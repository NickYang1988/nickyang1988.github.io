<search>
    
     <entry>
        <title>关于WebSocket的一些总结</title>
        <url>https://cppfans.org/2247.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>HTTP</tag><tag>WebSocket</tag><tag>ws</tag>
        </tags>
        <content type="html">  WebSocket下面简称ws
ws出现之前的http连接 在ws出现以前，http都是客户端发起-服务器回应的模式，全靠客户端主动交流，服务器完全是被动等待请求，回复数据。如果需要服务器主动推送信息给客户端(例如现在手机上的应用提醒），只能靠客户端主动pulling 或 long pulling不间断的请求服务器获取数据，并且http是无状态的，每次请求数据的时候都需要带认证信息，还需要每次进行tcp连接，非常消耗资源。
 关于 pulling 和 long pulling 的介绍，点击查看
 WebSocket协议 先来看一个ws的握手请求
GET / HTTP/1.1 Host: 127.0.0.1:8080 Connection: Upgrade Upgrade: websocket User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 Accept-Encoding: gzip, deflate, sdch Accept-Language: zh-CN,zh;q=0.8 Sec-WebSocket-Version: 13 Sec-WebSocket-Key: VR&#43;OReqwhymoQ21dBtoIMQ== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits  跟http类似，不过需要带上Connection和Upgrade域，告诉服务器，我要升级为ws连接，
各个域介绍是：
 必须是有效的http request格式
 HTTP request method 必须是GET，协议应不小于1.1 如： Get / HTTP/1.1
 必须包括Upgrade头域，并且其值为websocket
 必须包括Connection头域，并且其值为Upgrade
 必须包括Sec-WebSocket-Key头域，其值采用base64编码的随机16字节长的字符序列
 如果请求来自浏览器客户端，还必须包括Origin头域 。 该头域用于防止未授权的跨域脚本攻击，服务器可以从Origin决定是否接受该WebSocket连接
 必须包括Sec-webSocket-Version头域，当前值必须是13
 可能包括Sec-WebSocket-Protocol，表示client（应用程序）支持的协议列表，server选择一个或者没有可接受的协议响应之
 可能包括Sec-WebSocket-Extensions， 协议扩展， 某类协议可能支持多个扩展，通过它可以实现协议增强
 可能包括任意其他域，如cookie
  服务器端响应如下：
HTTP/1.1 101 Web Socket Protocol Handshake Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: Y&#43;Te7S7wQJC0FwXumEdGbv9/Mek=  说明：
 必须包括Upgrade头域，并且其值为websocket
 必须包括Connection头域，并且其值为Upgrade
 必须包括Sec-WebSocket-Accept头域，其值是将请求包Sec-WebSocket-Key的值，与258EAFA5-E914-47DA-95CA-C5AB0DC85B11这个字符串进行拼接，然后对拼接后的字符串进行sha-1运算，再进行base64编码，就是Sec-WebSocket-Accept的值
 应答包中冒号后面有一个空格
 最后需要两个空行作为应答包结束
  然后就建立通信了，后续就是ws的双向通信了，http就不用了。
 ws和http一样，都是默认监听80和443端口
 </content>
    </entry>
    
     <entry>
        <title>接口设计六大原则</title>
        <url>https://cppfans.org/2245.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>原则</tag><tag>接口</tag><tag>设计</tag><tag>软件设计</tag>
        </tags>
        <content type="html">  一. 单一职责原则 Single Responsibility Principle, 简称SRP。
定义 There should never be more than one reason for a class to change
应该有且仅有一个原因引起类的变
准则 职责的划分？单一的定义和级别？
应该根据实际业务情况而定。关注变化点。
实际使用时，类很难做到职责单一，但是接口的职责应该尽量单一。
二. 里氏替换原则 Liskov Substitution Principle, 简称LSP。
定义 Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it
所有引用基类的地方必须能透明地使用其子类的对象
准则 里氏替换原则为良好的继承定义了一个规范：
子类必须完全实现父类的方法
子类可以有自己的个性（属性和方法）。
覆盖或实现父类的方法时输入参数可以被放大。
覆写或实现父类的方法时输出结果可以被缩小。
 注：在类中调用其他类时务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。
 三. 依赖倒置原则 Dependence Inversion Principle, 简称DIP
定义 High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.
翻译过来，包含三层含义：
高层模块不应该依赖低层模块，两者都应该依赖其抽象
抽象不应该依赖细节。
细节应该依赖抽象。
精简的定义： 面向接口编程。
案例 Test-Driven Development 测试驱动开发是依赖倒置原则的最好体现。
测试驱动开发要求先写测试类，测试通过才写实现类，这就要求你要先想接口定义。
依赖的三种写法：
构造函数传递依赖对象。
Setter方法传递依赖对象。
接口声明依赖对象。
最佳实践： 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。
变量的表面类型尽量是接口或抽象类。
任何类都不应该从具体类派生。
尽量不要覆写基类的方法。
结合里氏替换原则使用。
四. 接口隔离原则： 接口这里指用interface关键字定义的接口。
定义： Clients should not be forced to depend upon interfaces that they don’t use.(客户端不应该依赖它不需要的接口)
The dependency of one class to anther one should depend on the smallest possible interface.(类间的依赖关系应该建立在最小的接口上)
概括：建立单一接口，不要建立臃肿庞大的接口。
通俗来讲：接口尽量细化，同时接口中的方法尽量少。
准则 如何细化？细化到什么程序？
没有统一的标准，应根据业务合理细分，适合业务才是重点。
保证接口的纯结性：
接口要尽量小。
接口要高内聚。
定制服务。
接口的设计是有限度的。
最佳实践： 一个接口只服务于一个子模块或业务逻辑。
通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法。
已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理。
了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，不要盲从大师的设计，要根据业务逻辑进行最好的接口设计。
五.迪米特法则 Law of Demeter, LOD。又称最少知识原则（Least Knowledge Principle, LKP）。
定义： 一个对象应该对其他对象保持最少的了解。
准则： 通俗来讲：一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没有关系，那是你的事情，我就调用你提供的public方法，其他一概不关心。
低耦合要求：
只和朋友交流
朋友类：出现在成员变量、方法的输入输出参数中的类。方法体内部的类不属于朋友类。
朋友间也是有距离的
迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。
是自己的就是自己的
如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，就放置在本类中。
谨慎使用Serializable
六.开闭原则 定义： Software entities like classes, modules and functions should be open for extension but closed for modifications.
一个软件实体如类、模块和函数应该对扩展开放，对修改关闭
准则： 软件实体包括以下几个部分：
项目和软件产品中按照一定的逻辑规则划分的模块。
抽象和类。
方法。
变化的三种类型：
逻辑变化
子模块变化
可见视图变化
 本文转载自：http://blog.bihe0832.com/principles.html
 </content>
    </entry>
    
     <entry>
        <title>Unity3D 2017.x Failed to start Unity Package Manager</title>
        <url>https://cppfans.org/2233.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>Unity</tag>
        </tags>
        <content type="html"> 升级到U3D 2017.x后，发现打开任何工程都会卡在Starting server处，经查看Editor.log后发现，是重试了几次后超时了，导致无法连接UnityPackageManager，网上搜了下之后，用如下方法解决的。先记录下，
修改hosts记录，将UNITY_NOPROXY设置为127.0.0.1
Windows下：
打开 C:\Windows\System32\drivers\etc\hosts
增加一行 127.0.0.1 localhost
在控制台下使用命令 setx UNITY_NOPROXY localhost,127.0.0.1
&amp;nbsp;
Mac下：
打开 /etc/hosts
增加一行 127.0.0.1 localhost
在中断下使用命令 export UNITY_NOPROXY=localhost,127.0.0.1
&amp;nbsp;
然后重新打开项目即可
</content>
    </entry>
    
     <entry>
        <title>ArkGameFrame开源跨平台游戏服务器框架0.2.0版本发布</title>
        <url>https://cppfans.org/2224.html</url>
        <categories>
          <category>ARK-GAME</category>
        </categories>
        <tags>
          <tag>ArkGame</tag><tag>ArkGameFrame</tag><tag>服务器</tag><tag>游戏</tag><tag>网游服务器</tag>
        </tags>
        <content type="html"> 各位朋友好，ArkGameFrame 0.2.0 版本发布了，Ark 是一个游戏服务器框架，主要提供了抽象的数据组织结构和通用的服务器架构，主要特性包括：
 抽象且通用的数据组织框架 面向数据和接口编程 事件和数据驱动模式 插件化和模块化 自由组织的分布式架构 跨平台 Excel 配置文件(对策划友好) 高性能(libevent &#43; evpp &#43; POD 数据类型) 配套的 U3D 简易客户端  Ark 的 app 组成方式如图： 后续计划：
 工具持续优化 易用性持续优化 带逻辑功能和 UI 的客户端 基于贝密开源棋牌客户端，开发一套简易的棋牌 demo 其他插件，例如：脚本，navi，db 等  ArkGameFrame 地址：
Github: https://github.com/ArkGame/ArkGameFrame
欢迎大家试用交流，QQ 群：540961187
大家有任何游戏相关的问题均可以讨论交流。
最后，欢迎大家 star、提 issue、加入ARK Game开源组织。
</content>
    </entry>
    
     <entry>
        <title>说说协程coroutine</title>
        <url>https://cppfans.org/2217.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>coroutine</tag><tag>协程</tag><tag>异步</tag>
        </tags>
        <content type="html"> 近几年来，协程的概念和使用被越多越多的人提到了，确实帮助很多人解决了很多问题，例如网络上的问题，异步逻辑流程控制等。我的工作中也接触到一些，所以打算总结下。
简单来说，协程就是一种用户态、编程语言层面的轻量级线程。
然而线程与协程又有很多差异的地方，线程是靠操作系统OS本身来调度，是抢占式的任务处理方式，谁抢到算谁的，所以大部分多线程程序中都要单独调用sleep来让出CPU给其他线程；线程每次阻塞、切换时都需要系统调用system call，然后调用调度函数来决定运行哪一个线程；协程拥有自己的用户态的上下文和栈(分为stackless和stackfulness，这个下一篇文章来讲)，协程切换时，先将寄存器上下文和栈内容保存起来，再次切换回来的时候再恢复之前保存的内容继续运行；
通过上面的讲解，明白了一个道理，协程是编译器来保证的，线程是操作系统来调度的；协程能更好的保证流程，而线程需要仔细处理公共数据资源；协程本质是单线程的，能提高单个CPU core的性能，适合计算密集型的应用；协程切换非常轻量，所以能大量的使用，线程切换成本较高，一般要控制线程数。
&amp;nbsp;
协程的概念和原理明白了后，其实有点类似于异步事件驱动，可以看看libevent/libuv等经典的C语言库，发现大量使用了异步事件回调，有一个event_loop来循环检查要处理的事件，不过就是代码相对协程恶心了一些，协程能让用户以类似同步的方式来处理异步流程，更加便于理解。
&amp;nbsp;
不过协程也是有缺点的，无法利用现代多核机器的性能，所以还需要配合多进程来提高性能；有阻塞操作的时候依然会阻塞整个进程，需要用其他方式来解决。
还有一个东西是actor，这个是更符合人类思维的方式，属于类似消息通知的方式来处理异步事件，可惜现在没有非常好用的actor cpp库，其他语言有类似的库，例如Java的akka, .net的Akka.net, Orleans/Service fabric等。
</content>
    </entry>
    
     <entry>
        <title>我为什么离开MK</title>
        <url>https://cppfans.org/2203.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>发展</tag><tag>学习</tag><tag>总结</tag><tag>职业</tag>
        </tags>
        <content type="html">  近半年都没发过文章了，工作比较忙，自己也懒得写。近期因为我辞职在家休息，有了一个短暂的空闲期，所以打算总结下这一段时间的收获。
先说说工作上的事情，从13年底进MK，先是开发了《全民无双》，然后短暂9个月运营后，又去挑头开发了《择天记》项目，然后因为种种原因，现在辞职了。
说说为什么辞职，马云说过：员工辞职，只有两个原因，一个是钱不爽，一个是人不爽。本文无意吐槽老东家的事情，只能将我的辞职归结于我在MK得不到更好的职业发展，现阶段已经不适合我了。
我总结下来一个公司是否适合自己，主要有下面几点。
1.公司的发展是否能契合自身的职业发展 具体如何契合，比如职位，比如自身能力成长等，都是需要自己去琢磨去考虑。公司是否能提供专业技能和管理技能两条线的职位和机会是非常重要的。一味的追求管理上的职位，认为管理高于技术职位的公司是不可取的，但同时一些有技术背景并适合做管理的同学去做PM、业务leader这也是合理的。
2.公司的做事风格是否契合自己的风格 这一点比较难得，毕竟公司不是自己开的，一些必要的流程还是需要的，但如果公司事事都需要一个漫长的流程，我觉得对执行力会大打折扣。所以在不违背利益和大流程的前提下，我认为执行力是第一要素。结果导向是上位者的思维，中间需要高度的默契和超强的执行力才会把想法变成产品。
3.公司是否能够提供足够的平台 这点不同于上面提到的职业发展，职业发展是个人能力的提升，而平台是可以给你一个开阔的视野/目标，有了足够的信息和见识，才能不摸着石头过河，总结教训，完善产品内容。所以这个平台既要给自身带来业务能力的成长，又要带来思路上的拓宽。
&amp;nbsp;
区别于公司，自身的发展也很重要，打铁还需自身硬，毕竟不能事事靠公司，公司只能提供机会和平台。自身的发展我从一个技术人员的角度总结下来有如下几点。
1.自身的面对挑战的处理能力 一个人的发展不能事事顺利，总得需要这样那样的挑战，特别是之前自己没有接触过的技术，要用于查资料、钻研、挑战。忘记从哪里看到的一句话：有人有枪有粮，猪都能打胜仗；就是因为条件受限，有难度，才挑你上去。不要认为挑战是一个苦差事，越过高山才能看到山下的风景。
2.自身处理事情的思路 不同的事情有不同的处理思路，这种人我归纳为情商高，拧巴的人在大多数领域一定是做不成什么大事的。见风使舵得分什么时候儿。一个我认为比较好的方法是换位思考，只有你真正懂得对方的需求时，才能做出对方想要的结果。
3.保持学习的热情 我认识很多朋友，因为公司的开发人员少，外部认识的人少，做的产品也没大量的用户，导致自己慢慢降低了技术要求，以产品凑活能运营就可以了为目标，从而技能能力慢慢退化，吃了几年老本，出来看了下市场环境，发现不是从前的那个美好时代了，导致后续的路越来越窄。所以，保持一个刚入行的新鲜感和学习的热情度，对于一个技术人员来说，甚至管理人员来说，都是非常重要的。
4.认清谁是甲方 这是我学到的一个最深刻的地方，我们最开始跟TX合作的时候，很多产品需求都是对方运营组提出来的，而我们研发方认为没必要、麻烦、提升不了数据为由，各种拖延甚至拒绝，被喷了几次后，终于看清了对方才是爷，对方让你有一万种不重样儿的死法。人在屋檐下，不得不低头，老祖宗玩这个才是王。
&amp;nbsp;
最后，这篇文章是我的一些总结，并非什么职业指导、吐槽大会等，各位看着玩儿就行了。感谢各位同事朋友的关心，这件事情只是一个职业路上的选择而已，并没有任何上纲上线，地球离了谁都一样转。下一步会去哪儿再说吧，谢谢各位。
</content>
    </entry>
    
     <entry>
        <title>[转]并发编程：Actors模型和CSP模型</title>
        <url>https://cppfans.org/2176.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 一、前言 不同的编程模型与具体的语言无关，大部分现代语言都可以通过巧妙地结构处理实现不同的模型.杂谈的意思是很杂，想到哪儿写到哪儿，不对正确性负责 :D.
&amp;nbsp;
二、Actors模型 传统的并发模型主要由两种实现的形式，一是同一个进程下，多个线程天然的共享内存，由程序对读写做同步控制(有锁或无锁). 二是多个进程通过进程间通讯或者内存映射实现数据的同步.
Actors模型更多的使用消息机制来实现并发，目标是让开发者不再考虑线程这种东西，每个Actor最多同时只能进行一样工作，Actor内部可以有自己的变量和数据.
Actors模型避免了由操作系统进行任务调度的问题，在操作系统进程之上，多个Actor可能运行在同一个进程(或线程)中.这就节省了大量的Context切换.
在Actors模型中，每个Actor都有一个专属的命名”邮箱”, 其他Actor可以随时选择一个Actor通过邮箱收发数据,对于“邮箱”的维护，通常是使用发布订阅的机制实现的，比如我们可以定义发布者是自己，订阅者可以是某个Socket接口，另外的消息总线或者直接是目标Actor.
目前akka库是比较流行的Actors编程模型实现，支持Scala和Java语言.
&amp;nbsp;
三、CSP模型 CSP(Communicating Sequential Process)模型提供一种多个进程公用的“管道(channel)”, 这个channel中存放的是一个个”任务”.
目前正流行的go语言中的goroutine就是参考的CSP模型，原始的CSP中channel里的任务都是立即执行的，而go语言为其增加了一个缓存，即任务可以先暂存起来，等待执行进程准备好了再逐个按顺序执行.
&amp;nbsp;
四、CSP和Actor的区别  CSP进程通常是同步的(即任务被推送进Channel就立即执行，如果任务执行的线程正忙，则发送者就暂时无法推送新任务)，Actor进程通常是异步的(消息传递给Actor后并不一定马上执行). CSP中的Channel通常是匿名的, 即任务放进Channel之后你并不需要知道是哪个Channel在执行任务，而Actor是有“身份”的，你可以明确的知道哪个Actor在执行任务. 在CSP中，我们只能通过Channel在任务间传递消息, 在Actor中我们可以直接从一个Actor往另一个Actor传输数据. CSP中消息的交互是同步的，Actor中支持异步的消息交互.  &amp;nbsp;
五、参考文档  Scala中的actors和Go中的goroutines对比 CSP Model From Wiki  文章转载自：http://sobuhu.com/program/2014/09/07/concurrent-models.html
安利几个库：Theron，libgo
</content>
    </entry>
    
     <entry>
        <title>ArkGameFrame实战系列文章说明</title>
        <url>https://cppfans.org/2171.html</url>
        <categories>
          <category>ARK-GAME</category>
        </categories>
        <tags>
          <tag>ArkGameFrame</tag><tag>实战</tag><tag>服务器框架</tag><tag>游戏开发</tag>
        </tags>
        <content type="html"> ArkGameFrame是一个面向中小型企业的开源游戏服务器敏捷开发框架，继承自NFrame，主要是项目的管理方式不同，这块经过沟通，很难有一个大家都满意的结果，所以暂时新作一个组织结构来管理这几个项目，后面再看结果是否合并。 关于这个框架的设计过程的介绍文章，请查看NF博客。 前面我们已经通过一系列ArkGameFrame架构和设计的文章来说明Ark是如何设计的，以及里面用到了什么技术，相信大家已经对Ark有了一个比较全面的了解了。 不过俗话说：光说不练假把式，光练不说傻把式，下面我们会通过一系列游戏开发实战文章来逐步介绍如何通过Ark框架实现一个较完整的游戏服务器。 大致的文章如下:  游戏开发实战1–初始化网络库   游戏开发实战2–连接数据库   游戏开发实战3–登陆游戏   游戏开发实战4–游戏世界区服列表   游戏开发实战5–创建角色   游戏开发实战6–上线，进入城镇   游戏开发实战7–城镇场景对象同步   游戏开发实战8–城镇场景中属性同步   游戏开发实战9–进入副本   游戏开发实战10–副本怪物控制   游戏开发实战11–打怪升级   游戏开发实战12–下线存档   文章中的内容实现将会在ArkGameServer中实现，我们还在努力做服务器业务内容的开发。 如果大家对于Ark实战开发还有什么需求，可以在QQ群(341159815)里提出来，我们后续再补充进去。 ---------------------------------------------------------------分割线--------------------------------------------------------------- 因为ketoo的出书计划，所以上述文章暂时不会放出来。我会根据项目情况放出来一套新的实战文章出来，大家敬请期待。 具体请关注github上的ArkGame页面，将会在ArkGameServer中放出来 </content>
    </entry>
    
     <entry>
        <title>[转]高并发性能调试经验分享</title>
        <url>https://cppfans.org/2167.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>性能</tag><tag>调试</tag><tag>高并发</tag>
        </tags>
        <content type="html">  作者：helloworlds
链接：https://zhuanlan.zhihu.com/p/21348220
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 引文   4月份的时候看到一道面试题，据说是腾讯校招面试官提的：在多线程和高并发环境下，如果有一个平均运行一百万次才出现一次的bug，你如何调试这个bug？知乎原贴地址如下：腾讯实习生面试，这两道题目该怎么回答？ - 编程 .
遗憾的是知乎很多答案在抨击这道题本身的正确性，虽然我不是这次的面试官，但我认为这是一道非常好的面试题。当然，只是道加分题，答不上，不扣分。答得不错，说明解决问题的思路和能力要超过应届生平均水平。
之所以写上面这段，是因为我觉得大部分后台服务端开发都有可能遇到这样的BUG，即使没有遇到，这样的题目也能够激发大家不断思考和总结。非常凑巧的是，我在4月份也遇到了一个类似的而且要更加严重的BUG，这是我自己挖的一个很深的坑，不填好，整个项目就无法上线。
现在已经过去了一个多月，趁着有时间，自己好好总结一下，希望里面提到的一些经验和工具能够带给大家一点帮助。  项目背景   我们针对nginx事件框架和openssl协议栈进行了一些深度改造，以提升nginx的HTTPS完全握手计算性能。
由于原生nginx使用本地CPU做RSA计算，ECDHE_RSA算法的单核处理能力只有400 qps左右。前期测试时的并发性能很低，就算开了24核，性能也无法超过1万。
核心功能在去年底就完成了开发，线下测试也没有发现问题。经过优化后的性能提升几倍，为了测试最大性能，使用了很多客户端并发测试https性能。很快就遇到了一些问题：   第一个问题是nginx有极低概率（亿分之一）在不同地方 core dump。白天线下压力测试2W qps一般都要两三个小时才出一次core。每次晚上睡觉之前都会将最新的调试代码编译好并启动测试，到早上醒来第一眼就会去查看机器并祈祷不要出core，不幸的是，一般都会有几个到几十个core，并且会发现经常是在一个时间点集中core dump。线上灰度测试运行了6天，在第6天的早上才集中core dump了几十次。这样算来，这个core dump的概率至少是亿分之一了。 不过和面试题目中多线程不同的是，nginx采用的是多进程&#43;全异步事件驱动的编程模式（目前也支持了多线程，但只是针对IO的优化，核心机制还是多进程加异步）。在webserver的实现背景下，多进程异步相比多线程的优点是性能高，没有太多线程间的切换，而且内存空间独立，省去线程间锁的竞争。当然也有缺点，就是异步模式编程非常复杂，将一些逻辑上连续的事件从空间和时间切割，不符合人的正常思考习惯，出了问题后比较难追查。另外异步事件对网络和操作系统的底层知识要求较高，稍不小心就容易挖坑。   第二个问题是高并发时nginx存在内存泄漏。在流量低的时候没有问题，加大测试流量就会出现内存泄漏。   第三个问题，因为我们对nginx和openssl的关键代码都做了一些改造，希望提升它的性能。那么如何找到性能热点和瓶颈并持续优化呢？    其中第一和第二个问题的背景都是，只有并发上万qps以上时才有可能出现，几百或者一两千QPS时，程序没有任何问题。  core dump的调试   首先说一下core的解决思路，主要是如下几点：   gdb及debug log定位，发现作用不大。   如何重现bug？   构造高并发压力测试系统。   构造稳定的异常请求。    gdb及debug log效率太低   因为有core dump ，所以这个问题初看很容易定位。gdb 找到core dump点，btrace就能知道基本的原因和上下文了。
core的直接原因非常简单和常见，全部都是NULL指针引用导致的。不过从函数上下文想不通为什么会出现NULL值，因为这些指针在原生nginx的事件和模块中都是这么使用的，不应该在这些地方变成NULL。由于暂时找不到根本原因，还是先解决CORE dump吧，修复办法也非常简单，直接判断指针是否NULL，如果是NULL就直接返回，不引用不就完事了，这个地方以后肯定不会出CORE了。   这样的防守式编程并不提倡，指针NULL引用如果不core dump，而是直接返回，那么这个错误很有可能会影响用户的访问，同时这样的BUG还不知道什么时候能暴露。所以CORE DUMP 在NULL处，其实是非常负责任和有效的做法。   在NULL处返回，确实避免了在这个地方的CORE，但是过几个小时又core 在了另外一个NULL指针引用上。于是我又继续加个判断并避免NULL指针的引用。悲剧的是，过了几个小时，又CORE在了其他地方，就这样过了几天，我一直在想为什么会出现一些指针为NULL的情况？为什么会CORE在不同地方？为什么我用浏览器和curl这样的命令工具访问却没有任何问题？   熟悉nginx代码的同学应该很清楚，nginx极少在函数入口及其他地方判断指针是否为NULL值。特别是一些关键数据结构，比如‘ngx_connection_t’及SSL_CTX等，在请求接收的时候就完成了初始化，所以不可能在后续正常处理过程中出现NULL的情况。   于是我更加迷惑，显然NULL值导致出CORE只是表象，真正的问题是，这些关键指针为什么会被赋值成NULL？
这个时候异步事件编程的缺点和复杂性就暴露了，好好的一个客户端的请求，从逻辑上应该是连续的，但是被读写及时间事件拆成了多个片断。虽然GDB能准确地记录core dump时的函数调用栈，但是却无法准确记录一条请求完整的事件处理栈。根本就不知道上次是哪个事件的哪些函数将这个指针赋值为NULL的,甚至都不知道这些数据结构上次被哪个事件使用了。   举个例子：客户端发送一个正常的get请求，由于网络或者客户端行为，需要发送两次才完成。服务端第一次read没有读取完全部数据，这次读事件中调用了 A，B函数，然后事件返回。第二次数据来临时，再次触发read事件，调用了A，C函数。并且core dump在了C函数中。这个时候，btrace的stack frame已经没有B函数调用的信息了。   所以通过GDB无法准确定位 core 的真正原因  log debug的新尝试 
这时候强大的GDB已经派不上用场了。怎么办？打印nginx调试日志。
但是打印日志也很郁闷，只要将nginx的日志级别调整到DEBUG，CORE就无法重现。为什么？因为DEBUG的日志信息量非常大，频繁地写磁盘严重影响了NGINX的性能，打开DEBUG后性能由几十万直线下降到几百qps。
调整到其他级别比如 INFO,性能虽然好了，但是日志信息量太少，没有帮助。尽管如此，日志却是个很好的工具，于是又尝试过以下办法：   针对特定客户端IP开启debug日志，比如IP是10.1.1.1就打印DEBUG，其他IP就打印最高级别的日志，nginx本身就支持这样的配置。   关闭DEBUG日志，自己在一些关键路径添加高级别的调试日志，将调试信息通过EMERG级别打印出来。   nginx只开启一个进程和少量的connection数。抽样打印连接编号（比如尾号是1）的调试日志。    总体思路依然是在不明显降低性能的前提下打印尽量详细的调试日志，遗憾的是，上述办法还是不能帮助问题定位，当然了，在不断的日志调试中，对代码和逻辑越来越熟悉。  bug如何重现？   这时候的调试效率已经很低了，几万QPS连续压力测试，几个小时才出一次CORE，然后修改代码，添加调试日志。几天过去了，毫无进展。所以必须要在线下构造出稳定的core dump环境，这样才能加快debug效率。
虽然还没有发现根本原因，但是发现了一个很可疑的地方：
出CORE比较集中，经常是在凌晨4,5点，早上7,8点的时候 dump几十个CORE。  弱网络环境的构造 traffic control   联想到夜间有很多的网络硬件调整及故障，我猜测这些core dump可能跟网络质量相关。**特别是网络瞬时不稳定，很容易触发BUG导致大量的CORE DUMP。**
最开始我考虑过使用TC(traffic control)工具来构造弱网络环境，但是转念一想，弱网络环境导致的结果是什么？显然是网络请求的各种异常啊,所以还不如直接构造各种异常请求来复现问题。于是准备构造测试工具和环境，需要满足两个条件：   并发性能强，能够同时发送数万甚至数十万级以上qps。   请求需要一定概率的异常。特别是TCP握手及SSL握手阶段，需要异常中止。     traffic control是一个很好的构造弱网络环境的工具，我之前用过测试SPDY协议性能。能够控制网络速率、丢包率、延时等网络环境，作为iproute工具集中的一个工具，由linux系统自带。但比较麻烦的是TC的配置规则很复杂，facebook在tc的基础上封装成了一个开源工具apc，有兴趣的可以试试。   WRK压力测试工具   由于高并发流量时才可能出core，所以首先就需要找一个性能强大的压测工具。
WRK是一款非常优秀的开源HTTP压力测试工具，采用多线程 &#43; 异步事件驱动的框架，其中事件机制使用了redis的ae事件框架，协议解析使用了nginx的相关代码。
相比ab（apache bench）等传统压力测试工具的优点就是性能好，基本上单台机器发送几百万pqs,打满网卡都没有问题。
wrk的缺点就是只支持HTTP类协议，不支持其他协议类测试，比如protobuf，另外数据显示也不是很方便。   nginx的测试用法： wrk -t500 -c2000 -d30s https://127.0.0.1:8443/index.html   分布式自动测试系统的构建   由于是HTTPS请求，使用ECDHE_RSA密钥交换算法时，客户端的计算消耗也比较大，单机也就10000多qps。也就是说如果server的性能有3W qps，那么一台客户端是无法发送这么大的压力的，所以需要构建一个多机的分布式测试系统，即通过中控机同时控制多台测试机客户端启动和停止测试。
之前也提到了，调试效率太低，整个测试过程需要能够自动化运行，比如晚上睡觉前，可以控制多台机器在不同的协议，不同的端口，不同的cipher suite运行整个晚上。白天因为一直在盯着，运行几分钟就需要查看结果。
这个系统有如下功能：
1. 并发控制多台测试客户端的启停，最后汇总输出总的测试结果。
2. 支持https，http协议测试，支持webserver及revers proxy性能测试。
3. 支持配置不同的测试时间、端口、URL。
4. 根据端口选择不同的SSL协议版本，不同的cipher suite。
5. 根据URL选择webserver、revers proxy模式。  异常测试请求的构造   压力测试工具和系统都准备好了，还是不能准确复现core dump的环境。接下来还要完成异常请求的构造。构造哪些异常请求呢？
由于新增的功能代码主要是和SSL握手相关，这个过程是紧接着TCP握手发生的，所以异常也主要发生在这个阶段。于是我考虑构造了如下三种异常情形：   异常的tcp连接。即在客户端tcp connent系统调用时，10%概率直接close这个socket。   异常的ssl连接。考虑两种情况，full handshake第一阶段时，即发送 client hello时，客户端10%概率直接close连接。full handshake第二阶段时，即发送clientKeyExchange时，客户端10%概率直接直接关闭TCP连接。   异常的HTTPS请求，客户端10%的请求使用错误的公钥加密数据，这样nginx解密时肯定会失败。    core bug fix小结   构造好了上述高并发压力异常测试系统，果然，几秒钟之内必然出CORE。有了稳定的测试环境，那bug fix的效率自然就会快很多。
虽然此时通过gdb还是不方便定位根本原因，但是测试请求已经满足了触发CORE的条件，打开debug调试日志也能触发core dump。于是可以不断地修改代码，不断地GDB调试，不断地增加日志，一步步地追踪根源，一步步地接近真相。
最终通过不断地重复上述步骤找到了core dump的根本原因。其实在写总结文档的时候，core dump的根本原因是什么已经不太重要，最重要的还是解决问题的思路和过程，这才是值得分享和总结的。很多情况下，千辛万苦排查出来的，其实是一个非常明显甚至愚蠢的错误。
比如这次core dump的主要原因是：
由于没有正确地设置non-reusable，并发量太大时，用于异步代理计算的connection结构体被nginx回收并进行了初始化，从而导致不同的事件中出现NULL指针并出CORE。  内存泄漏   虽然解决了core dump，但是另外一个问题又浮出了水面，就是**高并发测试时，会出现内存泄漏，大概一个小时500M的样子**。  valgrind的缺点   出现内存泄漏或者内存问题，大家第一时间都会想到valgrind
valgrind是一款非常优秀的软件，不需要重新编译程序就能够直接测试。功能也非常强大，能够检测常见的内存错误包括内存初始化、越界访问、内存溢出、free错误等都能够检测出来。推荐大家使用。
valgrind 运行的基本原理是：
待测程序运行在valgrind提供的模拟CPU上，valgrind会纪录内存访问及计算值，最后进行比较和错误输出
我通过valgrind测试nginx也发现了一些内存方面的错误，简单分享下valgrind测试nginx的经验：   nginx通常都是使用master fork子进程的方式运行，使用–trace-children=yes来追踪子进程的信息   测试nginx &#43; openssl时，在使用rand函数的地方会提示很多内存错误。比如Conditional jump or move depends on uninitialised value，Uninitialised value was created by a heap allocation等。这是由于rand数据需要一些熵，未初始化是正常的。如果需要去掉valgrind提示错误，编译时需要加一个选项：-DPURIFY   如果nginx进程较多，比如超过4个时，会导致valgrind的错误日志打印混乱，尽量减小nginx工作进程,保持为1个。因为一般的内存错误其实和进程数目都是没有关系的。    上面说了valgrind的功能和使用经验，但是valgrind也有一个非常大的缺点，就是它会显著降低程序的性能，官方文档说使用memcheck工具时，降低10-50倍
也就是说，如果nginx完全握手性能是20000 qps,那么使用valgrind测试，性能就只有400 qps左右。对于一般的内存问题，降低性能没啥影响，但是我这次的内存泄漏是在大压力测试时才可能遇到的，如果性能降低这么明显，内存泄漏的错误根本检测不出来。
只能再考虑其他办法了。  AddressSanitizer的优点   address sanitizer（简称asan）是一个用来检测c/c&#43;&#43;程序的快速内存检测工具。相比valgrind的优点就是速度快，官方文档介绍对程序性能的降低只有2倍。
对Asan原理有兴趣的同学可以参考asan的算法这篇文章，它的实现原理就是在程序代码中插入一些自定义代码，如下： 编译前： *address = ...; // or: ... = *address; 编译后： if (IsPoisoned(address)) { ReportError(address, kAccessSize, kIsWrite); } *address = ...; // or: ... = *address;`    和valgrind明显不同的是，asan需要添加编译开关重新编译程序，好在不需要自己修改代码。而valgrind不需要编程程序就能直接运行。
address sanitizer集成在了clang编译器中，GCC 4.8版本以上才支持。我们线上程序默认都是使用gcc4.3编译，于是我测试时直接使用clang重新编译nginx： &amp;ndash;with-cc=&amp;ldquo;clang&amp;rdquo; \ &amp;ndash;with-cc-opt=&amp;ldquo;-g -fPIC -fsanitize=address -fno-omit-frame-pointer&amp;rdquo; 其中with-cc是指定编译器，with-cc-opt指定编译选项， -fsanitize=address就是开启AddressSanitizer功能。  
 由于AddressSanitizer对nginx的影响较小，所以大压力测试时也能达到上万的并发，内存泄漏的问题很容易就定位了。
这里就不详细介绍内存泄漏的原因了，因为跟openssl的错误处理逻辑有关，是我自己实现的，没有普遍的参考意义。
最重要的是，知道valgrind和asan的使用场景和方法，遇到内存方面的问题能够快速修复。  性能热点分析 
 到此，经过改造的nginx程序没有core dump和内存泄漏方面的风险了。但这显然不是我们最关心的结果（因为代码本该如此），我们最关心的问题是：
1. 代码优化前，程序的瓶颈在哪里？能够优化到什么程度？
2. 代码优化后，优化是否彻底？会出现哪些新的性能热点和瓶颈？
这个时候我们就需要一些工具来检测程序的性能热点。  perf，oprofile，gprof，systemtap 
 linux世界有许多非常好用的性能分析工具，我挑选几款最常用的简单介绍下：
1. perf应该是最全面最方便的一个性能检测工具。由linux内核携带并且同步更新，基本能满足日常使用。推荐大家使用。
2. oprofile，我觉得是一个较过时的性能检测工具了，基本被perf取代，命令使用起来也不太方便。比如opcontrol &amp;ndash;no-vmlinux , opcontrol &amp;ndash;init等命令启动，然后是opcontrol &amp;ndash;start， opcontrol &amp;ndash;dump， opcontrol -h停止，opreport查看结果等，一大串命令和参数。有时候使用还容易忘记初始化，数据就是空的。
3. gprof主要是针对应用层程序的性能分析工具，缺点是需要重新编译程序，而且对程序性能有一些影响。不支持内核层面的一些统计，优点就是应用层的函数性能统计比较精细，接近我们对日常性能的理解，比如各个函数时间的运行时间，，函数的调用次数等，很人性易读。
4. systemtap 其实是一个运行时程序或者系统信息采集框架，主要用于动态追踪，当然也能用做性能分析，功能最强大，同时使用也相对复杂。不是一个简单的工具，可以说是一门动态追踪语言。如果程序出现非常麻烦的性能问题时，推荐使用 systemtap。  这里再多介绍一下perf命令，tlinux系统上默认都有安装，比如通过perf top就能列举出当前系统或者进程的热点事件，函数的排序。
perf record能够纪录和保存系统或者进程的性能事件，用于后面的分析，比如接下去要介绍的火焰图。  火焰图 flame graph 
 perf有一个缺点就是不直观。火焰图就是为了解决这个问题。它能够以矢量图形化的方式显示事件热点及函数调用关系。
比如我通过如下几条命令就能绘制出原生nginx在ecdhe_rsa cipher suite下的性能热点：   perf record -F 99 -p PID -g &amp;ndash; sleep 10   perf script | ./stackcollapse-perf.pl &amp;gt; out.perf-folded   ./flamegraph.pl out.perf-folded&amp;gt;ou.svg  
 直接通过火焰图就能看到各个函数占用的百分比，比如上图就能清楚地知道rsaz_1024_mul_avx2和rsaz_1024_sqr_avx2函数占用了75%的采样比例。那我们要优化的对象也就非常清楚了，能不能避免这两个函数的计算？或者使用非本地CPU方案实现它们的计算？
当然是可以的，我们的异步代理计算方案正是为了解决这个问题，从上图可以看出，热点事件里已经没有RSA相关的计算了。至于是如何做到的，后面有时间再写专门的文章来分享。  心态 
 为了解决上面提到的core dump和内存泄漏问题，花了大概三周左右时间。压力很大，精神高度紧张， 说实话有些狼狈，看似几个很简单的问题，搞了这么长时间。心里当然不是很爽，会有些着急，特别是项目的关键上线期。但即使这样，整个过程我还是非常自信并且斗志昂扬。我一直在告诉自己：   调试BUG是一次非常难得的学习机会，不要把它看成是负担。不管是线上还是线下，能够主动地，高效地追查BUG特别是有难度的BUG，对自己来说一次非常宝贵的学习机会。面对这么好的学习机会，自然要充满热情，要如饥似渴，回首一看，如果不是因为这个BUG，我也不会对一些工具有更深入地了解和使用，也就不会有这篇文档的产生。   不管什么样的BUG，随着时间的推移，肯定是能够解决的。这样想想，其实会轻松很多，特别是接手新项目，改造复杂工程时，由于对代码，对业务一开始并不是很熟悉，需要一个过渡期。但关键是，你要把这些问题放在心上。白天上班有很多事情干扰，上下班路上，晚上睡觉前，大脑反而会更加清醒，思路也会更加清晰。特别是白天上班时容易思维定势，陷入一个长时间的误区，在那里调试了半天，结果大脑一片混沌。睡觉前或者上下班路上一个人时，反而能想出一些新的思路和办法。   开放地讨论。遇到问题不要不好意思，不管多简单，多低级，只要这个问题不是你google一下就能得到的结论，大胆地，认真地和组内同事讨论。这次BUG调试，有几次关键的讨论给了我很大的启发，特别是最后reusable的问题，也是组内同事的讨论才激发了我的灵感。谢谢大家的帮助。   
作者介绍 罗成
 高级研发工程师，现任职于腾讯TEG基础架构部，对HTTPS、SPDY、HTTP2等应用层协议、高性能服务器技术、用户访问速度及运维技术有较深理解。 曾供职于百度，主导百度安全搜索全站HTTPS的性能优化，作为核心成员实现了百度网盟广告配置文件传输系统及百度早期的持续部署系统。  文章转载自：https://zhuanlan.zhihu.com/p/21348220
</content>
    </entry>
    
     <entry>
        <title>Jason Bourne 5观影感</title>
        <url>https://cppfans.org/2162.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>电影</tag><tag>谍影重重5</tag>
        </tags>
        <content type="html"> 自从07年第三部结束后，我一直都在等待《谍影重重》后续的电影，到了4，发现不是马特达蒙演的，而且剧情只是因为跟绊脚石计划都一些关联，所以非常失望，到了今年8.23，终于上映了5，先来张海报过过瘾。
23号晚上下班后和同事去看了首映，巨幕厅，整个剧情和人物都很棒，唯一不爽的是竟然是3D的，里面充斥着大量的街头摩托车，动作戏，整个是纪实拍摄风格，3D导致非常晃，有点眼晕。
不过另外一波去看的同事，反映说不好看，后来回想了下前三部，发现确实是有变化，前三部都讲了一个反政府的前特工在找寻自我的过程，充满着个人英雄主义和孤独主义，5直接变成了记忆全面恢复后的报仇，并且有各种漂亮妹子帮忙，变成了类似于碟中谍类型了，这点上可能让大家觉得有点失望。
 但是，纵观整部电影，前面做了大量铺垫，后面情节紧凑，动作戏十足，用各种工具的NB特工又回来了，还是看的非常爽的，总算满足了众多粉丝的期望。
 最后，送上片尾曲Extreme ways，最开始觉得这个片尾曲非常应景的是在3里，中枪后落入水中，静止了10多秒，然后突然向前游走，以及5里，开放性结局之后，大家猜猜，Bourne会不会回归CIA？
 </content>
    </entry>
    
     <entry>
        <title>A simple Spark test project</title>
        <url>https://cppfans.org/2142.html</url>
        <categories>
          <category>大数据</category><category>技术文章</category>
        </categories>
        <tags>
          <tag>Big data</tag><tag>sbt</tag><tag>Scala</tag><tag>Spark</tag>
        </tags>
        <content type="html"> I start to learn Spark to process some log files, here is a simple example.
How to build Spark, please see http://spark.apache.org/docs/latest/building-spark.html
Scala file
import org.apache.spark.SparkContext import org.apache.spark.SparkContext._ import org.apache.spark.SparkConf object SimpleApp { def main(args: Array[String]) { val conf = new SparkConf().setAppName(&#34;wordCount&#34;) val sc = new SparkContext(conf) val input = sc.textFile(&#34;/home/nickyang/develop/spark/spark-1.6.1/README.md&#34;) val words = input.flatMap(line =&amp;gt; line.split(&#34; &#34;)) val couts = words.map(word =&amp;gt; (word, 1)).reduceByKey{case (x, y) =&amp;gt; x &#43; y} couts.saveAsTextFile(&#34;/home/nickyang/develop/spark/spark-1.6.1/examples/wordCount/result&#34;) } } sbt file(use sbt to build this example)
name := &#34;SampleApp&#34; version := &#34;0.0.1&#34; scalaVersion := &#34;2.10.5&#34; libraryDependencies &#43;= &#34;org.apache.spark&#34; %% &#34;spark-core&#34; % &#34;1.6.2&#34; % &#34;provided&#34; sbt package  YOUR_SPARK_HOME/bin/spark-submit --class &amp;lt;span class=&#34;s2&#34;&#34;SimpleApp&#34;&amp;lt;/span --master &amp;lt;span class=&#34;nb&#34;local&amp;lt;/span&amp;lt;span class=&#34;o&#34;[&amp;lt;/span1&amp;lt;span class=&#34;o&#34;]&amp;lt;/span target/scala-2.11/sampleapp_2.10-0.0.1.jar The result is in result directory, two files, one is _SUCCESS that tells us the right result, the other one is &amp;ldquo;part-00000&amp;rdquo;, contains words and words&amp;rsquo; count in this text file.
(package,1)
(For,2)
(Programs,1)
(processing.,1)
(Because, 1)
(The,1)
(cluster.,1)
(its,1)
([run,1)
(APIs,1)
(have,1)
(Try,1)
&amp;hellip;
&amp;nbsp;
BTW. this article is written in Ubuntu, haven&amp;rsquo;t Chinese input method(English version).
</content>
    </entry>
    
     <entry>
        <title>尽量减少与低情商人群交流</title>
        <url>https://cppfans.org/2139.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>团队</tag><tag>工作</tag><tag>生活</tag>
        </tags>
        <content type="html"> 好久没有更新博客了，最近一直忙于搬家和新项目的事情，每天感觉无比心累，主要更多的还是跟人打交道上。故随意写了这一篇文章。
先摘录一段从网上关于低情商的九个表现。
 不喜欢换位思考，不在意别人感受 在众人面前，通过贬低别人来抬高自己 始终要在言语上胜过别人 负面情绪主导意识 只在意自己的表达，并不能察觉别人对自己表达的态度 问明知故问的问题，说话戳人痛处，哪壶不开提哪壶 即使是对最陌生、最无关的人，仍然过分在意其对自己的看法 对别人的生活指手画脚 把最好的脾气给了陌生人，最差的耐心给了亲人  而情商更多的时候表现在与人沟通打交道上面了，我上大学恋爱的时候，也经常被吐槽情商差，后来随着生活阅历、工作经验时间越来越丰富，逐渐理解了到底怎么样才算是高情商。对于如何提高情商，我也不好说，只能说努力观察学习吧。
这篇文章主要是想说说为什么要尽量避免跟情商低的沟通，因为会浪费大量时间和精力，不划算。
1.典型的自我为中心，从来不换位思考，从而评价别人的做法
生活中我们可能或多或少的都会遇到一些人对自己的事情各种评价，说好听点叫出谋划策，难听点叫指手画脚。每个人都有自己的世界观、价值观、生活方式，只需要给关心的人适合而止的建议即可，多的都会引起对方的反感。具体什么是适合而止，需要自己去琢磨了。
2.语言上胜过别人，不关注其他人表达的意思
工作中有一种人，为了彰显自己的职位或者重要性，其他人提出来任何方案，不管是否听明白，不管是否跟自己的方案部分一致，统一先做反对意见，然后再抛出自己的不同观点。当然了，别人的方案不管怎么样，或多或少都会有一些问题，而这种人就是专业将这些问题放大，然后提一些模棱两可无法具化实现的方案出来。
3.负面情绪过多
这种人是一定要远离的，他/她的生活或者工作每天都有不如意，给别人感觉要么真是他/她的生活充满苦痛、工作被人针对，要么是被迫害妄想症，这种人每天做的最多的事情就是诉苦，各种吐槽，别人老板多好、别人家庭多好。
&amp;nbsp;
这些人会让你觉得非常难沟通，说东道西、驴唇不对马嘴，否定别人的辛苦，带来的全是负能量。如果长期与这种人打交道，我保证等你醒悟了会骂自己是SB，为什么要浪费时间、为什么要要忙其他团队趟坑(其他团队可能还不领情)，为什么要扭转别人的想法……
具体的例子我遇到过很多，但是我不想拿出来讲了。这些人最后要么离开了团体，要么呆在了都是那种人的团体。
总之，我建议尽量远离这种人吧，TVB里一句很经典的台词“做人最重要的是开心”，为何不自己选择开心的团队、开心的人去交流，每个人都有选择权。
</content>
    </entry>
    
     <entry>
        <title>[转]你闺女也能看懂的插画版Kubernetes指南</title>
        <url>https://cppfans.org/2133.html</url>
        <categories>
          <category>虚拟化</category>
        </categories>
        <tags>
          <tag>docker</tag><tag>Kubernetes</tag><tag>容器</tag><tag>虚拟化</tag>
        </tags>
        <content type="html"> 编者按：Matt Butcher是Deis的平台架构师，热爱哲学，咖啡和精雕细琢的代码。有一天女儿走进书房问他什么是Kubernetes，于是就有了这本插画版的Kubernetes指南，讲述了勇敢的Phippy（一个PHP应用），在Kubernetes的冒险故事，满满的父爱有木有！
 （视频版建议在wifi环境下打开，土豪请随意）  https://v.qq.com/iframe/preview.html?vid=b0310drhj31&amp;width=500&amp;height=375&amp;auto=0  Hope You Enjoy The Story~      有一天，女儿走进书房问我：『亲爱的爸爸，什么是Kubernetes呢？』
我回答她：『Kubernetes是一个开源的Docker容器编排系统，它可以调度计算集群的节点，动态管理上面的作业，保证它们按用户期望的状态运行。通过使用「labels」和「pods」的概念，Kubernetes将应用按逻辑单元进行分组，方便管理和服务发现。』
 女儿更疑惑了……于是就有了这个故事      很久很久以前，有一个叫Phippy的PHP应用，她很单纯，只有一个页面。她住在一个托管服务里，周围还有很多可怕的应用，她都不认识，也不想去认识，但是他们却要共享这里的环境。所以，她一直都希能有一个属于自己的环境：一个可以称作home的webserver。
每个应用的运行都要依赖一个环境，对于一个PHP应用来说，这个环境包括了一个webserver，一个可读的文件系统和PHP的engine。
有一天，一只可爱的鲸鱼拜访了Phippy，他建议Phippy住在容器里。Phippy听从了鲸鱼的建议搬家了，虽然这个容器看起来很好，但是……怎么说呢，就像是漂浮在海上的一个小房间一样，还是没有家的感觉。
不过容器倒是为应用提供了隔离的环境，在这个环境里应用就能运行起来。但是这些相互隔离的容器需要管理，也需要跟外面的世界沟通。共享的文件系统，网络，调度，负载均衡和资源分配都是挑战。
『抱歉……孩子……』鲸鱼耸耸肩，一摇尾消失在了海平面下……Phippy还没有来得及失望，就看到远方驶来一艘巨轮，掌舵的老船长非常威风。这艘船乍一看就是大了点，等到船走近了，Phippy才发现船体两边挂满了皮筏。

老船长用充满智慧的语气对Phippy说：『你好，我是Kube船长』。      『Kubernetes』是希腊语中的船长，后来的『Cybernetic』和『Gubernatorial』这两个词就是从Kubernetes衍生来的。Kubernetes项目由Google发起，旨在为生产环境中成千上万的容器，构建一个健壮的平台。
 『您好，我是Phippy。』  『很高兴认识你。』船长边说，边在Phippy身上放了一个name tag。       Kubernetes使用label作为『nametag』来区分事物，还可以根据label来查询。label是开放式的：可以根据角色，稳定性或其它重要的特性来指定。      Kube船长建议Phippy可以把她的容器搬到船上的pod里，Phippy很高兴地接受了这个提议，把容器搬到了Kube的大船上。Phippy感觉自己终于有家了。
在Kubernetes中，pod代表着一个运行着的工作单元。通常，每个pod中只有一个容器，但有些情况下，如果几个容器是紧耦合的，这几个容器就会运行在同一个pod中。Kubernetes承担了pod与外界环境通信的工作。
Phippy对这一切都感到很新奇，同时她也有很多与众不同的关注点：『如果我想要复制自己该怎么做呢？按需的……任意次数的可以吗？』
 『很简单。』船长说道，接着就给Phippy介绍起了replication controller。      Replication controller提供了一种管理任意数量pod的方式。一个replication controller包含了一个pod模板，这个模板可以被不限次数地复制。通过replication controller，Kubernetes可以管理pod的生命周期，包括扩/缩容，滚动部署和监控等功能。
Phippy就这样在船上和自己的副本愉快地生活了好多天。但是每天只能面对自己的副本，这样的生活也太孤单了。
 Kube船长慷慨地笑道：『我有好东西给你。』  说着，Kube船长就在Phippy的replication controller和船上其它地方之间建了一个隧道：『就算你们四处移动，这个隧道也会一直待在这里，它可以帮你找到其它pod，其它pod也可以找到你。』      service可以和Kubernetes环境中其它部分（包括其它pod和replication controller）进行通信，告诉它们你的应用提供什么服务。Pod可以四处移动，但是service的IP地址和端口号是不便、变的。而且其它应用可以通过Kubernetes的服务发现找到你的service。
有了service，Phippy终于敢去船上其它地方去玩了，她很快就有了新朋友Goldie。有一天，Goldie送了Phippy一件礼物，没想到Phippy只看了一眼就哭了。
 『你怎么哭了？』Goldie问道。  『我太喜欢这个礼物了，可惜没地儿放……』Phippy都开始抽泣了。Goldie一听原来是这么回事，马上就告诉Phippy：『为什么不放在一个volume里呢？』      Volume代表了一块容器可以访问和存储信息的空间，对于应用来说，volume是一个本地的文件系统。实际上，除了本地存储，Ceph、Gluster、Elastic Block Storage和很多其它后端存储都可以作为volume。
Phippy渐渐地爱上了船上的生活，她很享受和新朋友的相处（Goldie的每个pod副本也都很nice）。但是回想起以前的生活，她又在想是不是可以有一点点私人空间呢？
 Kube船长很理解：『看起来你需要namespace。』      Namespace是Kubernetes内的分组机制。Service，pod，replication controller和volume可以很容易地和namespace配合工作，但是namespace为集群中的组件间提供了一定程度的隔离。
于是，在Kube船长的船上，Phippy和她的朋友们开始了海上的历险，最重要的是，Phippy找到了自己的家。
 从此，Phippy过上了幸福的生活。  原文链接：https://deis.com/blog/2016/kubernetes-illustrated-guide/  周小璐译  原文出处：灵雀云      </content>
    </entry>
    
     <entry>
        <title>[已放弃]打算迁移博客至hexo&#43;github pages</title>
        <url>https://cppfans.org/2126.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 打算迁移博客至hexo&#43;github pages，期间可能会出现无法访问等各种问题，请各位朋友不要惊慌，马上会修复。
一直想换成静态博客，不过苦于一直没时间折腾hexo，总觉得又要学一套东西，不过现在想了想还是得做这一步，折腾无极限嘛，一来方便管理，二来可以让更多的人参与，三呢可以装逼，所以决定换成hexo &#43; GitHub pages作为博客，各位不要喷我，可能会丢失图片，评论等内容，不过不破不立，各位共勉吧。
&amp;nbsp;
正在折腾中，各位等结果吧。
折腾了一圈，算是全部都弄好了，但是呢，问题也是不少的，文章名等等全变了，迁移的过程中，图片没办法弄过去，https暂时不能直接设置，总体原因还是我不熟悉，基于这些原因，我还是选择这个博客放弃了，后面再开新站的时候可以考虑hexo。
</content>
    </entry>
    
     <entry>
        <title>[转]理解Python装饰器</title>
        <url>https://cppfans.org/2117.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>Decarator</tag><tag>Partten</tag><tag>python</tag><tag>装饰器</tag>
        </tags>
        <content type="html">  作者：xlzd
链接：http://www.zhihu.com/question/26930016/answer/81263287
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。简单来讲，可以不严谨地把Python的装饰器看做一个包装函数的函数。
 比如，有一个函数： &amp;lt;span class=&#34;k&#34;def&amp;lt;/span &amp;lt;span class=&#34;nf&#34;func&amp;lt;/span&amp;lt;span class=&#34;p&#34;():&amp;lt;/span &amp;lt;span class=&#34;k&#34;print&amp;lt;/span &amp;lt;span class=&#34;s&#34;&#39;func() run.&#39;&amp;lt;/span &amp;lt;span class=&#34;k&#34;if&amp;lt;/span &amp;lt;span class=&#34;s&#34;&#39;__main__&#39;&amp;lt;/span &amp;lt;span class=&#34;o&#34;==&amp;lt;/span &amp;lt;span class=&#34;n&#34;__name__&amp;lt;/span&amp;lt;span class=&#34;p&#34;:&amp;lt;/span &amp;lt;span class=&#34;n&#34;func&amp;lt;/span&amp;lt;span class=&#34;p&#34;()&amp;lt;/span    运行后将输出: &amp;lt;span class=&amp;ldquo;go&amp;rdquo;&amp;gt;func() run.&amp;lt;/span&amp;gt;  
 现在需要在函数运行前后打印一条日志, 但是又不希望或者没有权限修改函数内部的结构, 就可以用到装饰器(decorator): &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;log&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;before function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run.&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;after function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run.&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;ldquo;nd&amp;rdquo;&amp;gt;@log&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;():&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;func() run.&amp;rsquo;&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;rsquo;main&amp;lsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;==&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;:&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;()&amp;lt;/span&amp;gt;  
 对于原来的函数&amp;rdquo;func()&amp;ldquo;并没有做修改,而是给其使用了装饰器log,运行后的输出为: &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;before&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;()]&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;run&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;()&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;run&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;after&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;()]&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;run&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;  
 把&amp;rdquo;@log&amp;rdquo;放到func()函数定义的地方,相当于执行了如下语句: &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;log&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt;  
 因为log()返回了一个函数, 所以原本的func指向了log()返回的函数wrapper。wrapper的参数列表为(*args, **kwargs), 所以其可以接受所有的参数调用, 在wrapper中,先打印了一行  &amp;lsquo;before function [%s()] run.&amp;rsquo; % function.name  (在Python中函数也是对象,函数的name是它的名字),然后执行了原来的函数并记录了返回值,在输出  &amp;lsquo;after function [%s()] run.&amp;rsquo; % function.name  后返回了函数的执行结果。  如果decorator本身需要传入参数，那就需要编写一个返回decorator的decorator。比如在Flask中: @app.route(&amp;lsquo;/&amp;rsquo;) def index(): return &amp;lsquo;hello, world!&amp;rsquo;  
 实现如下: &amp;lt;span class=&amp;ldquo;kn&amp;rdquo;&amp;gt;import&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nn&amp;rdquo;&amp;gt;functools&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;log&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;text&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;=&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;rdquo;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;decorator&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nd&amp;rdquo;&amp;gt;@functools.wraps&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;before function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run, text: [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;].&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;text&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;after function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run, text: [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;].&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;text&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;decorator&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;ldquo;nd&amp;rdquo;&amp;gt;@log&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;log text&amp;rsquo;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;():&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;func() run.&amp;rsquo;&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;rsquo;main&amp;lsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;==&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;:&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;func&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;()&amp;lt;/span&amp;gt;  
 输出如下: &amp;lt;span class=&amp;ldquo;go&amp;rdquo;&amp;gt;before function [func()] run, text: [log text].&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;go&amp;rdquo;&amp;gt;func() run.&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;go&amp;rdquo;&amp;gt;after function [func()] run, text: [log text].&amp;lt;/span&amp;gt;  
 最后脑洞小开一下, 有没有办法实现既支持不带参数(如log), 又支持带参数(如log(&amp;lsquo;text&amp;rsquo;))的decorator吗? &amp;lt;span class=&amp;ldquo;kn&amp;rdquo;&amp;gt;import&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nn&amp;rdquo;&amp;gt;functools&amp;lt;/span&amp;gt;
&amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;log&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;argument&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;if&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;ow&amp;rdquo;&amp;gt;not&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nb&amp;rdquo;&amp;gt;callable&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;argument&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;decorator&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nd&amp;rdquo;&amp;gt;@functools.wraps&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;before function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run, text: [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;].&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;text&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;after function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run, text: [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;].&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;text&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;decorator&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;def&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;nf&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;):&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;before function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run.&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;=&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;(&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;*&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;args&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;kwargs&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;p&amp;rdquo;&amp;gt;)&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;print&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;&amp;lsquo;after function [&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;si&amp;rdquo;&amp;gt;%s&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;s&amp;rdquo;&amp;gt;()] run.&amp;rsquo;&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;%&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;function&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;o&amp;rdquo;&amp;gt;.&amp;lt;/span&amp;gt;&amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;name&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;rst&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;k&amp;rdquo;&amp;gt;return&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;ldquo;n&amp;rdquo;&amp;gt;wrapper&amp;lt;/span&amp;gt;  
 如上~~~ 
</content>
    </entry>
    
     <entry>
        <title>[转]学习新东西的唯一方法</title>
        <url>https://cppfans.org/2114.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>学习</tag><tag>思路</tag><tag>方法</tag>
        </tags>
        <content type="html"> 转自：http://www.jianshu.com/p/3a515cc30df3
有人曾从我工作的一家公司盗取了9千万美元。我不太懂得如何观人识人。这家公司最终关门了。
有一些事情我就是学不会。我很容易相信一个人。
因此，无论我如何尝试，判断一个人对我来说，简直太难了。所以，我寻找擅长做这件事的人，我让他们给我提供帮助。
Learn   不要强迫自己学习那些你不想或者不属于你天赋所及的事情。
天赋的作用到底有多大？非常小。但你需要从它开始起步。天赋是技能的种子。
你如何得知你在某个方面具有天赋？当你10岁时，如果你热爱它，如果你梦到过它，如果你喜欢阅读这方面的内容。请继续阅读以下内容，你会发现你的天赋到底在哪里。
当我说：每一个人在许多方面都具有天赋。请相信我。
在过去的20多年里，我一直在试着学习一些东西，而且我希望把它们学好。写作、编程、商业技巧（领导力，销售，协商和决策制定等等），戏剧，游戏。
所以，我专门研究出了一项由10个步骤组成的学习方法。
热爱你学习的东西
如果你不能从“热爱”出发，那么那些热爱它们的人将会战胜那些仅仅“喜欢”或者“讨厌”它们的人。
这是一条放之四海而皆准的规则。第一个从西伯利亚出发直至阿拉斯加穿越北极的人，即使零下60多度，他依旧热爱他所做的事情。其他人可能宁愿呆在东非的大草原上。
在我第一次写下“Hello World”计算机程序时，我就梦到了计算机。我凌晨4点起床，返回“计算机实验室”，写出了一个更复杂点儿的程序。
当我第一天开始写作时，我写了一整天。我无法停下来。而且，在那时，我只想和形形色色的写作者们谈话和交流。
当我只有10岁时，我写了一个有关我五年级同学的专栏。我每天都阅读 Judy Blume 的书。我几乎什么都读，我太喜欢写作了。
我的绝大多数朋友都觉得我很无趣，所以，我很快陷入了一种孤独境地。当然，写作的时候例外。
阅读与之相关内容
Bobby Fischer 原本不擅长国际象棋。他有这方面的天赋，但很多人不这么认为。
因此，在他大约12-13岁时，他消失了一年时间。
当他在13岁时，他再次出现，而且突然之间，他成了美国最好的国际象棋手，赢得了美国象棋冠军赛。他成为当时世界上最年轻的国际象棋大师。
他如何做到的呢？其实，在这一整年里，他几乎没有真正地下过一盘象棋。
相反，他只做了两件事：
a) 他把上个世纪所有的象棋赛棋局研究了一遍。
当他返回时，他对所有的开局模式都非常熟悉，而且他把这些开局模式做了必要的改进。没人知道怎样才能战胜这些改进模式。
事实上，在1972年举办的世界冠军赛的决赛中，他和 Spassky 对垒，Fischer 就是凭借其 1800 年代的武器装备，最终赢得了世界冠军。
Spassky 必须赢得比赛以保持其冠军称号。Fischer 必须获胜比赛才能摘得冠军头衔。
Spassky 采用了一个非常现代的极具进攻态势的开局（“The Sicilian”），但是在随后的13步之后，所有的评论员开始窃窃私语。
Fischer 故意将开局做成了一种老式风格的“The Scotch Game”模式。自此，Spassky 始终没能再有胜出的机会。
b) Fischer 通过阅读俄罗斯象棋杂志学习和了解了有关俄罗斯棋手的信息。那个时候，世界象棋排名前20都是俄罗斯人。美国人根本没有机会。
正当所有美国棋手研究各种俄罗斯人已经熟知的各类开局风格时，Fischer 却在研究俄罗斯人的具体棋法。
结果是，当 Fischer 赢得全美冠军时，他成为了第一位全胜棋手，甚至没有一盘和局。
研究历史，研究既往最佳棋手，是成为最佳棋手的关键。即使开始时你只是有点儿天赋而已。
尝试。但不要太艰难
如果你想成为一名作家，一位商界精英，或者一名程序员，你必须写很多东西，创办很多企业，编写很多程序。
失败或错误时有发生。这就是为什么在开始的时候，数量比质量更重要。
我们的学习曲线不是构建在你业已取得的成就之上，而是构筑在数量之上。
如果你看到一个东西1000次，你将会比那些只看10次的人更有见识。
不要忘记这条重要规则：快乐的秘密不在于“成就卓越”，而在于“不断成长”。
如果你仅仅“尝试”你能力范围内的事情，成长将会停止，对此，你不会感到快乐和幸福。
找到一位老师（外加一个10倍速规则）
如果我尝试自学西班牙语，我会迷失方向。但当我走出门，结识一些阿根廷人，我会学到更多。
在国际象棋，写作，编程，商业等方面，我总能找到比我更加出色的人，为此，我会每周安排一定时间向他们请教一些问题，让他们给我布置一些作业，帮助我发现错误并且告知我错误的具体细节。
对于任何你热爱的事情，找到一位老师，就能帮助你以10倍速的效率前进。
事实上，我放在这个列表中的每一件事情，都可以让你的学习以10倍的速度前进。因此，如果你在学习中应用了这份列表中每一项方法的话，你的学习效率将是其他人的10的10次方。
这就是让你在某个方面取得杰出成就的基本路径。
学习历史，学习现在
如果你想要成为一名优秀的程序员，不要仅仅满足于编写一个应用程序，你应该学习机器语言。
学习1和0，学习计算机的历史，学习如何设计一个操作系统，学习各种编程语言，Fortran，Cobol，Pascal，Lisp， C， C&#43;&#43; 直至现代语言，比如，Python 等。
如果你想要提高自己的写作技能，去读自1800年起的优秀的文章。阅读海明威和弗吉尼亚·伍尔夫，甚至“垮掉一代”（Beat Generation）的文学著作，阅读那些经得起时间考验的作品。
它们都历经了时间的考验。经过与其他几百万本书的比较，它们就是这个世界上最好的文学作品。
然后，你需要研习当代对这些书籍的评论和批评。这样做的重要性就如同阅读它们一样重要。
如果你希望学习商业，阅读洛克·菲勒和卡内基的传记，了解阿姆斯特丹成立的第一家交易所，90年代的垃圾债券泡沫，金融危机，每一次经济衰退。每一次经济衰退都是再一次经济繁荣的发源地。
阅读彼得·蒂尔撰写的“从零到一”这本书。在 CNBC 电视网上观看“The Profit”专栏节目。阅读苹果公司创始人史蒂夫·乔布斯的传记。阅读《权力的终结》了解柯达如何衰落。
不要阅读那些自助型商业书籍。它们没有什么价值。你己经进入一个广阔的领域 - 创新领域 - 现代社会创建的一个领域。不要读去年刚刚出版的平庸作品。
再进一步，你可以阅读一些有关通过创新如何将世界变成今天这个形态的著作。
阅读亨利·福特如何从创办三家汽车公司起家，最终怎样找到正确发展之路，而且你还需要知道为什么“三”对于亨利·福特而言，是一个重要的数字。
阅读了解为什么雷·克拉克的技巧成就了世界上最大的特许加盟连锁餐饮企业 - 麦当劳。阅读可口可乐如何通过不生产任何东西，却造就了世界上最大的饮料公司。
把你从这些阅读中收获的东西记录下来。
先易后难
Tony Robbins 曾经向我提及他的第一次教学工作经历，当时，他对这份工作甚至有点害怕。
他必须教会一组海军陆战队员提高他们的射击准确度。“我这一辈子都没打过枪，” 他说。
他之前在一些专业人士那里学了一些东西，然而不久之后，他就发现了一个技巧，结果使得受训陆战队员的射击成绩达到了前所未有的水平。
他只是把射击目标拉近了。
他将靶子放在距离仅有5英尺的地方。他们全都命中了靶心。然后，他再将其后移一点，直至标准距离。
他们全都击中靶心。
理查德·布兰森在他开办航空公司之前，从创办一本杂志起步。比尔盖茨在整个团队都从事 Windows 开发之前，他自己编写第一个 Basic 语言和编译器。
斯蒂芬妮·迈耶（是的，我包括了她）撰写了《暮光之城》，在此之前，她写过一本名叫《五十级灰度》的书。
在早期，海明威从没有梦想成为一位小说家。因此，他只是写了一些小故事。
程序员在着手设计第一个搜索引擎之前，编写“Hello World”程序。
许多国际象棋大师在你开始学习象棋时，会推荐你先学习象棋残局（只有几枚棋子）。
这样做会给予你信心，会给予你微妙的提示，会给予你有关成长和提高的强烈的感受。
回顾你学过的东西
有一天，我把我几乎所有的东西都扔了。所有的东西。我扔了我所有的书（捐献了）。我扔了我所有的衣服。
我扔了那些旧电脑。我扔掉了我从来不用的盘子。我扔掉了我认为我不会有机会穿着的衬衣。我扔了我所有的家具，纸张及其它东西。
我想来个大扫除。我就这么做了。
我发现了一本我写于1991年的小说。24年之前。真是可怕呀。
24年来，我第一次重读了这本小说。我知道了当时出错的地方（人物不相关。故事刻画太明显。故事的高潮都发生在同一个地点）。
有人告诉我一个关于 Amy Schumer（我最喜爱的喜剧演员之一） 的故事。她把自己所有的表演都录了下来。
然后她返回家中，仔细研究她自己的表演，一秒接一秒。“我当时应该在这个动作上停留四分之一秒。”
她希望成为一名最好的喜剧演员。她研究了自己的每一次表演。
我下棋的时候，如果输掉一局，我会把这个棋局保存在计算机中。事后，我会查看我下过的每一步棋和计算机提示。我会思考在我下了步臭棋时，我当时都在想些什么等诸如此类的事情。
我最近投资的一个项目失败了。对我来说，我的感受糟糕极了。但不管怎样，我必须要研究出我到底错在了那里。我在什么地方出的错误。在各个层面上，我都将其进行必要的反思，并且在最后把它们记录下来。
如果你无法沉迷于自己的错误，这可能表明你对这个领域还不够热爱。
你不应该问自己这样的问题“我擅长做什么？” 相反，你应该问自己：“我什么地方做得不对，我应该如何改进？”
在你持续不断地询问自己一个更好的问题过程中，你将会变得比那些只问自己糟糕问题的人更为优秀。
例子：我讨厌看到自己在电视里的表现。所以我无法在表演方面做得更好。
你就是你最要好的5个朋友的平均数
观察一下每一个文化，艺术以及商业场景。很少有人能够作为个体表现突出，他们往往作为一个群体而表现突出。
垮掉一代（文学）：杰克·克鲁亚克，艾伦·金斯堡，威廉·博罗斯以及其他一些人。
技术与编程：史蒂夫·乔布斯，比尔·盖茨，泰德莱·昂西斯，保罗·艾伦，斯蒂夫·沃兹尼亚克等其它佳酿俱乐部成员。
50年代艺坛：贾斯珀·约翰斯，德·库宁，Pollack 等所有当时身处纽约芝麻街的那些人。
YouTube，LinkedIn，Tesla，Palantir 等所有这些被称为“PayPal 帮”的成员。
所有这些人都不是独自存在的。人类是一种以部落为单位的群居动物。我们需要和群体一起工作才能获得更大的提高。
找到这些最好的群体，尽量花费大量的时间和他们在一起，你就会变得和他们一样优秀。
你们每一个人彼此相互挑战，相互竞争，喜爱和欣赏彼此的工作成果，甚至彼此羡慕，最终，你们都将相互超越。
多多益善
坚持不懈与偶尔为之相比，坚持不懈更为重要。
我过去有一位朋友，一直想在绘画上有所提高。但是，她认为她应该去巴黎，因为那里的气氛更适合。
她的巴黎之旅一直没能成行。她目前坐在一个小隔间里，伴着荧光灯填写着各类报表，还有就是一些无聊的文书工作。
写作每一天，社交每一天，娱乐每一天，健康生活每一天。
请按照你所做事情的数量来衡量你的生活。
找到你自己的魔鬼计划
学生最终实现超越成为一名大师。
我曾为之工作的第一位对冲基金经理现在非常恨我。我开创自己的基金时，他的基金正要被淘汰出局。我的魔鬼计划最终来看比他的更有效。
然而，
自此之后，我会发现自己的声音。而且，当你用这种声音说话，世界就会呈现出一种新气象。
你的老师和朋友们可能并不希望听到这种声音。但是，如果你能够继续让喜欢和尊重你的人围绕在你周围，那么，他们会继续鼓励你发出那样的声音。
有句话是这样说的，“there are no new ideas.” But there are。
如果你能融合已有的思想或想法，你就是那只美丽的蝴蝶。
_- 原文：The Only Technique To Learn Something New_
_- 感谢：Qingniu 帮助审阅和完成校对。_
&amp;nbsp;
 文／Jodoo（简书作者）
原文链接：http://www.jianshu.com/p/3a515cc30df3
著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。  </content>
    </entry>
    
     <entry>
        <title>[转]我在系统设计上犯过的14个错</title>
        <url>https://cppfans.org/2111.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>架构</tag><tag>系统</tag><tag>设计</tag>
        </tags>
        <content type="html"> 转自:http://hellojava.info/?p=458
在上篇《架构师画像》的文章中提到了自己在系统设计上犯过的一些错，觉得还挺有意义的，这篇文章就来回顾下自己近八年来所做的一些系统设计，看看犯的一些比较大的血淋淋的错误（很多都是推倒重来），这八年来主要做了三个基础技术产品，三个横跨三年的大的技术项目（其中有两个还在进行中），发现大的错误基本集中在前面几年，从这个点看起来能比较自豪的说在最近的几年在系统设计的掌控上确实比以前成熟了很多。
第1个错
在设计服务框架时，我期望服务框架对使用者完全不侵入，于是做了一个在外部放一个.xml文件来描述spring里的哪些bean发布为服务的设计，这个版本发布后，第一个小白鼠的用户勉强在用，但觉得用的很别扭，不过还是忍着用下去了，到了发布的时候，发现出现了两个问题，一是这个xml文件研发也不知道放哪好，所以到了发布的时候都不知道去哪拿这个xml文件。
这个设计的关键错误就在于在设计时没考虑过这个设计方式对研发阶段、运维阶段的影响，后来纠正这个错误的方法是去掉了这个xml文件，改为写了一个Spring FactoryBean，用户在spring的bean配置文件中配置下就可以。
因此对于一个架构师来说，设计时在全面性上要充分考虑。
第2个错
服务框架在核心应用上线时，出现了前端web应用负载高，处理线程数不够用的现象，当时处理这个故障的方式是回滚了服务框架的上线，这个故障排查了比较长的时间后，查到的原因是服务框架用的JBoss Remoting在通信时默认时间是60s，导致一些处理速度慢的请求占据了前端web应用的处理线程池。
上面这里故障的原因简单来说是分布式调用中超时时间太长的问题，但更深层次来思考，问题是犯在了设计服务框架时的技术选型，在选择JBoss-Remoting时没有充分的掌握它的运行细节，这个设计的错误导致的是后来决定放弃JBoss-Remoting，改为基于Mina重写了服务框架的通信部分，这里造成了服务框架的可用版本发布推迟了两个多月。
因此对于一个架构师来说，在技术选型上对技术细节是要有很强的掌控力的。
第3个错
在服务框架大概演进到第4个版本时，通信协议上需要做一些改造，突然发现一个问题是以前的通信协议上是没有版本号的，于是悲催的只能在代码上做一个很龌蹉的处理来判断是新版本还是老版本。
这个设计的错误非常明显，这个其实只要在最早设计通信协议时参考下现有的很多的通信协议就可以避免了，因此这个错误纠正也非常简单，就是参考一些经典的协议重新设计了下。
因此对于一个架构师来说，知识面的广是非常重要的，或者是在设计时对未来有一定的考虑也是非常重要的。
说到协议，就顺带说下，当时在设计通信协议和选择序列化/反序列化上没充分考虑到将来多语言的问题，导致了后来在多语言场景非常的被动，这也是由于设计时前瞻性的缺失，所谓的前瞻性不是说一定要一开始就把未来可能会出现的问题就解掉，而是应该留下不需要整个改造就可以解掉的方法，这点对于架构师来说也是非常重要的。
第4个错
在服务框架切换为Mina的版本上线后，发布服务的应用重启时出现一个问题，就是发现重启后集群中的机器负载严重不均，排查发现是由于这个版本采用是服务的调用方会通过硬件负载均衡去建立到服务发布方的连接，而且是单个的长连接，由于是通过硬件负载均衡建连，意味着服务调用方其实看到的都是同一个地址，这也就导致了当服务发布方重启时，服务调用方重连就会集中的连到存活的机器上，连接还是长连，因此就导致了负载的不均衡现象。
这个设计的错误主要在于没有考虑生产环境中走硬件负载均衡后，这种单个长连接方式带来的问题，这个错误呢还真不太好纠正，当时临时用的一个方法是服务调用方的连接每发送了1w个请求后，就把连接自动断开重建，最终的解决方法是去掉了负载均衡设备这个中间点。
因此对于一个架构师来说，设计时的全面性要非常的好，我现在一般更多采用的方式是推演上线后的状况，一般来说在脑海里过一遍会比较容易考虑到这些问题。
第5个错
服务框架在做了一年多以后，某个版本中出现了一个严重bug，然后我们就希望能通知到用了这个版本的应用紧急升级，在这个时候悲催的发现一个问题是我们压根就不知道生产环境中哪些应用和机器部署了这个版本，当时只好用一个临时的扫全网机器的方法来解决。
这个问题后来纠正的方法是在服务发布和调用者在连接我们的一个点时，顺带把用的服务框架的版本号带上，于是就可以很简单的知道全网的服务框架目前在运行的版本号了。
因此对于一个架构师来说，设计时的全面性是非常重要的，推演能起到很大的帮助作用。
第6个错
服务框架这种基础类型的产品，在发布时会碰到个很大的问题，就是需要通知到使用者去发布，导致了整个发布周期会相当的长，当时做了一个决定，投入资源去实现完全动态化的发布，就是不需要重启，等到做的时候才发现这完全就是个超级大坑，最终这件事在投入两个人做了接近半年后，才终于决定放弃，而且最终来看其实升级的问题也没那么大。
这个问题最大的错误在于对细节把握不力，而且决策太慢。
因此对于一个架构师来说，技术细节的掌控非常重要，同时决策力也是非常重要的。
第7个错
服务发布方经常会碰到一个问题，就是一个服务里的某些方法是比较耗资源的，另外的一些可能是不太耗资源，但对业务非常重要的方法，有些场景下会出现由于耗资源的方法被请求的多了些导致不太耗资源的方法受影响，这种场景下如果要去拆成多个服务，会导致开发阶段还是挺痛苦的，因此服务框架这边决定提供一个按方法做七层路由的功能，服务的发布方可以在一个地方编写一个规则文件，这个规则文件允许按照方法将生产环境的机器划分为不同组，这样当服务调用方调用时就可以做到不同方法调用到不同的机器。
这个功能对有些场景来说用的很爽，但随着时间的演进和人员的更换，能维护那个文件的人越来越少了，也成为了问题。
这个功能到现在为止我自己其实觉得也是一直处于争议中，我也不知道到底是好还是不好…
因此对于一个架构师来说，设计时的全面性是非常重要的。
第8个错
服务框架在用的越来越广后，碰到了一个比较突出的问题，服务框架依赖的jar版本和应用依赖的jar版本冲突，服务框架作为一个通用技术产品，基本上没办法为了一个应用改变服务框架自己依赖的jar版本，这个问题到底怎么去解，当时思考了比较久。
可能是由于我以前OSGi这块背景的原因，在设计上我做了一个决定，引入OSGi，将服务框架的一堆jar处于一个独立的classloader，和应用本身的分开，这样就可以避免掉jar冲突的问题，在我做了引入OSGi这个决定后，团队的1个资深的同学就去做了，结果是折腾了近两个月整个匹配OSGi的maven开发环境都没完全搭好，后来我自己决定进去搞这件事，即使是我对OSGi比较熟，也折腾了差不多1个多月才把整个开发的环境，工程的结构，以及之前的代码基本迁移为OSGi结构，这件事当时折腾好上线后，效果看起来是不错的，达到了预期。
但这件事后来随着加入服务框架的新的研发人员越来越多，发现多数的新人都在学习OSGi模式的开发这件事上投入了不少的时间，就是比较难适应，所以后来有其他业务问是不是要引入OSGi的时候，我基本都会建议不要引入，主要的原因是OSGi模式对大家熟悉的开发模式、排查问题的冲击，除非是明确需要classloader隔离、动态化这两个点。
让我重新做一个决策的话，我会去掉对OSGi的引入，自己做一个简单的classloader隔离策略来解决jar版本冲突的问题，保持大家都很熟悉的开发模式。
因此对于一个架构师来说，设计时的全面性是非常重要的。
第9个错
服务框架在用的非常广了后，团队经常会被一个问题困扰和折腾，就是业务经常会碰到调用服务出错或超时的现象，这种情况通常会让服务框架这边的研发来帮助排查，这个现象之所以查起来会比较复杂，是因为服务调用通常是多层的关系，并不是简单的A–&amp;gt;B的问题，很多时候都会出现A–&amp;gt;B–&amp;gt;C–&amp;gt;D或者更多层的调用，超时或者出错都有可能是在其中某个环节，因此排查起来非常麻烦。
在这个问题越来越麻烦后，这个时候才想起在09年左右团队里有同学看过G家的一篇叫dapper的论文，并且做了一个类似的东西，只是当时上线后我们一直想不明白这东西拿来做什么，到了排查问题这个暴露的越来越严重后，终于逐渐想起这东西貌似可以对排查问题会产生很大的帮助。
到了这个阶段才开始做这件事后，碰到的主要不是技术问题，而是怎么把新版本升级上去的问题，这个折腾了挺长时间，然后上线后又发现了一个新的问题是，即使服务框架具备了Trace能力，但服务里又会调外部的例如数据库、缓存等，那些地方如果有问题也会看不到，排查起来还是麻烦，于是这件事要真正展现效果就必须让Trace完全贯穿所有系统，为了做成这件事，N个团队付出了好几年的代价。
因此对于一个架构师来说，设计时的全面性、前瞻性非常重要，例如Trace这个的重要性，如果在最初就考虑到，那么在一开始就可以留好口子埋好伏笔，后面再要做完整就不会太复杂。
第10个错
服务的发布方有些时候会碰到一个现象是，服务还没完全ready，就被调用了；还有第二个现象是服务发布方出现问题时，要保留现场排查问题，但服务又一直在被调用，这种情况下就没有办法很好的完全保留现场来慢慢排查问题了。
这两个现象会出现的原因是服务框架的设计是通过启动后和某个中心建立连接，心跳成功后其他调用方就可以调用到，心跳失败后就不会被调到，这样看起来很自动化，但事实上会导致的另外一个问题是外部控制上下线这件事的能力就很弱。
这个设计的错误主要还是在设计时考虑的不够全面。
因此对于一个架构师来说，设计时的全面性非常重要。
第11个错
在某年我和几个小伙伴决定改变当时用xen的模式，换成用一种轻量级的“虚拟机”方式来做，从而提升单机跑的应用数量的密度，在做这件事时，我们决定自己做一个轻量级的类虚拟机的方案，当时决定的做法是在一个机器上直接跑进程，然后碰到一堆的问题，例如从运维体系上来讲，希望ssh到“机器”、独立的ip、看到自己的系统指标等等，为了解决这些问题，用了N多的黑科技，搞得很悲催，更悲催的是当时觉得这个问题不多，于是用一些机器跑了这个模式，结果最后发现这里面要黑科技解决的问题实在太多了，后来突然有个小伙伴提出我们试用lxc吧，才发现我们之前用黑科技解的很多问题都没了，哎，然后就是决定切换到这个模式，结果就是线上的那堆机器重来。
这个设计的主要错误在于知识面不够广，导致做了个不正确的决定，而且推倒重来。
因此对于一个架构师来说，知识面的广非常重要，在技术选型这点上非常明显。
第12个错
还是上面这个技术产品，这个东西有一个需求是磁盘空间的限额，并且要支持磁盘空间一定程度的超卖，当时的做法是用image的方式来占磁盘空间限额，这个方式跑了一段时间觉得没什么问题，于是就更大程度的铺开了，但铺开跑了一段时间后，出现了一个问题，就是经常出现物理机磁盘空间不足的报警，而且删掉了lxc容器里的文件也还是不行，因为image方式只要占用了就会一直占着这个大小，只会扩大不会缩小。
当时对这个问题极度的头疼，只能是删掉文件后，重建image，但这个会有个要求是物理机上有足够的空间，即使有足够的空间，这个操作也是很折腾人的，因为得先停掉容器，cp文件到新创建的容器，这个如果东西多的话，还是要耗掉一定时间的。
后来觉得这个模式实在是没法玩，于是寻找新的解决方法，来满足磁盘空间限额，允许超卖的这两需求，最后我们也是折腾了比较长一段时间后终于找到了更靠谱的解决方案。
这个设计的主要错误还是在选择技术方案时没考虑清楚，对细节掌握不够，考虑的面不够全，导致了后面为了换掉image这个方案，用了极大的代价，我印象中是一堆的人熬了多次通宵来解决。
因此对于一个架构师来说，知识面的广、对技术细节的掌控和设计的全面性都非常重要。
第13个错
仍然是上面的这个技术产品，在运行的过程中，突然碰到了一个虚拟机中线程数创建太多，导致其他的虚拟机也创建不了线程的现象（不是因为物理资源不够的问题），排查发现是由于尽管lxc支持各个容器里跑相同名字的账号，但相同名字的账号的uid是相同的，而max processes是限制在UID上的，所以当一个虚拟机创建的线程数超过时，就同样影响到了其他相同账号的容器。
这个问题我觉得一定程度也可以算是设计问题，设计的时候确实由于对细节掌握的不够，考虑的不全导致忽略了这个点。
因此对于一个架构师来说，对技术细节的掌控和设计的全面性都非常重要。
第14个错
在三年前做一个非常大的项目时，项目即将到上线时间时，突然发现一个问题是，有一个关键的点遗漏掉了，只好赶紧临时讨论方案决定怎么做，这个的改动动作是非常大的，于是项目的上线时间只能推迟，我记得那个时候紧急周末加班等搞这件事，最后带着比较高的风险上了。
这个问题主要原因是在做整体设计时遗漏掉了这个关键点的考虑，当时倒不是完全忽略了这个点，而是在技术细节上判断错误，导致以为不太要做改动。
因此对于一个架构师来说，对技术细节的掌控是非常重要的，这里要注意的是，其实不代表架构师自己要完全什么都很懂，但架构师应该清楚在某个点上靠谱的人是谁。
</content>
    </entry>
    
     <entry>
        <title>[转]钱没了，公司就死了，科技创业公司如何才能不把钱花光？</title>
        <url>https://cppfans.org/2105.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>产品</tag><tag>公司</tag><tag>创业</tag><tag>资本</tag>
        </tags>
        <content type="html">  &amp;nbsp;编者按：本文作者 Carol Leaman 是 Axonify公司的 CEO，她之前创办的公司被 Google 收购。
10年 前，我成了一家创业早期软件公司的 CEO。我本来受雇于一家私人股权公司，他们让我掌管他们觉得已经走错方向的业务。这并不完全是一场灾难，但是公司投入了上百万元，他们的一致认为：三位创始人需要一些 “帮助”。
5 天后，我开出了 7 万美元的个人工资单。在我运营过的四家科技公司里，这是最接近死亡的一个，我很长时间内都在思考为什么这些创始人会想有这种想法。更让我吃惊的是他们完全没有意识到自己的想法。
Y Combinator 的创始人 Paul Graham 多年前曾写过一篇博客，指出年轻的企业家在变得富有之前一定不要让公司死掉。
不幸的是，很多创业初期的公司像生活在童话故事里一样，他们不会在创业初期做决策时不会思考 “为了避免死亡我们应该怎么做。” 这不是说他们不应该关注走向成功需要做的事情，而是当涉及到一样东西——现金——时，需要作出理性的决策。
如果你在互联网上搜素 “为什么科技公司会失败?” 你会发现很多文章都将失败的主要原因归结于 “钱花光了。”
“撞到现金墙上了” 常常用来说明为什么科技公司会失败，现实情况是钱花光了是真实原因的结果。作为多年来上百家创业公司早期的导师，我可以说深层的原因是一致的。
以下是确保科技公司早期不会花光钱的 5 个建议：
1、不要把产品建立在空中楼阁之上。
如果非要让我说出一件让公司花光钱的事情，那就是闷头制造产品，但是不考察市场。实际上，CB Insights 曾发布过一份列表，这份列表由 156 名创业公司创始人和投资人撰写的，写明了他们的公司失败的原因。最常见的原因是他们制造的产品没有人愿意买。
很多创始人耗资百万余元，认为自己比任何人都了解产品的用户。很多创始人会告诉我 “当我们发布产品的时候，人们一定会喜欢它。” 但是事实证明：你不是乔布斯，你的产品也不是 iPhone。
2、尽早获取用户。
与第一点相关。用户意味着金钱。金钱意味着发展。发展意味着持续的生存能力。如果你无法说服别人购买你的产品，哪怕是小产品，那么你最好是 Facebook 或 Twitter 之类的公司，这样你才能找到像他们那样的投资人。用户是验证你的方向是否正确的最好方法。实际上，他们会帮你在恰当的时间吸引投资人，让公司获得恰当的估值。
3、不要低估融资的难度。
第一次创业的创业者，非常耀眼，有新鲜感。这些创始人对创业公司融资平均需要花费多长时间以及有多么困难不太了解。大部分天使和机构投资人一个月就会有几百次路演。几百次！你是在与有伟大想法的其他创始人进行竞争，你希望能脱颖而出。这是非常难的。在获得融资之前，你对融资的热情会消失殆尽，开始尝试接受现实，然后会变得疲惫。你给自己设定的期限是在六个月的时间内拿到必要的现金资源。
4、不要扩张太快。
不管你是否成功地融到了钱，还是使用自己的资金在支撑一段时间，扩招员工是最吸金的，而且员工的工资是需要不断支付的。第一批员工工资相对降低，但是如果你想扩张原有的团队，员工会希望拿到和市场待遇相近的薪资。这个固定的花费很快会失控，你的资金很快就会花完。
扩张规模主要在三个因素中寻求平衡：把钱花在哪儿、花钱的速度、预测你到达下一个里程碑需要多长时间。如果你在某一方面花费得过早或者花费得过多，那么你花光钱的几率会增加。
5、不要逃避数字。
很多年前，有人告诉我北美大部分公司的 CEO 都有商务、会计、金融背景，这都是有数据证明的。
我本身是一个 CPA（注册会计师），我立刻意识到有关金融和现金流方面的基础知识是如何为我管理年轻的公司提供坚实的基础支持的。
但是我一直很好奇为什么很多创始人不明白预定量和收益的不同，无法区分应收账款和现金流，甚至不会做最简单的、精确的现金预估。
当你开始创业时，最重要的事情是要了解公司每个周有哪些收入款项，哪些支出款项，以及下个周的现金余额状态。
如果你无法预见半年内的花费，也无法估计什么时候钱会花完，你会走我 10年 前的道路：钱花完了，还有 45 个人的工资没有支付。
本文编译自：venturebeat.com，如若转载，请注明出处：http://36kr.com/p/5044327.html
</content>
    </entry>
    
     <entry>
        <title>[转]为何你的产品 Demo 如此糟糕？因为你太注重产品本身了</title>
        <url>https://cppfans.org/2103.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>demo</tag><tag>产品</tag><tag>经验</tag>
        </tags>
        <content type="html">  &amp;nbsp;编者按：不管是大公司还是创业公司，我们很多时候都需要去给别人 Demo 产品，给客户 Demo，给投资人 Demo。但很多时候你会发现你的产品 Demo 并不尽如人意。为什么呢？如何才能做一个成功的产品 Demo 呢？本文就是为回答这个问题而来的。
“有人会讨厌你，也有人会质疑你，然后你会想办法证明他们是错误的。” 这是 Robert Falcone 对于产品 Demo 的看法，他自己一生中做过太多的产品 Demo 了。Falcone 现在是营销软件公司 Monetate 的联合创始人，在他的带领下，Monetate 已经和上百家企业进行深入的合作，为了获取这些企业用户，他做过的产品 Demo 也已经数不胜数。最开始的时候，他做的很多产品 Demo 并不成功，不过他很好地从中吸取了经验和教训，并总结了一套行之有效的产品 Demo 宝典。
“我之前以为产品 Demo 是一项很简单的工作，就是告诉人们这个产品是什么、有什么用途。然而每次当我做完产品 Demo 后，客户要么感觉非常困惑，要么非常礼貌地跟我说 ‘谢谢’，然后再也听不到他们的任何消息。” Falcone 说道。
在一次又一次地从客户那里得到这样的反馈后，他决定破解产品 Demo 的成功秘诀。如果产品 Demo 的简单明了能够带来客户转化率，那么如何做到产品 Demo 的简单明了呢？为了能找到这个问题的答案，他不断地去做产品 Demo、做 A/B 测试、去观察、再去重复。他将自己的产品 Demo 经验和心得都写进了《去你的 Demo》（Just F*cking Demo) 这本书中，这本书最近还进入了 Amazon 新书畅销榜单。
在这篇文章中，Falcone 分享了一个成功的产品 Demo 的结构、以及如何仅仅通过一次产品 Demo 就成功搞定客户的技巧与秘诀。
要搞砸一个产品 Demo 其实很简单
对我而言，我绝对算得上是我自己 Demo 的产品方面的专家，我自己也日复一日地向各种大公司 Demo 我们的 Monetate 这款产品，但很多时候还是无法成功地说服客户。很显然，对产品了然于心并不意味着你可以做一个成功的产品 Demo。
此外，看你做产品 Demo 的人很少会就 Demo 给你任何反馈，这样你就不知道该如何提升产品 Demo 的水平。那些看你做产品 Demo 的人中的大多数通常只会出于礼貌性地感谢你能抽时间过来 Demo 产品并就此结束对话。他们不会就如何改善产品给你提任何建议，更不会针对如何更好地向他们做产品 Demo 给你提意见。
“我会问他们：‘你理解我刚刚说的东西了吗？’，他们通常会回答：‘是的，理解了。’ 他们之所以这样回答是因为他们不想让自己看起来很蠢。不过你需要的肯定不仅是对方简单的一句：‘当然，我懂了。’ 你需要的实实在在的交易，是要他们购买你的产品。” Falcone 这样说道。
经过一系列失败的产品 Demo 后，他意识到必须要认真分析到底是哪里出问题了，他必须学会让自己的 Demo 百战百胜。他并没有可以向客户寻求反馈，在他 Demo 的过程中，他会非常注意房间内各种微妙的变化，他开始注意对话的语调，并不断地测试和记录自己的发现。他还会看其他人做 Demo 的视频，以从中寻找实用的建议。
他发现，人们在做产品 Demo 时最容易犯的一个错误、也是最大的一个错误在于不能给特定的展示对象做针对性地产品 Demo，无法引起客户的共鸣。例如，做产品 Demo 时，你不能从产品数十个功能和卖点中选取那几个能让展示对象（如特定的客户或投资者）产生共鸣的功能进行展示，从而促成交易。
 成功的 Demo 并不一定非要完美适合产品，但必须要完美适合展示对象。
 不管你的 Demo 对象是谁，你都需要好好花时间想想这个问题：在他们愿意达成交易之前，他们特别需要了解哪些东西？为确保能很好地回答这个问题，Falcone 专门针对产品 Demo 提出了 “你-他们-你” 的展示框架。你只需要给潜在客户展示他们需要知道的产品特性就行了，让他们知道你的产品是能帮助他们取得他们想要的结果的，这样你也能获得你要想的结果。一个 Demo 的成功与否取决于你的潜在客户是否能理解你的产品能带给他们的价值。
为了能让产品 Demo 更有吸引人和说服力，Falcone 还专门研究了包括 Malcolm Glandwell 和 Simon Sinek 在内的很多著名商业演讲家的演讲视频，他甚至还研究了魔术师的表演，看他们是如何让听众 / 观众那么全神贯注地看他们说或做的事情的。他发现了一个共同的特点，这些人对听众真正关心的东西都有非常深刻的理解。“如果你知道客户最关心的是什么问题，你就能最大限度地将自己的产品与他们最关心的问题联系在一起，这样有利于取得最好的 Demo 效果。”
做到灵活充分的准备
很多时候，原本那些我认为是我的强项的东西反而正在托我的后腿。如果你是一款产品方面的专家，那么你在做产品 Demo 时就得非常小心了，因为你会不由自主地向客户展示产品的每一项细节功能，而这又是非常乏味的，很有可能让客户听着听着就睡着了，或是客户突然提了一个你之前没有预料到的问题，这势必会让你乱了阵脚。
在做产品 Demo 前，与其想办法记住产品的每一个细节功能，还不如将这些准备时间用在思考你准备向客户问的问题以及他们可能会提的问题上面。如果对于这些问题你心中都已经有了答案，这才可以算作是有效的 Demo 准备。这时，你在 Demo 产品的时候便可以在各个 Demo 部分间顺畅转换，同时也能有效应对各种突发状况。注意，这些问题是专门针对客户准备的，你需要提前制作一个问题列表，确保能通过这些问题获得尽可能多的客户信息。
 做产品 Demo 时，你需要的不是一个一层不变的固定方案，你需要的是一本玩法的指南，你需要了解所有玩法，但真正在做产品 Demo 时，你只需演示最符合当时需要的那几种玩法。
 根据 Falcone 的经验，在所有的产品 Demo 中，有 10%的产品 Demo 无论如何都是会成功的，或许是因为展示对象之前曾与你一起共事过，或是第一次看你展示就特别欣赏你和你 Demo 的产品。还有 10% 的人不管你如何 Demo，他们都不会买你的帐，因为你给错误的客户群体展示了错误的解决方案。但是剩余的 80%的潜在客户将是你最主要的收入来源，对于这部分人群，你必须要想方设法搞定他们。
根据 Falcone 的经历，在 Demo 前做好充分的准备是可以为你搞定那剩下的 80%的潜在客户的。什么样的 Demo 才算是一个成功的 Demo 呢？就是容许听众在 Demo 中途打断你，既容许听众让你停下来重新解释演示过的内容，也要容许听众让你加快进度，而这些干扰都不会影响到你、让你惊慌错乱。你只需要 Demo 那些听众需要知道的内容即可。Demo 时务必做到顺畅与灵活。如果你在 Demo 之前认真演练过的话，这是能够做到的，会让听众看来非常自然。
用 5 分钟时间发现客户的需求
为了能让客户很明显地感受到你的产品和他们的需求之间是有关联的，你需要尽可能快地了解客户。或许你在 Demo 之前已经对 Demo 对象做了一定的背景调查，然而为了能让 Demo 更有效，你需要做的远不止这些。几十年前，商学院一般都会建议商人们在卖东西之前尽可能多地了解客户，甚至还有一本书建议商人花一整天时间来跟客户交流，以便能全面了解客户的需求。这在现在已经不可能了，没人愿意给你这么长的时间让你了解他的需求。
实际上，没有一个客户会愿意给你超过 1 小时的时间去做产品 Demo。所以在正式 Demo 之前，一定要尽可能地了解你的客户，你需要在 5 分钟之内就能了解他们的需求到底是什么。那么如何做呢？其实最好的方法就是直截了当地和客户说明：“在开始 Demo 前，我想先用 5 分钟时间来问大家一些问题，好让我了解你们最需要哪些功能。” 通过这种方式，Demo 双方就能形成共识，让客户直接参与到问答中。在 5 分钟的提问环节，时间控制非常重要。如果你把握不好时间超时了，客户可能就会要求你进入重点，这就意味着你已经失去了一个非常好的机会。
为了能充分利用这 5 分钟的时间，你需要首先从问答中梳理出客户 “之前” 的状态。他们的需求痛点在哪里？是什么影响了他们的工作效率？然后再将注意力集中在他们 “以后” 所希望实现的理想状态。你的产品能够帮助他们完成什么目标，能帮助他们解决什么问题？他们对这样的一款产品有什么要求？谁会使用这款产品？在你的产品的帮助下，他们的公司会变成什么样子？
如果能将 “之前” 和 “以后” 这两个问题搞清楚，就能让你的产品 Demo 变得更有针对性。当然，为了获得更精确的信息，你也可以在 Demo 过程中问问题。不过 Demo 之前的 5 分钟提问题的环境是最为重要的，直接关乎你是否能了解客户的需求。
尽管这 5 分钟非常重要，但是你还是无法在这么短的时间内获取所有有价值的信息的。你需要知道，他们告诉你的东西只是他们真实感受和期待的冰山一角。所以你必须要利用一切可以利用的机会来获取更多的信息。你还会发现，如果听众认为你的 Demo 和他们的需求有相关性，他们便会为你提供越来越多的信息。
正是通过这种方式，Falcone 最近成功搞定了一家大型电商的订单。在产品 Demo 的过程中，他了解到了一些关键性的细节信息：“我们需要真正了解客户正在面临的问题和挑战。他们所面临的最大的问题就是很难区分客户群体。为了推动营收增长，他们每个月的月底都会面向所有人进行打折促销。这家电商希望能够区分客户，给不同的客户群体提供最合适的折扣方案。” Falcone 了解了客户的这一需求后，他就在 Demo 产品时专门介绍了 Monetate 软件是如何能帮助对方解决这个问题的。
在了解了他们最关心的问题后，我就有底气这样说：“我觉得你们最大的营收增长机会就是使用我接下来将展示的工具。下面我就为你们详细介绍这款工具，看它是如何能为你们实现营收的增长的。” 如此一来，我成了能为他们实现目标的值得信赖的顾问，让我与那些单纯向他们销售产品的其他竞争对手有本质的区别。
首先告诉客户结果，再解释过程
畅销书作家 Malcolm Gladwell 写的书之所以这么受欢迎，其中很大原因在于他讲故事的方式：先告诉你故事的结局是什么，然后再解释其中的前因后果。其实同样的结构也适用于产品 Demo 中。你可以首先让客户能想象、甚至体验用了你的产品或服务之后的工作和生活是什么样子的。在他们的脑海中形成了这种画面感后，再返回去向他们解释为什么用了你的产品后他们的生活 / 工作能变得更好。这也算是 5 分钟问答环节中药留意客户 “以后” 所希望实现的理想状态的一部分，然后再针对性地进行回答。
迈克尔.乔丹是如何掀起一股运动鞋革命的？如果你回过头去重新看飞人乔丹拍过的电视广告的话，你就会发现，大家看完广告后之所以选择去买那款运动鞋并不是因为这是一款质量很好的产品，而是因为他们想和乔丹一样能飞。他们知道自己想成为什么样子，因此在做产品 Demo 时，你首先就要告诉他们你能帮他们实现的东西。
 这是你们的目标，这是你们目前面临的问题，这是我们的产品帮你解决问题之后的样子。要尽快把这些信息告诉客户。
 开头说完上面这部分内容后，如果客户给出以下这种回应：“嗯，不错，这正是我想要的。那你现在就告诉我你的产品是如何能帮我实现目标的。” 那么你离成功就不远了，这时你就可以向客户解释你的产品功能具体是如何能满足他们的需求的。
在给客户 Demo Monetate 这款产品的时候，Falcone 通常会采用下面这个非常有效的方法：先展示客户自己目前的网站，再展示加入了他们希望加入的内容和服务之后的网站，即使用了 Monetate 后网站是什么样子。通过这种对比的方式后，如果你把解决方案直接放在他们面前，客户想拒绝都难。
在 Demo 的时候，根据现场情况选择合适的展示语调也非常重要，可以选择热情洋溢，也可以表现得沉稳严肃。如果选择不恰当，则会适得其反。如果我的 Demo 对象是投资人，投资人说他只投那些真正具有革命性意义的 B2B 应用，这时我会表现得非常严肃和直接，告诉他为什么我的产品和市场上的其它产品是与众不同的。如果我的 Demo 对象是销售类公司，对方希望在没有 IT 的帮助下通过更快推内容来增加营收，这时我会用一种更具想象力的兴奋语气来向他们解释使用我们的产品是如何帮助他们实现这项目标的。
 要学会洞察整个房间里微妙的变化，包括客户的用词、客户谈论自己的产品和你的产品的方式，这样你就能更快地了解双方。
 Demo 产品时要按从宏观到微观的顺序
介绍产品时要从宏观入手，等于为接下来详细的介绍内容搭建一个框架。你要记住，你要演示的对象中的大部分人对你所要演示的内容是一无所知的，也不知道这个产品是如何运作的。如果你担心无法详细介绍产品的各项功能或是漏掉什么内容就去太快介绍产品细节的话，那么你很有可能就会搞砸。
你首先从宏观方面描述你的产品是如何能满足客户的需求的，然后再详细介绍产品的细节信息。如果客户能给出这样的反馈就最好了：“你刚刚介绍的产品的大概内容我了解了，整体上比较符合我们的需求，我想知道你的产品是如何具体满足我们的特殊需求的。” 在详细介绍产品的时候，你需要利用在之前的 5 分钟提问环节中发现的客户的需求来抓住他们的注意力。
举个例子，假如你销售的是一款设备，这款设备最大的特点之一就是它非常小巧。你需要把介绍重点放在设备质量上，同时让用户知道你甚至可以将这款设备放在口袋里。这是这款设备的宏观信息。然后你可以再去介绍设备的具体功能，这是微观信息，例如支持无线充电、电池容量等信息。
先展示产品的宏观信息，再介绍微观的具体功能，这样能够确保客户跟着你的逻辑走，让他们从一开始就对产品产生兴趣。如果接下来介绍的某些具体功能他们不感兴趣或是和他们的需求不相关，你要学会及时打住。如果你将自己准备的东西按照这个逻辑在大脑里多过几遍，那么你 Demo 的成功率就会越高。
掌控 Q&amp;amp;A 环节
 一个成功的 Demo 就是一次以产品为背景的对话。
 在理想情况下，在做产品 Demo 的过程中，你肯定希望大家能够提问交流，而不想讲 Demo 变成一场个人讲座。因此你可以尽早在 Demo 中问一些问题。
为了能让大家都参与进来并加强双方的了解，你可以在 Demo 过程中问几类问题。第一类问题是开放式问题。这类问题的目的就是为了能让客户进行讨论。例如：当前工作流程中的哪一方面最让你崩溃？千万不要低估了你选择问的问题的重要性。即便你只想通过问问题让大家讨论，你也需要认真想想该问什么问题。一定要避免问那些无法和产品功能关联起来的问题。
第二类问题是针对性的问题，问这种问题的目的是为了将 Demo 效果最大化。如果我发现了客户面临的一个非常大的挑战或想实现的目标，这时为了将我 Demo 的产品的影响最大化，我就可以问一个针对性的问题，例如：所有这些低效率工作都会浪费公司很多的钱，不是吗？。一般他们在同意这个说法之前都会先沉默一段时间。
当然产品 Demo 最紧张的环节还是客户的提问环节。如果你发现自己无法很好回答对方的问题，那么你最好的办法就是 ‘回应式提问’，也就是说在他们提一个问题后你可以提出一个你自己的问题。首先要考虑他们问问题的目的，他们为什么要问这个问题？也许是因为他们真的对一些东西还不了解，也许是因为他们认为竞争对手的产品更好，或许他们质疑你的产品交付能力。你可以通过回应式提问的方式来了解其中的缘由。
回应式问题可以帮你走出困境。Falcone 曾记得有一位客户问他：“你 Demo 的产品是否能根据用户的选择来自定义推送内容？” 他立刻说：“当然可以，我来给你展示一下如何做到的。” 演示完之后，客户竟然给出这样的反馈：“你知道吗，这个功能并不适合我们，如果每个人都能这样做的话，那就太糟糕了。”
今天，如果面临同样的情景和问题，Falcone 不会立刻问题对方的问题，而是会提一个回应式的问题：“你们要推送什么特别种类的内容？你们团队中是谁在做这项工作？你希望每个人都有这么大的权限吗？” 如果你能针对对方的问题问出这一系列精心准备的问题的话，客户一般都会从中挑选对于他们来说最重要的问题去解释回答，这样你就能获得更多的数据信息。如果对方告诉我，他们只希望技术用户能够推送内容，我就会告诉他们 Monetate 是如何可以帮助他们做到这一点的。
总结
 要尽可能地多地了解你的客户，甚至是他们的个人资料。Demo 前要多跑腿搜集尽可能多的资料，在正式 Demo 之前，先用 5 分钟时间去来了解他们真实的需求、挑战和目标。
 期待、准备、排练，直到你可以游刃有余得完成整个 Demo，做到 Demo 的信息充足、冷静沉稳、表达清晰。
 在 Demo 开始后，首先给客户他们想要的结果，让他们知道使用你的产品后他们的工作、生活是如何变得更好的，然后再解释原因。
 Demo 时要从宏观入手，让他们了解大致情况，这部分尽可能简单，不能让客户厌烦。然后再根据客户的特别需求来介绍相应的产品微观功能。
 在整个 Demo 过程中，都要掌控 Q&amp;amp;A，尽可能让每个人都参与进来，同时要持续不断地强化产品卖点，并办法了解客户对产品的真实需求。
  本文编译自：firstround.com，如若转载，请注明出处：http://36kr.com/p/5044093.html
</content>
    </entry>
    
     <entry>
        <title>[转]为什么面试官很少向求职者解释原因</title>
        <url>https://cppfans.org/2099.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>求职</tag><tag>面试</tag>
        </tags>
        <content type="html"> _本文译自Linkedin，作者 Ambra Benjamin。_
作为一个面试官，拒绝人是我们工作中最糟糕的部分。相信我，就像求职者害怕接到拒绝电话一样，我也害怕打出这样的电话。虽然你也会遇到一些公司会详细解释原因，但多数情况下，你得到的将是简单的拒绝电话或者邮件，没有更多的详细解释。求职过程中你投入了不少精力和时间，结果却让人失望。但它们总归是有原因的。
不管你信不信，不解释被拒的原因总归是有合理的含义的。在一个热爱争论的社会，尤其是 90年 代后期 20 世纪初，企业为保护利益是高度敏感的，因此，许多企业给求职者的拒信上拒绝填写详细信息。很多企业不想做任何可能把企业置于负面的事情。企业不提供任何信息，这样一来前雇员就不能因为没有获得工作而批评他们，也不会对事情产生误解。即便是面试官一句简单的 “你不符合团队的文化”，都可能引起失望的求职者的一系列质疑。在我看来，任何时候，团队文化都是一个难以讨论清楚的概念。
面试者方面也有原因。对面试者来说，对面试结果进行反馈是个很容易掉进坑里的事情。很多时候面试的结果是相当主观的。技术或程序类面试，有比较清楚的正确或错误，但其它时候，我发现关于什么是正确答案具有很强的主观性。我面试过的求职者曾经用我发给另一个软件工程师的代码和我争论对错。一个求职者被拒可能有很多原因，很多原因并不是求职者想听到的。我发现，10 次中有 9 次，当我向求职者反馈了他们的面试结果后，他们变得非常有防御性，话题也变成他们试图证明我的观点是错的。如果把一个人的争论时间乘上面试的人数，每天我们就别指望能干别的了。
当求职者成熟而专业时，我通常会慎重地稍微给他们一些反馈，因为我们知道他们能够接受。有些面试者我们希望在给他们反馈后，下次他们能够有明显的提高和改进。但不幸的是，大多数人不能很好地接受反馈意见。这可能和文化有关，也可能和我们的教育有关。和求职者争论面试结果的正确与否显然不是个好主意。在我所从事的科技领域，有些公司为了防止求职者在 LinkedIn 上反复向面试官发邮件争论面试结果，甚至不会提供面试官的姓氏信息。现在信息渠道非常多，Twitter , Medium , Glassdoor , Reddit , Quora 等等，你不会知道求职者会在什么渠道发表对于面试的抱怨。
我很理解人们在倾注了精力后，很想知道面试结果却又得不到的失望。你要了解到，你之所以得不到面试结果，很大程度上是因为多数不专业的求职者毁掉了少数求职者本可以拥有的权利。所以当你发现自己属于能够接受面试结果的少数时，我的建议是不论是否满意面试结果，简单地说一句 “感谢您的意见” 就好。面试本就是不完美的过程。
原创文章，作者：Yuri，如若转载，请注明出处：http://36kr.com/p/5043247.html
</content>
    </entry>
    
     <entry>
        <title>[转]为什么我们抛弃ECS而选择了Kubernetes</title>
        <url>https://cppfans.org/2078.html</url>
        <categories>
          <category>虚拟化</category>
        </categories>
        <tags>
          <tag>AWS</tag><tag>docker</tag><tag>ECS</tag><tag>google</tag><tag>Kubernetes</tag>
        </tags>
        <content type="html"> 转载自：http://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;mid=401368207&amp;idx=1&amp;sn=6bb2b3fe6ece8f41e7f2e2a54f52e46c&amp;scene=1&amp;srcid=0113d03chnJkdvhm86dmBSyW#rd  2016-01-13 杨润青 译 Docker    在这篇文章中我们将会探讨2个主流的Docker编排框架：AWS的ECS（Elastic Container Service）和Google的Kubernetes。  3个月前，我们在nanit.com希望选择一个合适的Docker编排框架，ECS成为了我们的首选，毕竟，我们对AWS的服务较为熟悉，并且我们的基础设施都是建立在AWS的。经过一段时间的测试，我们发现ECS并不成熟，缺少一些我们需要的关键功能，因此我们开始尝试其他的框架：Kubernetes。令人意外的是，Kubernetes非常成熟，几乎支持我们需要的所有功能。对于我们来说，Kubernetes在ECS的主场完胜了ECS。接下来，就让我们一起来看看Kubernetes赢在哪些方面。  注意：ECS一直在更新，我们会尽可能的跟进这些内容，但部分内容可能被忽略了，希望读者不要介意。 构建集群（Cluster Setup）     ECS：为了启动一个ECS集群，用户需要设置一个Auto Scaling Group。用户可以编辑user-data来将EC2实例添加到指定的ECS集群上。当ASG被设置，实例启动之后，用户可以在ECS控制台看到这部分内容。现在，用户可以开始进行task-definition，方式类似于Docker-compose。  Kubernetes：想要在AWS上启动一个Kubernetes，用户需要先启动一个具有一定权限的EC2实例（通过IAM）。这将会创建多个AWS constructs来支持你的集群：VPC、ASG、一些安全组（Security Groups）和一个Kubernetes主实例。集群需要几分钟来启动，之后用户就能够在上面运行自己的容器。  比较结果：使用这两种框架来启动一个集群都非常的简单和友好。 启动基础服务（Basic Service Setup）     我们的任务是启动一个Nginx 镜像，并且让其他人能够访问这个Web服务。  ECS：首先，我们需要创建一个ELB(Elastic Load Balancer)，它负责80端口的转发。然后，我们需要创建一个task-definition，它负责在80端口上启动一个Docker镜像。最后，需要创建一个Service，它会显示出有多少实例会同时运行。我们需要将它绑定到我们之前创建的ELB上。  Kubernetes：首先需要创建一个Replication Controller，它会显示出我们希望运行的Docker镜像和有多少镜像会同时运行。之后，我们需要创建一个Service object，这会启动一个ELB并且将ELB的流量转发到对应的容器上。  比较结果：Kubernetes的方式更舒服一些，更简洁。用户并不需要手工启动或者管理ELB。Kubernetes会完全负责管理：当用户创建了一个service，一个ELB会自动创建；当用户删除了一个service，它会自动从AWS上删除。 服务发现（Service Discovery）     当你使用了微服务架构和Docker，一个好的服务发现解决方案是至关重要的。Docker容器总是在不同虚拟机中迁移，用户必须有一个可靠的方法来发现在集群内和集群外的服务。  ECS：ECS并没有提供任何服务发现的解决方案。我能想到的最好方法就是构建一个内部加载平衡器（internal load balancer），并且将每一个service附加到一个平衡器上。平衡器的host name不会被改变，然后你就能够利用这个host name来作为服务的端点。其他的方法还有集成一个外部的程序，比如Consul。  Kubernetes：我认为这是Kubernetes的亮点之一。Kubernetes内置了一个完全的解决方案。它是一个插件，因此用户可以选择是否使用，但我强烈建议使用。它能够和namespace一起很好的工作。简单来说，当你创建了一个Kubernetes服务，比如说叫做redis，你就能够在集群的任何地方引用redis这个名字，即便是跨虚拟机。这就像是让docker网络跨越了特定的虚拟机，连通了整个集群。Namespaces允许你将多个服务归纳到一个具有逻辑的组中。现在假设我们有两个命名空间，分别是production和staging，他们都包含有一个redis的服务。一个在production命名空间下的容器可以通过redis来引用在production命名空间下的redis服务，同样的，在stagin命名空间下的容器也能通过redis来引用到位于stagine命名空间下的redis服务。这种自动化识别使得用户不需要花费时间去配置信息就能够构建一个隔离的环境，并且你可以随意在所有的命名空间中使用redis来引用对应的服务，接下来kunernetes会为你自动解析它们。  比较结果：毫无疑问，Kubernetes小胜一局。使用Kubernetes，用户完全不用关心服务发现的事情，全部交给Kubernetes来做就好了：） 部署（Deployments）     当我们升级一个服务的时候，即便还在部署，我们也想要确保它百分之百能用。我们的测试包括一个简单的NginX服务和一些简单的静态网页。我们启动了一个并发为30个请求的负载测试，并且在负载测试期间，我们会对该服务进行升级。  在部署期间，我们发现ECS丢失了比Kubernetes更多的请求。其中，Kubernetes丢失了0-2个请求，而ECS丢失了9-14个。  比较结果：说实话，我对ECS非常的失望。同样，我也对Kubernetes表示失望，但是它至少比ECS好多了。值得注意的是，Kubernetes 1.1.1版本应该会对轮询升级机制（rollong update mechanism）进行改善，还有一些其他的系统系能提升，这些改进都会使得这些数字变得更好看。 持久卷（Persistent Volumes）     我们经常需要挂载一些持久性的文件系统到一个指定的容器上，MySQL就是一个典型的例子。  ECS：ECS支持Docker原生的解决方案——用户可以启动一个数据容器，然后使用volumes-from命令来挂载它到其他容器上。就拿MySQL来看，你首先需要设置一个mysql-data容器，这个容器仅仅拥有一个数据卷。然后设置另外一个mysql-db容器，这个容器使用volumes-from命令来挂载之前创建的数据卷容器。这个方法看起来不错，但是它是host-sepicific的，这意味着你的mysql-db容器不能够在主机之间移动。你必须指定mysql-db容器在哪一个主机上运行，以此来防止容器被重新分配到其他主机上，最终失去了持久性。  Kubernetes：除了从一个指定的主机上挂载数据卷，Kubernetes还提供了一个选项：挂载一个EBS（Elastic Book Store）数据卷。这意味着一个容器的持久性存储可以在多个不同的虚拟机之间保留。你再也不需要强制你的MySQL容器必须运行在哪一个具体的虚拟机上。  注意：EBS同一时间只能被一个虚拟机挂载，这意味着如果有一个服务，它有两个运行在不同虚拟机的容器，他们将不能够挂载和共享这个EBS。  比较结果：即便Kubernetes的EBS挂载有一定的限制，但它依旧非常的独特和有用。 健康检查（Health-Checks）     确保拥有足够的服务容量是高可用性和冗余性的核心思想。健康检查就是用来确保服务不仅仅是运行的，并且它们还是健康和可操作的。  ECS：ECS使用ELB(Elastic Load Balancer)健康检查，这种方式有三个主要的缺点：  ELB健康检查仅仅限于HTTP/TCP检查   如果你想要对一个不开放TCP端口的服务进行检查，这是不行的。仅仅是为了能够进行健康检查，你就必须运行一个HTTP/TCP服务器。   即便你拥有一个支持HTTP/TCP的服务，你还需要创建一个ELB，并将它绑定到这个服务上，这样才能进行健康检查。    Kubernetes：除了基于HTTP/TCP的健康检查，Kubernetes还提供了一种叫做Exec的方式。Exec可以让用户在容器中运行命令。如果命令结束，并且返回0则表示这个服务是健康的，否则这个服务很可能是不健康的，它会被其他的实例所替换。  比较结果：Kubernetes的方式更灵活，更简单配置。用户并不需要去启动一个冗余的HTTP/TCP服务器仅仅为了进行健康检查，并且即便服务没有绑定ELB，你也可以对它们进行健康检查。 端口管理（Port Management）     从我们的上篇文章中可以看出，端口管理在Docker中是比较困难的。我们想通过一个简单的例子来说明Kubernetes如何比ECS更优雅的解决了这个问题。我们拥有一台虚拟机和两个监听80端口的网站。我们不能够在同一个虚拟机上开2个80端口，因此我们需要寻找一个方法来解决这个问题。  ECS：用户必须手工确定两个服务没有使用同一个端口。我们只有一台虚拟机，因此只能运行一个开放80端口的容器。当我们想要开启第二个开放80端口的容器时，这是不行的，因为我们没有多余的虚拟机了。也就是说，能够开放多少个x端口的服务取决于拥有多少个虚拟机。在小型集群中，这是非常容易满足的条件，但是当你的服务数量变得越来越多时，这将成为一个头疼的问题，因为当你想要扩充容器时，你必须确认你还有足够的端口。  Kubernetes：Kubernetes非常优雅的解决了这个问题。它为每一个虚拟机上的容器都分配了一个随机的端口。然后它创建了2个ELB，一个将80端口转发到容器A的随机端口上，另外一个转发到容器B的随机端口上。一个内部的路由机制会负责将数据包转发到对应容器端口。  比较结果：Kubernetes使用虚拟端口的方式代替绑定原始端口的方法，很好的解决了这个头疼的问题。 记录（Logging）     没有什么系统不需要记录功能。  我从没有想过记录会成为一个大问题，但能够为你解决问题令我非常的高兴，即便这个问题非常简单。我们之前提到Kubernetes提供了一个服务发现的扩展功能，在这里，我想说的是记录的扩展功能。它含有两个不同的记录和度量收集（metric collection）的机制。第一种是著名的ELK方法，ELK会收集容器的所有记录，并且能够让用户通过Kibana接口来查询和可视化这些记录。第二种是InfluxDB，它使用Grafana作为可视化工具来查询系统信息，如CPU和内存使用情况。  比较结果：Kubernetes的扩展功能更胜一筹。当然，你会说我并不需要这些扩展，系统也能很好工作，但是，它们效果如此之好，并且能适用于99%的用例，为什么不使用呢？ECS并没有提供内置的记录功能，用户想要集成一个进去并不是很困难，但是这些并不能和Kubernetes提供的功能相提并论。 未知的云平台（Cloud Agnostic）     其实，Kubernetes和ECS之间并不存在竞争：）  ECS会专注于AWS平台，如果你已经在ECS上构建了你的基础架构，当你想要转移到其他云平台时，你将会遇到很多困难。  Kubernetes适用于多个云平台。你可以在AWS，Google Cloud，微软的ZURE，Rackspace等等上运行你的集群，并且运行效果或多或少都是相同的。在这里，或多或少指的是有一些功能只有部分云供应商提供。你必须确认你选择的新供应商能够支持Kubernetes中使用的功能，至少确保迁移是可能的。 开源软件（OSS）     Kubernetes是开源的项目，而ECS不是。这意味着，所有的一切，从源代码到未来的发展路线都是对你开放的。发现了漏洞？你可以创建一个issue或者直接提交一个pull 请求来修复它。新的功能会被添加到每一个新版本，其中的贡献人数和pull请求是惊人的。  ECS有着不同的性质，我不能够在网上找到关于它未来发展路线的规划。你不能够获得一个漏洞和issue的列表，你必须深入到论坛上去寻找想要的答案。并且你寻找的答案往往都是缺乏实际的，并不能够提供任何帮助（https://forums.aws.amazon.com/message.jspa?messageID=664865#664865）。也许这仅仅是因为我个人的糟糕经历，但是不管怎么说，这都是令人烦躁和失望的。  比较结果：就我个人而言，我更喜欢开源软件。我喜欢Kubernetes的开放性，每个人都能够参与讨论和贡献代码。我相信社区的力量会给我们带来一个更好的产品。 多可用区域（Multi-AZ）     当谈论到Kubernetes时，有一件事情困扰着我：它不支持AWS上的多可用区域集群（multiple availability-zones cluters）。这意味着所有EC2实例都集中在一个AZ上，这使得你的集群很可能会遭受到中断问题。  ECS有对Multi-AZ有很好的支持。  比较结果：在Kubernetes的issue上，已经有一些工作正在进行。我十分确定下个版本会很好的得到改善。因此ECS在这一点上的胜利并不会长久。 总结     很多公司都开始使用Doker作为他们的主要基础设置，传递机制（delivery mechanism）和编排框架（orchestration frameworks）成为了系统的核心，并且影响着我们开发，迁移，运行，升级的方式。当我想要比较ECS和Kubernetes时，我找不到类似的文章。所以我认为把我们的经验公布出来非常的重要，这样其他人能够站在我们的肩膀上看的更远。  对于nanit.com来说，Kubernetes毫无疑问获得了胜利。如果你有任何的异议，请告诉我理由，我非常想要知道这些内容：）  </content>
    </entry>
    
     <entry>
        <title>[转]程序员如何谋划出月薪3万</title>
        <url>https://cppfans.org/2066.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>价值</tag><tag>商业</tag><tag>程序员</tag><tag>职业规划</tag><tag>薪资</tag>
        </tags>
        <content type="html">  转载自：http://www.techug.com/how-to-plan
不久前我发表了一篇文章，“月薪3万的程序员都避开了哪些坑”，在我的微信订阅号“程序视界”、CSDN博客、简书等平台都受了非常广泛的关注，点击量和评论出奇的多。有一些朋友觉得很难做到，其实，月薪3万是可以一步一步谋划出来的。个中关键，从大的方面来说，有两点：
1. 个人商业价值的挖掘与修炼
2. 职业机会的探索与把握
在展开之前，我们需要先澄清三个问题：
 商业价值包含哪些因素 职业机会包哪些要素 内生涯与外生涯是什么  本文整体上分为两部分，第一部分，是和大家一起弄明白上面三个概念；第二部分，我们会一起研究如何通过商业价值的挖掘、内生涯的修炼以及职业机会的寻找来实现薪水月薪3万的目标。
本文为万字长文，如果你没耐心看这么这么多干货，可以跳转到最后，那里有一个归纳总结，是压缩饼干式的超级干货，可能合你的胃口。
关键的基本概念 小米在发展过程中，挖过两个比较著名的人物，一个是谷歌Android副总裁胡戈·巴拉，一个是新浪总编陈彤。我们来看两个问题：
1. 小米看上了这两个人什么？
2. 这两个人看上了小米什么？
商业价值要素
胡戈·巴拉身上有几个很有价值的点，这是他能加盟小米的关键：
1. 在谷歌工作5年
2. Android产品管理副总裁
3. Android操作系统团队最具代表性的公众人物之一，他曾经频繁出席谷歌的新闻发布会以及谷歌的I/O开发者大会。比如Nexus 7平板电脑就是由他登台演示。
4. 熟悉海外市场
相信这也是小米看中胡戈·巴拉的重要原因。而这些原因，其实就是胡戈·巴拉身上体现出来的商业价值。具体来看，谷歌的工作是其个人经历，为其积累了广泛而有价值的人脉，同时他也在Android产品管理方面有独到的知识和技能。
好啦，注意我加粗的四个关键词，这就是个人商业价值当中的四个要素。
个人商业价值中还有非常非常重要的一个要素，那就是是天赋。天赋指人与生俱来的某些特质。在胡戈·巴拉身上来讲，人际交往能力和个人形象气质就属于天赋。在姚明身上，他的身高算是天赋之一种，特别有助于他的蓝球事业。在罗纳尔多身上，他的爆发力就是天赋，所以你经常看到他突然加速把对方球员摔在身后然后狂奔几十米形成单刀射门的优势。如果一个人能发挥其天赋，将其与职业关联起来，必能自我实现，有所成就。
总结一下，商业价值包含五个要素：
 知识 技能 天赋 经历 人脉  我们每个人身上都有这些东西，如何挖掘出来，如何着重培养某方面的价值，就是我们能不能获取高薪水的关键。
职业机会
现在我们看看胡戈·巴拉为什么会选择小米。我猜测有这么几点：
1. 小米处在中国这个经济快速增长的发展中国家
2. 智能手机的发展在中国处于上升期
3. 小米公司上升势头强劲
4. 负责小米国际业务拓展
5. 薪水可观
第一点是很宏观环境的东西，只有宏观环境足够好时，机会才会多。这也是为什么现在小米等手机厂商发力印度的原因。
第二点是产业环境，在一个好的宏观环境里，一个好的、处于快速发展期的产业是最有吸引力的，到这样的产业中去，个人必将随着产业的发展而有所成就。所谓站在风口上猪都能飞起来，就是这个道理。
第三点是可以说是组织环境，一家处在好的宏观环境下好的产业环境里的公司，又正处于上升期，对个人来讲，是天赐良机啊。到这样的公司里，你就是躺着不动都可能比一般人达到的高度高。
其他都是小米提供给胡戈·巴拉的职位相关的东西，属于职业资源。另外还有一点，是八卦了，据说胡戈·巴拉的前女友阿曼达·罗森博格曾与布林交往，这也可能是胡戈·巴拉从谷歌离职的原因之一。这一点其实关系到的是家庭环境，一个人的家庭，可能成为他选择新职业的助力，也可能成为阻力。比如有很多学生毕业后就被父母通过人脉安排到银行、电力等国有企业工作，如果他们要跳槽，父母一般都会成为阻力。
好啦，现在职业机会的五个要素都出来了：
 宏观环境 产业环境 组织环境 职业资源 家庭环境  陈彤的事儿我们就不说了，咱得赶紧看内生涯与外生涯了。
内生涯与外生涯
内生涯与外生涯是职业规划中非常重要的一组概念，理清了它们，我们就知道在哪个方向上努力可以提升自己，进而提升薪资待遇。
内生涯与外生涯，最直接的区分，就是用你的身体，我们常说的身外之物，其实就是外生涯。我们常说的内在，就是内生涯。比如你现在是华为的软件工程师，负责相机模块开发，月薪20K，这属于外生涯；而你熟悉C&#43;&#43;、Android的Camera框架、图像处理算法，这些就属于内生涯。
属于外生涯的那些身外之物，是别人、别的组织给予你的，很容易因为外界环境的变化而被剥夺。比如你曾经是诺基亚北京研发中心的开发人员，那2014年8月份诺基亚北京研发中心大裁员，你就会瞬间失去这个身份。
而我们归属于内生涯的那些内在之物，一旦拥有，就是你的，别人很难夺走。比如你掌握C&#43;&#43;这门语言，熟悉了Android应用开发框架，精通数据库调优，你工作负责，为人诚信，勇于担当，这些知识或技能或心态，别人不可能从你这里拿走（除非他有黑衣人的记忆消除棒或者他是吸血鬼日记里的斯特凡或达蒙，拥有擦除记忆的法力）。
现在对内生涯和外生涯我们应该比较清楚了，那我们来总结一下它们都包含哪些内容。
外生涯包括（但不限于）职务目标、经济收入、工作内容、工作环境、工作时间、工作地点、企业文化、薪酬福利、通勤状况等。
内生涯包括（但不限于）知识、技能、工作经验、心理素质、内心情感、行为习惯、视野、观念、职业心态（爱与感恩、责任、忠诚、诚信、勇气、担当）、职业成熟度、心灵成长等。
如果你仔细品味内生涯包括的东西，就会发现，它们和个人商业价值的某些要素是重叠的，尤其是知识、技能、天赋这些东西。而外生涯包含的一些东西，其实也和个人商业价值相关，比如你的职务目标、工作内容、工作过的企业等，都是你的经历。你在选择一份新的职业时，不论内外，只要能体现商业价值的内容，都会被重度参考。
内生涯与外生涯的关系
我们知道了内生涯和外生涯都包括哪些内容，接下来就是它们之间的关系，弄明白它们之间的关系，就可以导出如何规划自己的职业发展与方向了。
内生涯和外生涯包含的一些东西，既可能是企业选择你的依据，也可能是你选择新职业时的目标，影响你的职业选择。比如你在22~24岁时可能更看重知识、技能、工作经验的积累，积累到一定程度，你的职务目标、薪酬就会自然上升，工作内容也可能发生变化。而当你的职务、工作内容，也会影响到你积累什么样的知识和技能。
举个我自己的例子，我2005年开始做软件开发，做了两三年，积累了C&#43;&#43;、Windows开发、网络编程、MFC、WTL、Windows CE、多媒体等方面的知识和技能，2008年时开始带团队，工作内容分成开发和管理两部分，慢慢积累了项目管理和团队管理方面的知识和技能。在这个变化过程中，经济收入也发生了变化。当我再次选择职业时，我的知识、技能、曾经的工作经验、薪酬福利等，共同决定了我能找到什么样的职业：别的企业会看我的知识、技能、经历，我也会本着个人商业价值可持续发展的角度去选择职业机会。
OK，现在可以来说明内生涯和外生涯的关系了：
 内生涯决定外生涯 外生涯拉动内生涯  《花千骨》中有几段特别有意思的情节，可以印证内外生涯的关系。
花千骨投入长留，可她【仙资】有限，修行【飞剑术】，好久也飞不起来，在仙剑大会上败给霓漫天，却因缘际会得白子画收为徒弟，此时她作为【掌门首徒】，受到了很多人的质疑以及霓漫天的陷害。为了拿走花千骨掌门弟子的身份，霓漫天用涂了洗髓散（尹上漂提供）的毒针暗算花千骨，令其失去仙资。白子画耗费百年修为帮花千骨驱毒，不但恢复其仙资，还打通了她的【仙脉】，为其日后精进奠定坚实基础。
注意我标注重点的那些词，仙资、仙脉属于天赋，飞剑术属于技能，都是内生涯里面的东西；而掌门首徒则是身外之物，是别人赋予花千骨的一种身份，代表一种地位，是外生涯的东西。
只有飞剑术到一定程度，才有资格做掌门首徒。这是大部分人的看法，是内生涯决定外生涯的原则影响了人的看法。当内生涯低于外生涯时，如果个人不能很快通过修行提升内生涯，就会面临各种痛苦和压力：别人会质疑，为毛你嘛都不行还能当掌门首徒，尸位素餐，给我下来；自己也会怀疑，我到底是不是这块料啊，我如果真的不行怎么办呢。而一旦因为各种原因，内生涯真的配不上外生涯，那组织、他人就会采取措施剥夺你的外生涯。
古代的学而优则仕，也是内生涯决定外生涯的一种典型情况。其实我们身边也很多，普通的开发工程师知识、技能、经验修炼到一定程度，就可以做架构师、技术专家，这也是典型的内生涯决定外生涯。
当外生涯高于内生涯时，虽然有压力，但也会促使你提升自己的知识、技能等，使内生涯与外生涯匹配，最终内生涯超越外生涯，可以进一步在组织内或组织外发展，获得更高的外生涯。这就是外生涯拉动内生涯的一种表现。
说到这里我们再展开一下。当内生涯略高于外生涯时，工作会驾轻就熟，容易出成绩，感到轻松舒适。当内生涯高过外生涯一大截时，个人就会觉得怀才不遇，想谋求更高的发展，如果长时间处于失配状态，跳槽指数就会增高。当内生涯低于外生涯时，工作会感到吃力，需要不断提升自己。如果不能有效提升，就可能会被剥夺外生涯。
高薪的谋划之道 因为内生涯决定外生涯，所以，程序员要想获取高薪，最根本的策略是修炼内功，发挥自己的性格优势，挖掘自己的职业兴趣，找到适合自己的职业，发挥天赋，不断提升知识、技能，让自己的商业价值不断爬升。
而一个人的商业价值能否提现出来，和所处平台又有非常大的关系。当你在一个好的宏观环境里，在一个前景光明的产业里，在一个处于上升期的企业里时，你的价值很容易就能体现出来，你能获取到的回报（外生涯）也会超越大多数人。所以，除了修炼内功，还要懂得如何寻找职业机会，让自己有用武之地。这就是程序员谋取高薪的指导性原则。
下面我们展开来讲如何修炼内功以及如何寻找职业机会。
修炼内功
内功的修炼，其实又分为三部分：
1. 发挥性格优势
2. 挖掘职业兴趣
3. 积累知识和技能
假如你现在已经是软件开发工程师，那我们就略过第一和第二两步了。
假如你虽然是软件开发工程师，但不确定是否适合做下去，那可以看看我发表在微信订阅号“程序视界”的文章，“如何快速定位自己热爱的工作（程序员版）”，肯定会有帮助。
假如你是还没入职场的小鲜肉，OK，可以来找我聊聊，我们可以一起来看看你是否适合做程序员。
搞了这么多假如，那我们要关注的就只有第三点了，积累知识和技能。哇哈哈哈哈，终于到正题了，走，西天！
积累知识和技能有两个原则：
 职业目标相关性 持续性  有人说程序员是最爱项目符号列表的，凡事1、2、3……你看我这篇文章就能推断出，我一定是受了程序员工作经历的熏陶了。
职业目标相关性
这一点很容易理解，假如你就想做iOS应用开发，那你学C#估计就没什么用，学MFC就更没用了。一样知识，一种技能，只有它和你的目标相关时才是有用的。没用的知识对你来讲，再多都是枉然，假如一种知识不能落到应用上，那它就不是知识。我这是针对职业相关性来讲的哦，这句话写给那些爱抬杠的朋友们。
技能呢，其实又分为两类：
 专业技能 通用技能  专业技能是对某种专业知识的应用能力，与特定职业相关。比如磨剪子镪菜刀（现在很少了），你不走街串巷干这个行当，基本就没用了。再比如你能用MFC在Windows下开发客户端应用，现在你要去做Android开发，那用处也不大。
通用技能是可迁移的，就是你会做的事。比如你超级会写PPT，这种技能到哪里都用得上啊。比如你很善于沟通，总能与别人达成一致；比如你善于当众演讲；比如你社交能力强；比如你很会指导别人；比如游泳……这些都是通用的技能，可以在不同的工作中广泛应用。
通用技能对于你能否找到理想工作至关重要。
我们从程序员的世界来看，那些很牛X的人，比如马克·扎克伯格，一开始也是程序员，后来呢，人家创立Facebook，他的创新、谈判、指导、说服等通用能力一定很强。另外他还会中文（语言技能也是通用技能，和驾驶一样），可以用中文和习大大流畅交谈。还有雷军，写了十年程序，现在在做什么呢？如果他只会使用C语言开发能这样吗？
所以，我们在积累技能时，既要立足于现在的职业，强化职业相关的专业技能，比如你做Web前端的，HTMP、CSS、JavaScript、各种JS框架（比如JQuery、AngularJS等）、前端框架如Bootstrap，都可以玩得很熟，这是专业技能，必须的，你做前端就会用得上；又要留意专业技能之外的通用技能，通用技能是一个程序员的软实力，比如发现自己的学习模式，培养自我学习的能力，比如与人沟通的能力，比如口头表达能力，比如写作能力，比如信息检索能力……
那么，问题来了，怎样才能知道，一个职业都需要什么样的知识、技能呢？有三种途径：
 企业内的岗位描述 业内前辈访谈 招聘网站的招聘信息  一般的企业都会有岗位（职位）描述，说明这个职位的职责，需要的知识、技能。有的企业还有一条晋升通道，比如软件开发工程师会有初级、中级、高级、资深、专家等级别，每个级别的任职资格说明里通常会有对技能水平的说明。这是我们第一个可以接触到的资料。比如我曾经待过的公司就有这种说明，高级开发工程师会要求你C&#43;&#43;、概要设计、文档、数据库调优、授课、指导、管理等知识和能力。
第二种途径是找一个同岗位的前辈聊一聊，他很可能会给你和第一种途径不一样的视角，根据他的经验告诉你什么重要什么不重要，该培养什么不该培养什么。
第三种是非常有效的途径，不但可以弥补第一种途径的不足（有的公司会没有，有的公司会很简单而流于形式），还可以从中梳理出某个技术栈的发展态势。像智联招聘、拉钩、猎聘、大街网、51job等网站都会有大量软件开发工程师的招聘信息，可以结合我们自己的技术方向，拟定关键字进行搜索，然后看看别的企业对某个岗位都是什么要求。通过不断分析，就可以列出一张知识、技能清单来，拿着这个清单，就可以去有针对性的发展自己的技能，该自学的自学，该培训的培训，该参加开源项目的参加开源项目……
持续性
植物的顶芽优先生长而侧芽受抑制的现象，在植物学上称为顶端优势。为了维持顶端优势，可以人为干预植物的生长，比如一颗泡桐树，要想它长得又高又直又粗，就需要不断砍掉树干上的侧枝。
在企业管理领域存在顶端优势现象，处在优势的实权部门会抑制其它相关职能部门的发展，处于权力顶端的人往往抑制着处于下端的职权，处于优势的核心产品也会抑制其它产品的发展壮大……
对于程序员个人的知识和技能积累来讲，通常也需要维持顶端优势。
一个软件开发工程师，在自己知识图谱与技能树中，如果存在顶端优势现象，那当别人问你擅长什么时，你就可以信心满满地回答出来。而如果你的知识和技能还能在企业内超越其他程序员，形成群体内的比较优势或者顶端优势，那你的光芒一定照耀四方。
我承认，能做到第二步这种程度的人相对较少，所以，我们只讨论第一步：在自己的知识图谱与技能树中打造顶端优势。
毋庸讳言，软件开发工程师跳槽频率比大部分职业的从业者高一些，在不同的企业不同的行业为不同的用户开发不同的产品时，用到的知识和技能通常是不同的。这就会导致一种情形：什么都懂一点，什么都不精深，什么都能干一点儿，什么都干不专业。而知识越精深越有价值，技能越熟练产出率越高，现在以及将来是专业主义时代（参见大前研一的《专业主义》），如果我们能沿着一个方向积累知识锻炼技能，那就可以形成竞争优势，随着不断用心打磨，就会产生顶端优势，就越来越能解决问题，不可替代性就会越来越强，商业价值就越来越高，薪酬福利自然越来越好。
所以，工作一段时间之后，就要思考自己的职业目标，梳理自己的知识和技能，选择几样，着重培养，持续精进，形成优势。
寻找职业机会 修炼完内功，我们该来寻找外部机会了。
在向外看寻找机会时，有三个递进的层次需要注意：
 行（产）业 企业 职业  我们一个一个来讲。
行业选择
现在软件已经成为支撑各行各业发展的服务，几乎每个行业都会用到软件。行业里的企业在使用软件服务时，要么买现成的，要么自己开发。现成的软件，比如CRM、ERP、OA等，很多行业里的公司都用，也一般都是采购。除了采购软件，还有一些行业的公司选择自己开发，那这个时候就需要软件开发工程师，也就是程序员了。
必须注意的是，不同行业的程序员的平均薪酬待遇是相差很大的。行业越有前景，个人的发展越好回报越好。越赚钱的行业，处在它里面的程序员薪资水平越高。这是一般性规律，我们程序员在择业时也需要考虑。
以房地产行业为例，2003到2013是中国房地产黄金十年，处在这个行业里的从业人员，有很多都赚得盆满钵满。以商品房销售为例，售楼小姐曾经是收入非常高的职业，干上一两年，拿到的提成都能买几套房。房产中介也有同样的机会，我买学区房时，提供服务的房产中介，他们的片区经理，就是在那几年赚了两套房子，过上了相对丰裕的生活。而2013年后，房地产销售每况愈下，现在几乎是举步维艰，我们家楼下的房产中介每天门可罗雀，今天开一家，明天关两家。新建住宅也是人流稀少，销售惨淡。
再说说我曾经待过的电信行业，1995年到2012年是黄金阶段，其中1997到2005年，是固定电话业务和宽带业务大发展的时期，国内产生了华为、中兴、西安大唐电信、普天、UT斯达康、烽火等知名企业。我的前辈们说，1999、2000年左右，奖金比工资多，出差都是飞机，每天补助200左右。而我2002年加入西安大唐电信后不久，固话和程控交换业务开始走下坡路（2002年之后移动通信大发展），我们出差都是火车，坐卧铺都受限制，出差补助不但按城市分档还变少了，票据报销也很严格。所以，你进入一个产业的时机非常重要。
那么，我们该怎样选择行业？
先看一张图：
从上面的产业曲线图中可以看出，一般产业都有形成、发展、成熟、衰退四个时期。我们在选择一个产业时，发展期进入是最好的，成熟期也可以，衰退期就要慎重考虑了，除非你已无太多要求，只想随便干两年退休。
所以，作为程序员，也不能只盯着技术，还要看行业大势。“女怕嫁错郎，男怕入错行”这种老话是很有道理的。
现在（2015年），最有发展前景的行业是互联网、金融、医疗、教育、新能源、智慧产业、高端制造等。而一些传统行业，比如煤炭、电力、房地产、石油，都在走下坡路。再说下房地产，别看那些楼盘死撑着不降价，其实一个月也不见得卖出一套房去，很多房地产厂商想跑路都跑不掉，工地停工，薪资拖欠，各种新闻不断。
企业选择
2002年到2012年，移动通信黄金十年，最赚钱的公司除了中国移动，还包括一大波2G手机厂商以及其他设备厂商，西安大唐电信没能及时转型，迅速没落，原来的产业园都卖给陕鼓动力了，而华为则顺利转型，依然强劲，到处买地建园区，如日中天。一个程序员，在西安大唐电信和在华为，这么些年的感受肯定不同！
与行业类似，企业有投入、成长、成熟、衰退这样的发展周期。我们选择企业时也需要考虑目标企业的当前状况，是在快速成长还是正在衰退。对不太有冒险精神的程序员来讲，最好的进入时机是快速成长期，此时企业飞速扩张，各种机会很多，产品要不断迭代要形成技术优势，对技术人员需求很大，职位上的晋升，技术上的积淀，都会有很多。对于想拿青春赌明天的程序员来讲，也可以在一个公司的投入期进入，如果这家公司能突围，那作为初期的核心人员，回报是难以想象的，你只要看看阿里巴巴的十八罗汉就知道了。
选择朝阳行业，选择非衰退期的企业，这是寻找职业机会时必须要首先考虑的，只要你选对了行业进对了企业，个人的成长和回报是早晚的事儿。
我们还要展开来说一下，行业是由若干从事同一类或相近性质产品生产的企业组成的，在这些企业当中，一定有龙头老大，一定有前三甲，一定有前五前十，选择排名靠前的企业，一般来讲会更好一些。因为实力越强的企业，占有的资源越多，市场覆盖越广，盈利能力越强，现金流越好。企业盈利，企业现金充裕，员工收益自然也大。
可我为什么说一般呢？因为一个行业还有细分，还存在一些垄断细分领域的企业，虽然在整个行业中综合实力排名不靠前，但因为卡位好，此山是我开此树是我栽，要想从此过留下买路财，你想干那个领域的事儿就绕不开它，所以它也能活得很滋润。选择这样的企业，也相当不错。
职业
选对了行业，选对了企业，接下来就是选择企业内的职业了。
前面我们说互联网行业很好，金融行业很好，互联网金融也很好，你进了这些行业中的某家企业，也不一定有什么大发展。因为这里面还有职业之分。比如你在Camera360做前台，比如你在网易做行政专员，比如你在腾讯做保洁，是不是回报没那么高呢？
在一个企业里，一定是创造价值最多、距离核心价值链最近的职位的员工拿到的薪水最多（你要说有例外那我就认为你是在抬杠，不解释）。
有人说对于程序员来讲，根本没得选择，因为到哪个企业里都是做开发啊。
其实不然，还是有得选的。
比如你到一个房地产公司去做网站前端开发，你觉得怎么样？房地产公司最重要的部门是什么？肯定不是维护网站的技术部啊，你作为一个软件开发工程师，很可能受到的尊重拿到的薪水远不如销售人员。
对互联网公司来讲，最重要的是产品，那就对应有两个职位——产品经理和软件开发——很受重视。所以你到这样的公司里去做软件开发，就和到房地产公司感觉不一样。
再说说我们前文提到的华为，华为内部有核心网、终端、大数据等不同的部门，你觉得哪块的软件开发待遇更好？我猜是大数据和终端。
现在再来想，是不是有得选？
 补充一点：其实我们在选择行业和企业时，还要考虑宏观环境里的地域因素。比如你在西安，互联网氛围就不太好；比如你在郴州，整个软件行业就很差……所以有时为了更好的发展，有些程序员会选择到机会更多的城市，比如北京、上海、深圳等。而如果你不想换城市（像笔者一样），有时就得妥协。
 【没有一滴水分的总结】
我写文章经常放而不收，下笔千言离题万里，遭人诟病，这次我要学乖一点，来总结归纳一下。要点如下（符号列表，又见符号列表，符号列表让没有逻辑的我显得有条理）：
 个人的商业价值体现在知识、技能、经历、天赋、人脉等方面 宏观环境、产业、组织、职业、家庭等要素的综合会影响职业选择 知识、技能、天赋、经验等属于内生涯，是你的内在质量，没人可以剥夺 职务、薪酬福利、工作环境、工作内容等属于外生涯 内生涯决定外生涯，外生涯可以拉动内生涯 通过对知识、专业技能、通用技能等的不断积累，形成顶端优势，可以找到更好的外生涯目标 累积知识和技能时，注意职业目标相关性和持续性 要想高回报，选择前景好的行业里处于投入期、成长期的企业，在企业内选择靠近核心价值链的职位  </content>
    </entry>
    
     <entry>
        <title>[转]提问的智慧</title>
        <url>https://cppfans.org/2060.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>交流</tag><tag>智慧</tag><tag>疑问</tag>
        </tags>
        <content type="html">   提问的智慧   &amp;lt;div&amp;gt; &amp;lt;div class=&amp;#34;author&amp;#34;&amp;gt; &amp;lt;h3 class=&amp;#34;author&amp;#34;&amp;gt; 艾瑞克.史蒂文.雷蒙德（&amp;lt;span class=&amp;#34;firstname&amp;#34;&amp;gt;Eric&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;othername&amp;#34;&amp;gt;Steven&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;surname&amp;#34;&amp;gt;Raymond）&amp;lt;/span&amp;gt; &amp;lt;/h3&amp;gt; &amp;lt;div class=&amp;#34;affiliation&amp;#34;&amp;gt; &amp;lt;span class=&amp;#34;orgname&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://www.catb.org/~esr/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Thyrsus Enterprises&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;address&amp;#34;&amp;gt; &amp;lt;code class=&amp;#34;email&amp;#34;&amp;gt;&amp;amp;lt;&amp;amp;lt;a href=&amp;#34;mailto:esr@thyrsus.com&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;esr@thyrsus.com&amp;amp;lt;/a&amp;gt;&amp;amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div class=&amp;#34;author&amp;#34;&amp;gt; &amp;lt;h3 class=&amp;#34;author&amp;#34;&amp;gt; 瑞克.莫恩（&amp;lt;span class=&amp;#34;firstname&amp;#34;&amp;gt;Rick&amp;lt;/span&amp;gt; &amp;lt;span class=&amp;#34;surname&amp;#34;&amp;gt;Moen）&amp;lt;/span&amp;gt; &amp;lt;/h3&amp;gt; &amp;lt;div class=&amp;#34;affiliation&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;address&amp;#34;&amp;gt; &amp;lt;code class=&amp;#34;email&amp;#34;&amp;gt;&amp;amp;lt;&amp;amp;lt;a href=&amp;#34;mailto:respond-auto@linuxmafia.com&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;respond-auto@linuxmafia.com&amp;amp;lt;/a&amp;gt;&amp;amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;p class=&amp;#34;copyright&amp;#34;&amp;gt; 版权©2001, 2006 Eric S. Raymond, Rick Moen &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div class=&amp;#34;revhistory&amp;#34;&amp;gt; &amp;lt;table border=&amp;#34;1&amp;#34; summary=&amp;#34;Revision history&amp;#34; width=&amp;#34;100%&amp;#34;&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;th colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;修订历史&amp;lt;/b&amp;gt; &amp;lt;/th&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.9 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2013年4月23日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 修正链接 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.8 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2012年6月19日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 修正链接 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.7 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2010年12月6日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 对于英语为第二语言人士的有益建议 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.7 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2010年11月2日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 几种翻译不见了 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.6 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2008年3月19日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 小更新及新链接 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.5 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2008年1月2日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 勘误及一些翻译链接 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.4 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2007年3月24日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 新章节：“关于代码的问题” &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.3 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2006年9月29日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 增加凯.尼格曼（Kai Niggemann）的一个好建议 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.2 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2006年1月10日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 加入瑞克.莫恩（Rick Moen）编写的内容 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.1 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2004年10月28日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 文档“谷歌是你的朋友！” &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 修订版 3.0 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; 2004年2月2日 &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34;&amp;gt; esr &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr&amp;gt; &amp;lt;td colspan=&amp;#34;3&amp;#34; align=&amp;#34;left&amp;#34;&amp;gt; 主要新增在网页论坛应有的礼节 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;hr /&amp;gt; 
 原文：How To Ask Questions The Smart Way
翻译：王刚 时间：2013年10月26日  内容 &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#translations&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;译文&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#disclaimer&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;弃权申明&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#intro&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;引言&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#before&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;提问前&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#asking&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;提问时&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#forum&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;仔细挑选论坛&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#usefora&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;面向新手的论坛和互联网中继聊天（IRC）通常响应最快&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#uselists&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;第二步，使用项目的邮件列表&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#bespecific&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;使用有意义且明确的主题&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#easyreply&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;使问题容易回复&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#writewell&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;用清晰、语法、拼写正确的语句书写&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#formats&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;使用易于读取且标准的文件格式发送问题&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#beprecise&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;描述问题应准确且有内容&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#volume&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;量不在多，精炼则灵&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id264997&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;别急于宣称找到臭虫&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id265155&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;低声下气代替不了做自己的家庭作业&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#symptoms&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;描述问题症状而不是猜测&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#chronology&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;按时间先后罗列问题症状&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#goal&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;描述目标而不是过程&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#noprivate&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;别要求私下回复电邮&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#explicit&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;提问应明确&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#code&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;关于代码的问题&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#homework&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;别张贴家庭作业式问题&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#prune&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;删除无意义的要求&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#urgent&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;不要把问题标记为“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;紧急&amp;lt;/span&amp;gt;”， 即使对你而言的确如此&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#courtesy&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;礼貌总是有益的&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#followup&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;问题解决后追加一条简要说明&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#answers&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;如何解读回答&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#rtfm&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;“读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#lesser&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;如果还不明白……&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect2&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#keepcool&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;对待无礼&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#not_losing&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;别象失败者那样反应&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#classic&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;提问禁忌&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#examples&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;好问题与坏问题&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266352&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;如果得不到回答&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266392&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;如何更好地回答&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266466&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;相关资源&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;sect1&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266494&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;鸣谢&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;/dl&amp;gt; 
  译文    
&amp;lt;p&amp;gt; 译文： &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://bulsara.host.sk/index.php?p=2005&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;印尼语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.fatcow.com/edu/smart-questions-by&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;白俄罗斯语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.istf.com.br/perguntas/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;巴西葡萄牙语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.beiww.com/doc/oss/smart-questions.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;简体中文&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://docs.jaspervries.nl/smart-questions/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;荷兰语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.gnurou.org/documents/smart-questions-fr.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;法语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://maxo127.narod.ru/Geo/Articles/smart-questions_ge.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;乔治亚语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.tty1.net/smart-questions_de.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;德语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.dionyziz.com/howto-smart-questions-gr/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;希腊语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.penguin.org.il/essays/smart-questions-he.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;希伯来语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.ranvis.com/articles/smart-questions.ja.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;日语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://rtfm.killfile.pl/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;波兰语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.celiojunior.com.br/comofazerperguntas.htm&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;葡萄牙语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://wiki.lug.ro/mediawiki/index.php/Cum_se_pun_%C3%AEntreb%C4%83ri_%C3%AEn_mod_inteligent&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;罗马尼亚语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://maddog.sitengine.ru/smart-question-ru.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;俄语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://www.sindominio.net/ayuda/preguntas-inteligentes.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;西班牙语&amp;lt;/a&amp;gt; &amp;lt;a class=&amp;#34;ulink&amp;#34; href=&amp;#34;http://wiki.opentle.org/Smart-questions&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;泰语&amp;lt;/a&amp;gt; 如果你想复制、镜像、翻译或引用本文，请参阅我的 &amp;lt;a href=&amp;#34;http://www.catb.org/~esr/copying.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;复制协议&amp;lt;/a&amp;gt;。 &amp;lt;/p&amp;gt; 
  弃权申明    
&amp;lt;p&amp;gt; 许多项目的网站在如何取得帮助的部分链接了本文，这没有关系，也正是我们想要的。但如果你是该项目生成此链接的网管，请在链接附近显著位置注明：&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;我们不提供该项目的服务支持！&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 我们已经领教了没有此说明带来的痛苦，我们将不停地被一些白痴纠缠，他们认为既然我们发布了本文，那么我们就有责任解决世上所有的技术问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你是因为需要帮助正在阅读本文，然后就带着可以直接从作者那取得帮助的印象离开，那么 &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;你 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;就不幸成了我们所说的白痴之一。 别向&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 我们&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; 提问，我们不会理睬的。 我们只是在这教你如何从那些真正懂得你软硬件问题的人那里取得帮助，但 99.9％ 的时间我们不会是那些人。除非你非常地&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 确定&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; 本文的作者是你遇到问题方面的专家，请不要打搅，这样大家都更开心一点。 &amp;lt;/p&amp;gt; 
  引言    
&amp;lt;p&amp;gt; 在 &amp;lt;a href=&amp;#34;http://www.catb.org/~esr/faqs/hacker-howto.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;黑客&amp;lt;/a&amp;gt; 的世界里，你所提技术问题的解答很大程度上取决于你提问的方式与解决此问题的难度，本文将教你如何提问才更有可能得到满意的答复。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 开源程序的应用已经很广，你通常可以从其他更有经验的用户而不是黑客那里得到解答。这是好事，他们一般对新手常有的毛病更容忍一点。然尔，使用我们推荐的方法，象对待黑客那样对待这些有经验的用户，通常能最有效地得到问题的解答。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 第一件需要明白的事是黑客喜欢难题和激发思考的好问题。假如不是这样，我们也不会写本文了。如果你能提出一个有趣的问题让我们咀嚼玩味，我们会感激你。好问题是种激励与礼物，帮助我们发展认知，揭示没有注意或想到的问题。在黑客中，“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;好问题！&amp;lt;/span&amp;gt;” 是非常热烈而真挚的赞许。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 此外，黑客还有遇到简单问题就表现出敌视或傲慢的名声。有时，我们看起来还对新手和愚蠢的家伙有条件反射式的无礼，但事情并不真是这样。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 我们只是毫无歉意地敌视那些提问前不愿思考、不做自己家庭作业的人。这种人就象时间无底洞──他们只知道索取，不愿意付出，他们浪费了时间，这些时间本可用于其它更有趣的问题或更值得回答的人。我们将这种人叫做 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;失败者（loser）&amp;lt;/span&amp;gt;” （由于历史原因，我们有时将“loser”拼写为“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;lusers&amp;lt;/span&amp;gt;” 。） &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，计算机只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做，我们承认这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。不过，我们回答问题的风格是为了适应那些&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;真正&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就会在自己能做得最好的事情上不再那么犀利。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 我们（大多数）是自愿者， 从自己繁忙的生活中抽时间来回答问题，有时会力不从心。因此，我们会毫不留情地滤除问题，特别是那些看起来象是失败者提的，以便更有效地把回答问题的时间留给那些胜利者。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你认为这种态度令人反感、以施惠者自居或傲慢自大，请检查你的假设，我们并未要求你屈服──事实上，假如你做了该做的努力，我们中的大多数将非常乐意平等地与你交流，并欢迎你接纳我们的文化。试图去帮助那些不愿自救的人对我们简直没有效率。不懂没有关系，但愚蠢地做事不行。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 所以，你不必在技术上很在行才能吸引我们的注意，但你&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 必须 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;表现出能引导你在行的姿态──机 敏、有想法、善于观察、乐于主动参与问题的解决。如果你做不到这些使你与众不同的事情，我们建议你付钱跟别人签商业服务合同，而不是要求黑客无偿帮助。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你决定向我们求助，你不会想成为一名失败者，你也不想被看成一个失败者。得到快速有效回答的最好方法是使提问者看起来象个聪明、自信和有想法的人，并且暗示只是碰巧在某一特别问题上需要帮助。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; （欢迎对本文指正，可以将建议发至 &amp;lt;a href=&amp;#34;mailto:esr@thyrsus.com&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;esr@thyrsus.com&amp;lt;/a&amp;gt; 或 &amp;lt;a href=&amp;#34;mailto:esr@thyrsus.com&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;respond-auto@linuxmafia.com&amp;lt;/a&amp;gt;。 请注意，本文不想成为一般性的 &amp;lt;a href=&amp;#34;http://www.ietf.org/rfc/rfc1855.txt&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;网络礼仪&amp;lt;/a&amp;gt; 指南，我一般会拒绝那些与引出技术论坛中有用的回答不特别相关的建议。） &amp;lt;/p&amp;gt; 
  提问前    
&amp;lt;p&amp;gt; 在通过电邮、新闻组或论坛提技术问题以前，做以下事情： &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;procedure&amp;#34;&amp;gt; &amp;lt;ol type=&amp;#34;1&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 尝试在你准备提问论坛的历史文档中搜索答案 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 尝试搜索互联网以找到答案 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 尝试阅读手册以找到答案 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 尝试阅读“常见问题文档”（FAQ）以找到答案 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 尝试自己检查或试验以找到答案 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 尝试请教懂行的朋友以找到答案 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 如果你是程序员，尝试阅读源代码以找到答案 &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 学到的东西 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;，我们喜欢回答那些表现出能从答案中学习的人。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 &amp;lt;a href=&amp;#34;http://groups.google.com/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;谷歌论坛&amp;lt;/a&amp;gt;，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;我在谷歌中搜过下列句子但没有找到什么有用的东西&amp;lt;/span&amp;gt;” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;愚蠢的问题……&amp;lt;/span&amp;gt;”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 永远不要假设你&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 有资格 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;有没有人能指个方向？&amp;lt;/span&amp;gt;”，&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;我这还差点什么？&amp;lt;/span&amp;gt;”，“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;我应该查哪个网站？&amp;lt;/span&amp;gt;”，通常要比 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请给出我可以用的完整步骤&amp;lt;/span&amp;gt;”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。 &amp;lt;/p&amp;gt; 
  提问时    
&amp;lt;div class=&amp;#34;sect2&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;forum&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;仔细挑选论坛 &amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”： &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;itemizedlist&amp;#34;&amp;gt; &amp;lt;ul type=&amp;#34;disc&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 张贴与论坛主题无关的问题 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 在太多不同的新闻组同时张贴 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 给既非熟人也没有义务解决你问题的人发送你私人的电邮 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 阅读 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告臭虫的流程或链接，如果是这样，去看看。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect2&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;usefora&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;面向新手的论坛和互联网中继聊天（IRC）通常响应最快 &amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;用&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 我们的 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;代码&amp;lt;/span&amp;gt;”。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect2&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;uselists&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;第二步，使用项目的邮件列表 &amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由： &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;itemizedlist&amp;#34;&amp;gt; &amp;lt;ul type=&amp;#34;disc&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 如果一个项目既有 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;用户&amp;lt;/span&amp;gt;” 也有“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;开发者&amp;lt;/span&amp;gt;”（或 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;黑客&amp;lt;/span&amp;gt;”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 然尔，如果你&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 确信 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;你的问题不一般，而且在“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;用户&amp;lt;/span&amp;gt;” 列表或论坛中几天都没有回复，可以试试“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;开发者&amp;lt;/span&amp;gt;”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意） &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect2&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;bespecific&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;使用有意义且明确的主题 &amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请帮我&amp;lt;/span&amp;gt;” （更别提大写的 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请帮我！！！！&amp;lt;/span&amp;gt;”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 使用主题的好惯例是“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;对象──偏差&amp;lt;/span&amp;gt;”（式的描述），许多技术支持组织就是这样做的。在“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;对象&amp;lt;/span&amp;gt;”部分指明是哪一个或哪一组东西有问题，在“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;偏差&amp;lt;/span&amp;gt;”部分则描述与期望的行为不一致的地方。 &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;variablelist&amp;#34;&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;愚蠢：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 救命啊！我的笔记本视频工作不正常！&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;明智：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;更明智：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 编写 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;对象──偏差&amp;lt;/span&amp;gt;”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;Re: 测试&amp;lt;/span&amp;gt;” 或者 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;Re: 新臭虫&amp;lt;/span&amp;gt;”的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 只想 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;在该线索当前活跃的人群中提问，还是另起炉灶比较好。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect2&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;easyreply&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;使问题容易回复 &amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 以“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请向……回复&amp;lt;/span&amp;gt;”来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，&amp;lt;a href=&amp;#34;http://linuxmafia.com/faq/Mail/muas.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;换个好点的&amp;lt;/a&amp;gt;；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;留意本线索&amp;lt;/span&amp;gt;”、“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;有回复发送邮件&amp;lt;/span&amp;gt;”等功能。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect2&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h3 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;writewell&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;用清晰、语法、拼写正确的语句书写 &amp;lt;/h3&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 必须 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;很准确，而且有迹象表明你是在思考和关注问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 正确地拼写、使用标点和大小写，不要将“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;its&amp;lt;/span&amp;gt;”混淆为“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;it&amp;#39;s&amp;lt;/span&amp;gt;”，“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;loose&amp;lt;/span&amp;gt;”搞成“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;lose&amp;lt;/span&amp;gt;”或者将“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;discrete&amp;lt;/span&amp;gt;”弄成 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;discreet&amp;lt;/span&amp;gt;”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。） &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将“you”简化为“u”会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如： &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;itemizedlist&amp;#34;&amp;gt; &amp;lt;ul class=&amp;#34;itemizedlist&amp;#34; type=&amp;#34;disc&amp;#34;&amp;gt; &amp;lt;li class=&amp;#34;listitem&amp;#34;&amp;gt; 英语不是我的母语，请谅解拼写错误。 &amp;lt;/li&amp;gt; &amp;lt;li class=&amp;#34;listitem&amp;#34;&amp;gt; 如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。 &amp;lt;/li&amp;gt; &amp;lt;li class=&amp;#34;listitem&amp;#34;&amp;gt; 对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。 &amp;lt;/li&amp;gt; &amp;lt;li class=&amp;#34;listitem&amp;#34;&amp;gt; 我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; 
  使用易于读取且标准的文件格式发送问题    
&amp;lt;p&amp;gt; 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;itemizedlist&amp;#34;&amp;gt; &amp;lt;ul type=&amp;#34;disc&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 使用纯文本而不是 HTML（超文本标注语言）（ &amp;lt;a href=&amp;#34;http://www.birdhouse.org/etc/evilmail.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;关闭HTML&amp;lt;/a&amp;gt; 并不难） &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 但是，也&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 不要 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 在英语论坛中，不要使用&amp;#39;Quoted-Printable&amp;#39; MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;永远不要 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;聪明引用&amp;lt;/span&amp;gt;”功能（在“工具” -&amp;gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 在论坛，勿滥用“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;表情符号&amp;lt;/span&amp;gt;”和“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;HTML&amp;lt;/span&amp;gt;”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的“查看源码”命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。 &amp;lt;/p&amp;gt; 
  描述问题应准确且有内容    
&amp;lt;div class=&amp;#34;itemizedlist&amp;#34;&amp;gt; &amp;lt;ul type=&amp;#34;disc&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 仔细、清楚地描述问题的症状 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;Fedora Core 7&amp;lt;/span&amp;gt;”、“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;Slackware 9.1&amp;lt;/span&amp;gt;”等） &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 描述提问前做过的研究及其理解。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 描述提问前为确定问题而采取的诊断步骤。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 描述最近对计算机或软件配置的任何相关改变。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 如果可能，提供在可控环境下重现问题的方法。 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 尽最大努力预测黑客会提到的问题，并提前备好答案。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 西蒙.泰瑟姆（Simon Tatham）写过一篇 &amp;lt;a href=&amp;#34;http://www.chiark.greenend.org.uk/~sgtatham/bugs.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;如何有效报告臭虫&amp;lt;/a&amp;gt; 的文章，我强烈推荐各位阅读。 &amp;lt;/p&amp;gt; 
  量不在多，精炼则灵    
&amp;lt;p&amp;gt; 你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 有用的 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;回复。第三，在提纯臭虫报告的过程中，你可能自己就找到了解决办法或权宜之计。 &amp;lt;/p&amp;gt; 
  别急于宣称找到臭虫    
&amp;lt;p&amp;gt; 当你在一个软件中遇到问题，除非你&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 非常、非常 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;的有根据，不要动辄声称找到了臭虫。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;臭虫&amp;lt;/span&amp;gt;”，你应该能提供相应位置的替代文本。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（你在报怨前已经做了这些，&amp;lt;a title=&amp;#34;Before You Ask&amp;#34; href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#before&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;是吧&amp;lt;/a&amp;gt; ？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了臭虫，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;臭虫&amp;lt;/span&amp;gt;”也是特别不老练的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 提问时，即使你私下非常确信已经发现一个真正的臭虫，最好写得象是&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 你 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;做错了什么。如果真的有臭虫，你会在回复中看到这点。这样做的话，如果真有虫子，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。 &amp;lt;/p&amp;gt; 
  低声下气代替不了做自己的家庭作业    
&amp;lt;p&amp;gt; 有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;我知道我只是个可怜的新丁，一个失败者，但……&amp;lt;/span&amp;gt;”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。 &amp;lt;/p&amp;gt; 
  描述问题症状而不是猜测    
&amp;lt;p&amp;gt; 告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。 &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;variablelist&amp;#34;&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;愚蠢：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;明智：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。 &amp;lt;/p&amp;gt; 
  按时间先后罗列问题症状    
&amp;lt;p&amp;gt; 刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。 &amp;lt;/p&amp;gt; 
  描述目标而不是过程    
&amp;lt;p&amp;gt; 如果你想弄清楚如何做某事（而不是报告一个臭虫），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。 &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;variablelist&amp;#34;&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;愚蠢：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;明智：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。 &amp;lt;/p&amp;gt; 
  别要求私下回复电邮    
&amp;lt;p&amp;gt; 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 当你要求私下回复时，此过程和回报都被中止。别这样做，让&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 回复者 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;向我发电邮，我将为论坛归纳这些回复&amp;lt;/span&amp;gt;”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。 &amp;lt;/p&amp;gt; 
  提问应明确    
&amp;lt;p&amp;gt; 漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请问可否指点一下哪有好一点的 X 解释？&amp;lt;/span&amp;gt;”通常要比“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请解释一下 X&amp;lt;/span&amp;gt;”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。 &amp;lt;/p&amp;gt; 
  关于代码的问题    
&amp;lt;p&amp;gt; 别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示&amp;lt;x&amp;gt;，但实际出现的是&amp;lt;y&amp;gt;”非常有可能让你得到回复。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 &amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#volume&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;量不在多，精炼则灵&amp;lt;/a&amp;gt; ）。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 &amp;lt;/p&amp;gt; 
  别张贴家庭作业式问题    
&amp;lt;p&amp;gt; 黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 你 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;用户&amp;lt;/span&amp;gt;”邮件列表或论坛中提问。尽管黑客们&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 会 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;看出来，一些老用户也许仍会给你提示。 &amp;lt;/p&amp;gt; 
  删除无意义的要求    
&amp;lt;p&amp;gt; 抵制这种诱惑，即在求助消息末尾加上诸如“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;有人能帮我吗？&amp;lt;/span&amp;gt;”或“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;有没有答案？&amp;lt;/span&amp;gt;”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;是的，你可以得到帮助&amp;lt;/span&amp;gt;”和“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;不，没有给你的帮助&amp;lt;/span&amp;gt;”。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 一般来说，避免提“是或否”类型的问题，除非你想得到 “&amp;lt;a href=&amp;#34;http://homepage.ntlworld.com./jonathan.deboynepollard/FGA/questions-with-yes-or-no-answers.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;是或否”类型的回答&amp;lt;/a&amp;gt;。 &amp;lt;/p&amp;gt; 
  不要把问题标记为“紧急”， 即使对你而言的确如此    
&amp;lt;p&amp;gt; 这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！ &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;紧急：帮我救救这个毛绒绒的小海豹！&amp;lt;/span&amp;gt;”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。 &amp;lt;/p&amp;gt; 
  礼貌总是有益的    
&amp;lt;p&amp;gt; 礼貌一点，使用“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请&amp;lt;/span&amp;gt;”和“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;谢谢你的关注&amp;lt;/span&amp;gt;”或者“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;谢谢你的关照&amp;lt;/span&amp;gt;”，让别人明白你感谢他们无偿花时间帮助你。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的臭虫报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的） &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 然尔，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; （我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;提前谢了&amp;lt;/span&amp;gt;”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;提前谢了&amp;lt;/span&amp;gt;”，事后&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 再 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;对回复者表示感谢，要么换种方式表达，譬如用“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;谢谢你的关注&amp;lt;/span&amp;gt;”或“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;谢谢你的关照&amp;lt;/span&amp;gt;”）。 &amp;lt;/p&amp;gt; 
  问题解决后追加一条简要说明    
&amp;lt;p&amp;gt; 问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 最理想的方式是向最初提问的线索回复此消息，并在主题中包含“已解决”、“已搞定”或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;问题 X&amp;lt;/span&amp;gt;”和“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;问题 X-已解决&amp;lt;/span&amp;gt;”的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 追加的消息用不着太长或太复杂，一句简单的“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;你好──是网线坏了！谢谢大家──比尔&amp;lt;/span&amp;gt;”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;在此之后 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。“挠痒痒”为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。 &amp;lt;/p&amp;gt;  
  如何解读回答       “读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸    
&amp;lt;p&amp;gt; 有一个古老而神圣的传统：如果你收到&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;“读读该死的手册”（RTFM） &amp;lt;/span&amp;gt;的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; “读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;“搜搜该死的网络”（STFW）&amp;lt;/span&amp;gt;的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;“谷歌是你的朋友！”&amp;lt;/span&amp;gt;) &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息很容易找到。第二，自已找要比别人喂到嘴里能学得更多。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。 &amp;lt;/p&amp;gt; 
  如果还不明白……    
&amp;lt;p&amp;gt; 如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 譬如，假如我告诉你：“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;看起来象是某输入项有问题，你需要清除它&amp;lt;/span&amp;gt;”，接着是个 &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;不好 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;的回帖：“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;什么是某输入项？&amp;lt;/span&amp;gt;”。而这是一个&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 很好 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;的跟帖：“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？&amp;lt;/span&amp;gt;” &amp;lt;/p&amp;gt; 
  对待无礼    
&amp;lt;p&amp;gt; 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 没有 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 你 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; （有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;正常&amp;lt;/span&amp;gt;”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 喜欢 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;现在这个样子，并且一般都对病号标记有站得住脚的怀疑。） &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 在下一节，我们会谈到另一个问题，当&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 你 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;行为不当时会受到的“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;冒犯&amp;lt;/span&amp;gt;”。 &amp;lt;/p&amp;gt;  
  别象失败者那样反应      在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。  这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做：  熬过去，这很正常。事实上，它是有益健康与恰当的。  社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。  也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。  是夸张的“友谊”（以上述方式）还是有用？挑一个。  记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。  有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。  这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。  也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。 
  提问禁忌      下面是些典型的愚蠢问题和黑客不回答它们时的想法。   问：我到哪可以找到某程序或 X 资源？ 
&amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id265951&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;我怎样用 X 做 Y？&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id265970&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;如何配置我的 shell 提示？&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id265994&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266016&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;我的{程序、配置、SQL 语句}不运行了&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266052&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;我的视窗电脑出问题了，你能帮忙吗？&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266079&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;我的程序不运行了，我认为系统工具X有问题&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266099&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;我安装 Linux 或 X 遇到困难，你能帮忙吗？&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dt&amp;gt; 问：&amp;lt;a href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#id266136&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？&amp;lt;/a&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;table border=&amp;#34;0&amp;#34; summary=&amp;#34;Q and A Set&amp;#34;&amp;gt; &amp;lt;colgroup&amp;gt; &amp;lt;col width=&amp;#34;1%&amp;#34; align=&amp;#34;left&amp;#34; /&amp;gt;&amp;lt;/colgroup&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id265927&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id265929&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我到哪可以找到某程序或 X 资源？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 &amp;lt;a href=&amp;#34;http://www.google.com/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;谷歌 &amp;lt;/a&amp;gt;吗？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id265951&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id265953&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我怎样用 X 做 Y？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id265970&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id265972&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 如何配置我的 shell 提示？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 如果你有足够的智慧提这个问题，你也该有足够的智慧去 &amp;lt;a title=&amp;#34;RTFM and STFW: How To Tell You&amp;#39;ve Seriously Screwed Up&amp;#34; href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#rtfm&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;“读读该死的手册”（RTFM）&amp;lt;/a&amp;gt;，然后自己去找出来。 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id265994&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id265997&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266016&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id266018&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我的{程序、配置、SQL 语句}不运行了 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：&amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;itemizedlist&amp;#34;&amp;gt; &amp;lt;ul type=&amp;#34;disc&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 你还有什么补充吗？ &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 噢，太糟了，希望你能搞定。 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 这跟我究竟有什么关系？ &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266052&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id266055&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我的视窗电脑出问题了，你能帮忙吗？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 可以 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266079&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id266081&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我的程序不运行了，我认为系统工具 X 有问题 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266099&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id266101&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我安装 Linux 或 X 遇到困难，你能帮忙吗？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 &amp;lt;a href=&amp;#34;http://www.linux.org/groups/index.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;这里&amp;lt;/a&amp;gt; 找到用户组列表）&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 注意：如果安装问题与某 Linux 发行版有关，在针对&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 它 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 所有 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;被怀疑的硬件 [作关键词] 仔细搜索。&amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;question&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266136&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;a id=&amp;#34;id266138&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;问：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？ &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt; &amp;lt;tr class=&amp;#34;answer&amp;#34;&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; &amp;lt;b&amp;gt;答：&amp;lt;/b&amp;gt; &amp;lt;/td&amp;gt; &amp;lt;td align=&amp;#34;left&amp;#34; valign=&amp;#34;top&amp;#34;&amp;gt; 想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。 &amp;lt;/td&amp;gt; &amp;lt;/tr&amp;gt;&amp;lt;/tbody&amp;gt; &amp;lt;/table&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect1&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;examples&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;好问题与坏问题 &amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。 &amp;lt;/p&amp;gt; &amp;lt;div class=&amp;#34;variablelist&amp;#34;&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;愚蠢：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt;我在哪能找到关于 Foonly Flurbamatic 设备的东西？&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 这个问题在乞求得到 &amp;lt;a title=&amp;#34;RTFM and STFW: How To Tell You&amp;#39;ve Seriously Screwed Up&amp;#34; href=&amp;#34;http://doc.zengrong.net/smart-questions/cn.html#rtfm&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;“搜搜该死的网络”（STFW）&amp;lt;/a&amp;gt; 式的回复。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;明智：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; 我用谷歌搜索过“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;Foonly Flurbamatic 2600&amp;lt;/span&amp;gt;”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;variablelist&amp;#34;&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;愚蠢：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; 我不能编译某项目的源代码，它为什么这么破？&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 提问者假设是别人搞砸了，太自大了。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;明智：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;variablelist&amp;#34;&amp;gt; &amp;lt;dl&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;愚蠢：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; 我的主板有问题，谁能帮我？&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 某黑客对此的反应可能是：“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;是的，还需要帮你拍背和换尿布吗？&amp;lt;/span&amp;gt;”，然后是敲下删除键。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;dt&amp;gt; &amp;lt;span class=&amp;#34;term&amp;#34;&amp;gt;&amp;lt;span class=&amp;#34;strong&amp;#34;&amp;gt;&amp;lt;strong&amp;gt;明智：&amp;lt;/strong&amp;gt;&amp;lt;/span&amp;gt; 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？&amp;lt;/span&amp;gt; &amp;lt;/dt&amp;gt; &amp;lt;dd&amp;gt; 相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。&amp;lt;/p&amp;gt; &amp;lt;/dd&amp;gt; &amp;lt;/dl&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 在最后那个问题中，注意“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;给我一个回答&amp;lt;/span&amp;gt;”与“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;请帮我看看我还能再做点什么测试以得到启发&amp;lt;/span&amp;gt;”之间细微但重要的差别。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;名字&amp;lt;/span&amp;gt;挂在列表上，而只是因为我正确的提问方式。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt; 表现得 &amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect1&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266352&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;如果得不到回答 &amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect1&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266392&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;如何更好地回答 &amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;态度和善一点。&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;对初犯者私下回复。&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;如果你不确定，一定要说出来！&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;如果帮不了忙，别妨碍。&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;探索性的反问以引出更多的细节。&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;如果你决意回答，给出好的答案。&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt; 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过X，Y，Z，A，B与C都没有得到想要的結果，那么回复&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;试试A或B&amp;lt;/span&amp;gt;”&amp;lt;/span&amp;gt; 或者给出一个内容为 &amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;试一下X，Y，Z，A，B或C&amp;lt;/span&amp;gt;”&amp;lt;/span&amp;gt;的链接将极其无益！ &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;帮助你的社区从中学习&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;。当回复一个好问题时，问问自己 “&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;如何修改相关文件或 FAQ 文档以免再次解答同样的问题？&amp;lt;/span&amp;gt;”，接着再向文档维护者发一份补丁。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果你是在研究一番后才做出的回答，&amp;lt;span class=&amp;#34;emphasis&amp;#34;&amp;gt;&amp;lt;em&amp;gt;展现你的技巧而不是直接端出结果&amp;lt;/em&amp;gt;&amp;lt;/span&amp;gt;。毕竟“授人以鱼，不如授人以渔”。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect1&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266466&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;相关资源 &amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 如果需要个人电脑、Unix 和互联网如何工作的基础知识，参阅 &amp;lt;a href=&amp;#34;http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Unix 和互联网工作的基本原理&amp;lt;/a&amp;gt;。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 当你发布软件或补丁时，试着按 &amp;lt;a href=&amp;#34;http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html&amp;#34; target=&amp;#34;_top&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;软件发布实践&amp;lt;/a&amp;gt; 操作。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;sect1&amp;#34; lang=&amp;#34;en&amp;#34; xml:lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;titlepage&amp;#34;&amp;gt; &amp;lt;div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;h2 class=&amp;#34;title&amp;#34;&amp;gt; &amp;lt;a id=&amp;#34;id266494&amp;#34;&amp;gt;&amp;lt;/a&amp;gt;鸣谢 &amp;lt;/h2&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt; 伊夫林.米切尔（Evelyn Mitchell）贡献了一些愚蠢问题例子并启发了编写“&amp;lt;span class=&amp;#34;quote&amp;#34;&amp;gt;如何更好地回答问题&amp;lt;/span&amp;gt;”这一节，米哈伊尔.罗门迪克（Mikhail Ramendik）贡献了一些特别有价值的建议和改进。 &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt;</content>
    </entry>
    
     <entry>
        <title>什么时候需要学一门新的编程语言？</title>
        <url>https://cppfans.org/2038.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>程序员</tag><tag>编程</tag><tag>语言</tag>
        </tags>
        <content type="html">   声明：本文没有任何褒贬或者对比各种编程语言的意思，请不要做无谓的语言之争。
 我们这些80后程序员大部分人都是从delphi，C，C&#43;&#43;开始接触编程的，然后等到了大学或者工作，因为生计或者其他种种原因，大家从事的行业开始有了变化，从而导致开发语言也有了一些变化，一些做后端的，开始使用Java，C&#43;&#43;等等，一些做前端的开始用php，js等等。
然而，当我们用一门语言很久之后，就会对这门语言有了更多更深刻的了解，优点缺点、解决方案等等，而且大部分人会有一中喜新厌旧的心里，再加上市面上的新语言、新特性层出不绝，特别是看到那些你曾经花了很大精力想了各种奇淫技巧解决了一个问题，而在某些新语言中这只是一个普通特性，所以大家难免会心里痒痒，“我要不要学这个新语言，我要不要在工作环境中使用这个语言？”
这篇文章我就两方面讲下什么时候需要学一门编程语言，一个是学新语言是否真的对你的开发工作有帮助，一个是你的生活工作环境中是否允许你用新的语言。因为我是从事游戏服务器开发，主要语言是C&#43;&#43;，而我打算学习C#，以下的内容就用这两门语言做例子。
学新语言是否真的对你的开发工作有帮助？ 我们学习任何东西都是建立在有需要的情况下，如果知识不能转化成财富，估计很少有人会去上学。所以学一门新的编程语言是否对我们有帮助是很重要的，不过如果你只是单纯的兴趣，那倒是无所谓。学习新语言的原因基本分为下面几种：
 现在的语言太复杂，很多特性非常老，实现功能起来很纠结，需要一门简单实用的新语言快速解决问题，新语言简洁高效，特性强大 现在的语言需要大量的第三方库，而新语言自带平常开发的大部分库 现在的语言开发效率太低，新语言分分钟撸一个功能模块出来  上面的几点，总结起来就是现在的语言用起来很不爽，需要新语言来帮助我提高效率。
简单高效一直是现代编程语言的核心思想，通过C&#43;&#43; 11,14,17标准我们很明显的看出来，C&#43;&#43;当初为了兼容C(挖C程序员的墙角)，做了很多现在看来很纠结的东西，而新标准就是在改善这块东西。我们团队维护的NFrame C&#43;&#43;版本，到了现在又开始用C#语言做一个，核心思想没变，只是单纯的换个语言，现在核心功能已经换完了，只花了两周多的时间，一个库都没依赖，只依赖了.Net Framework，杂七杂八架起来只有10M多，而C&#43;&#43;版本库解压后有近1G，从开发和维护成本上来说，都是C#更胜一筹。再加上现在MS本身已经开始支持跨平台了，或者mono，跨平台根本不是问题。
这个例子可以看出，新的语言C#确实提高了我们的开发效率，而C#的Task等等特性和内容，已经将我们再C&#43;&#43;上纠结的Actor模式完全替代了，让我们可以安心做功能设计，而不是纠结语言层面的实现问题。
而且新语言一般都是通杀的，web，UI，back-end等，基本都支持，C#，js，Java都是前后端通杀，适合大部分领域和行业。
//TODO
&amp;nbsp;
生活工作环境中是否允许你用新的语言？ 俗话说兴趣是最好的老师，当你对某个事物有了兴趣之后，自然就有学习的动力了。但是我们都不是一个人在战斗，多多少少都会有合作的同事、朋友，小到自己的简单开源项目，大到公司的大项目，所以工作生活中都是多个人在合作，做任何事情都不能一意孤行，自己喜欢某种编程语言就大用特用，毕竟团队整体的效率才是执行力，现在已经不是个人英雄主义的时代了，保持合作交流才能有更大的进步。团队做出来的东西才是外面比较看重的，技术不是决定性因素，而项目产品才是提升自己价值的东西，离开团队这个平台，一身是铁打几根钉子？面面俱到方能做到完美。
&amp;nbsp;
暂时想到的就是这么多了，大家可以继续补充讨论。
</content>
    </entry>
    
     <entry>
        <title>[转]单表60亿记录等大数据场景的MySQL优化和运维之道 | 高可用架构</title>
        <url>https://cppfans.org/2030.html</url>
        <categories>
          <category>大数据</category><category>技术文章</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  此文是根据杨尚刚在【QCON高可用架构群】中，针对MySQL在单表海量记录等场景下，业界广泛关注的MySQL问题的经验分享整理而成，转发请注明出处。
 杨尚刚，美图公司数据库高级DBA，负责美图后端数据存储平台建设和架构设计。前新浪高级数据库工程师，负责新浪微博核心数据库架构改造优化，以及数据库相关的服务器存储选型设计。
 前言 MySQL数据库大家应该都很熟悉，而且随着前几年的阿里的去IOE，MySQL逐渐引起更多人的重视。
MySQL历史  1979年，Monty Widenius写了最初的版本，96年发布1.0   1995-2000年，MySQL AB成立，引入BDB   2000年4月，集成MyISAM和replication   2001年，Heikki Tuuri向MySQL建议集成InnoDB   2003发布5.0，提供了视图、存储过程等功能   2008年，MySQL AB被Sun收购，09年推出5.1   2009年4月，Oracle收购Sun，2010年12月推出5.5   2013年2月推出5.6 GA，5.7开发中   MySQL的优点  使用简单   开源免费   扩展性“好”，在一定阶段扩展性好   社区活跃   性能可以满足互联网存储和性能需求，离不开硬件支持   上面这几个因素也是大多数公司选择考虑MySQL的原因。不过MySQL本身存在的问题和限制也很多，有些问题点也经常被其他数据库吐槽或鄙视
MySQL存在的问题  优化器对复杂SQL支持不好   对SQL标准支持不好   大规模集群方案不成熟，主要指中间件   ID生成器，全局自增ID   异步逻辑复制，数据安全性问题   Online DDL   HA方案不完善   备份和恢复方案还是比较复杂，需要依赖外部组件   展现给用户信息过少，排查问题困难   众多分支，让人难以选择   看到了刚才讲的MySQL的优势和劣势，可以看到MySQL面临的问题还是远大于它的优势的,很多问题也是我们实际需要在运维中优化解决的，这也是MySQL DBA的一方面价值所在。并且MySQL的不断发展也离不开社区支持，比如Google最早提交的半同步patch，后来也合并到官方主线。Facebook Twitter等也都开源了内部使用MySQL分支版本，包含了他们内部使用的patch和特性。
数据库开发规范 数据库开发规范定义：开发规范是针对内部开发的一系列建议或规则, 由DBA制定(如果有DBA的话)。
开发规范本身也包含几部分：基本命名和约束规范，字段设计规范，索引规范，使用规范。
规范存在意义  保证线上数据库schema规范   减少出问题概率   方便自动化管理   规范需要长期坚持，对开发和DBA是一个双赢的事情   想想没有开发规范，有的开发写出各种全表扫描的SQL语句或者各种奇葩SQL语句，我们之前就看过开发写的SQL 可以打印出好几页纸。这种造成业务本身不稳定，也会让DBA天天忙于各种救火。
基本命名和约束规范  表字符集选择UTF8 ，如果需要存储emoj表情，需要使用UTF8mb4(MySQL 5.5.3以后支持)   存储引擎使用InnoDB   变长字符串尽量使用varchar varbinary   不在数据库中存储图片、文件等   单表数据量控制在1亿以下   库名、表名、字段名不使用保留字   库名、表名、字段名、索引名使用小写字母，以下划线分割 ，需要见名知意   库表名不要设计过长，尽可能用最少的字符表达出表的用途   字段规范  所有字段均定义为NOT NULL ，除非你真的想存Null   字段类型在满足需求条件下越小越好，使用UNSIGNED存储非负整数 ，实际使用时候存储负数场景不多   使用TIMESTAMP存储时间   使用varchar存储变长字符串 ，当然要注意varchar(M)里的M指的是字符数不是字节数；使用UNSIGNED INT存储IPv4 地址而不是CHAR(15) ，这种方式只能存储IPv4，存储不了IPv6   使用DECIMAL存储精确浮点数，用float有的时候会有问题   少用blob text   关于为什么定义不使用Null的原因
 1.浪费存储空间，因为InnoDB需要有额外一个字节存储
 2.表内默认值Null过多会影响优化器选择执行计划
  关于使用datatime和timestamp，现在在5.6.4之后又有了变化，使用二者存储在存储空间上大差距越来越小 ，并且本身datatime存储范围就比timestamp大很多，timestamp只能存储到2038年
索引规范  单个索引字段数不超过5，单表索引数量不超过5，索引设计遵循B&#43; Tree索引最左前缀匹配原则   选择区分度高的列作为索引   建立的索引能覆盖80%主要的查询，不求全，解决问题的主要矛盾   DML和order by和group by字段要建立合适的索引   避免索引的隐式转换   避免冗余索引   关于索引规范，一定要记住索引这个东西是一把双刃剑，在加速读的同时也引入了很多额外的写入和锁，降低写入能力，这也是为什么要控制索引数原因。之前看到过不少人给表里每个字段都建了索引，其实对查询可能起不到什么作用。
冗余索引例子
 idx_abc(a,b,c)    idx_a(a) 冗余    idx_ab(a,b) 冗余   隐式转换例子
字段:remark varchar(50) NOT Null
MySQL&amp;gt;SELECT id, gift_code FROM gift WHERE deal_id = 640 AND remark=115127; 1 row in set (0.14 sec)
_MySQL&amp;gt;SELECT id, gift_code FROM poolgift WHEREdeal_id = 640 AND remark=‘115127’; 1 row in set (0.005 sec)
字段定义为varchar，但传入的值是个int，就会导致全表扫描，要求程序端要做好类型检查
SQL类规范  尽量不使用存储过程、触发器、函数等   避免使用大表的JOIN，MySQL优化器对join优化策略过于简单   避免在数据库中进行数学运算和其他大量计算任务   SQL合并，主要是指的DML时候多个value合并，减少和数据库交互   合理的分页，尤其大分页   UPDATE、DELETE语句不使用LIMIT ，容易造成主从不一致   数据库运维规范 运维规范主要内容  SQL审核，DDL审核和操作时间，尤其是OnlineDDL   高危操作检查，Drop前做好数据备份   权限控制和审计   日志分析，主要是指的MySQL慢日志和错误日志   高可用方案   数据备份方案   版本选择  MySQL社区版，用户群体最大   MySQL企业版，收费   Percona Server版，新特性多   MariaDB版，国内用户不多   建议选择优先级为：MySQL社区版 &amp;gt; Percona Server &amp;gt; MariaDB &amp;gt; MySQL 企业版
不过现在如果大家使用RDS服务，基本还以社区版为主
Online DDL问题 原生MySQL执行DDL时需要锁表，且锁表期间业务是无法写入数据的，对服务影响很大，MySQL对这方面的支持是比较差的。大表做DDL对DBA来说是很痛苦的，相信很多人经历过。如何做到Online DDL呢，是不是就无解了呢？当然不是！
上面表格里提到的 Facebook OSC和5.6 OSC也是目前两种比较靠谱的方案
MySQL 5.6的OSC方案还是解决不了DDL的时候到从库延时的问题，所以现在建议使用Facebook OSC这种思路更优雅
下图是Facebook OSC的思路
后来Percona公司根据Facebook OSC思路，用perl重写了一版，就是我们现在用得很多的pt-online-schema-change，软件本身非常成熟，支持目前主流版本。
使用pt-online-schema-change的优点有：
 1.无阻塞写入   2.完善的条件检测和延时负载策略控制   值得一提的是，腾讯互娱的DBA在内部分支上也实现了Online DDL，之前测试过确实不错，速度快，原理是通过修改InnoDB存储格式来实现。
使用pt-online-schema-change的限制有：
 改表时间会比较长(相比直接alter table改表)   修改的表需要有唯一键或主键   在同一端口上的并发修改不能太多   可用性 关于可用性，我们今天分享一种无缝切主库方案，可以用于日常切换，使用思路也比较简单
在正常条件下如何无缝去做主库切换，核心思路是让新主库和从库停在相同位置，主要依赖slave start until 语句，结合双主结构，考虑自增问题。
MySQL集群方案：
 集群方案主要是如何组织MySQL实例的方案   主流方案核心依然采用的是MySQL原生的复制方案   原生主从同步肯定存在着性能和安全性问题   MySQL半同步复制：
现在也有一些理论上可用性更高的其它方案
 Percona XtraDB Cluster(没有足够的把控力度，不建议上)   MySQL Cluster(有官方支持，不过实际用的不多)   红框内是目前大家使用比较多的部署结构和方案。当然异常层面的HA也有很多第三方工具支持，比如MHA、MMM等，推荐使用MHA
sharding拆分问题  Sharding is very complex, so itʼs best not to shard until itʼs obvious that you will actually need to!   sharding是按照一定规则数据重新分布的方式   主要解决单机写入压力过大和容量问题   主要有垂直拆分和水平拆分两种方式   拆分要适度，切勿过度拆分   有中间层控制拆分逻辑最好，否则拆分过细管理成本会很高   曾经管理的单表最大60亿＋，单表数据文件大小1TB＋，人有时候就要懒一些
上图是水平拆分和垂直拆分的示意图
数据库备份 首先要保证的，最核心的是数据库数据安全性。数据安全都保障不了的情况下谈其他的指标(如性能等)，其实意义就不大了。
备份的意义是什么呢?
 数据恢复！   数据恢复！   数据恢复！   目前备份方式的几个纬度：
 全量备份 VS 增量备份   热备 VS 冷备   物理备份 VS 逻辑备份   延时备份   全量binlog备份   建议方式：
 热备＋物理备份   核心业务：延时备份＋逻辑备份   全量binlog备份   借用一下某大型互联网公司做的备份系统数据：一年7000＋次扩容，一年12＋次数据恢复，日志量每天3TB，数据总量2PB，每天备份数据量百TB级，全年备份36万次，备份成功了99.9%。
主要做的几点：
 备份策略集中式调度管理   xtrabackup热备   备份结果统计分析   备份数据一致性校验   采用分布式文件系统存储备份   备份系统采用分布式文件系统原因：
 解决存储分配的问题   解决存储NFS备份效率低下问题   存储集中式管理   数据可靠性更好   使用分布式文件系统优化点：
 Pbzip压缩，降低多副本存储带来的存储成本，降低网络带宽消耗
 元数据节点HA，提高备份集群的可用性
 erasure code方案调研
  数据恢复方案 目前的MySQL数据恢复方案主要还是基于备份来恢复，可见备份的重要性。比如我今天下午15点删除了线上一张表，该如何恢复呢？首先确认删除语句，然后用备份扩容实例启动，假设备份时间点是凌晨3点，就还需要把凌晨3点到现在关于这个表的binlog导出来，然后应用到新扩容的实例上，确认好恢复的时间点，然后把删除表的数据导出来应用到线上。
性能优化 复制优化 MySQL复制：
 是MySQL应用得最普遍的应用技术，扩展成本低   逻辑复制   单线程问题，从库延时问题   可以做备份或读复制   问题很多，但是能解决基本问题
上图是MySQL复制原理图，红框内就是MySQL一直被人诟病的单线程问题
单线程问题也是MySQL主从延时的一个重要原因，单线程解决方案：
 官方5.6&#43;多线程方案   Tungsten为代表的第三方并行复制工具   sharding   上图是MySQL5.6 目前实现的并行复制原理图，是基于库级别的复制，所以如果你只有一个库，使用这个意义不大
当然MySQL也认识到5.6这种并行的瓶颈所在，所以在5.7引入了另外一种并行复制方式，基于logical timestamp的并行复制，并行复制不再受限于库的个数，效率会大大提升
上图是5.7的logical timestamp的复制原理图
刚才我也提到MySQL原来只支持异步复制，这种数据安全性是非常差的，所以后来引入了半同步复制，从5.5开始支持
上图是原生异步复制和半同步复制的区别。可以看到半同步通过从库返回ACK这种方式确认从库收到数据，数据安全性大大提高
在5.7之后，半同步也可以配置你指定多个从库参与半同步复制，之前版本都是默认一个从库
对于半同步复制效率问题有一个小的优化，就是使用5.6&#43;的mysqlbinlog以daemon方式作为从库，同步效率会好很多
关于更安全的复制，MySQL 5.7也是有方案的，方案名叫Group replication 官方多主方案，基于Corosync实现
主从延时问题 原因：一般都会做读写分离，其实从库压力反而比主库大／从库读写压力大非常容易导致延时。
解决方案：
 首先定位延时瓶颈   如果是IO压力，可以通过升级硬件解决，比如替换SSD等   如果IO和CPU都不是瓶颈，非常有可能是SQL单线程问题，解决方案可以考虑刚才提到的并行复制方案   如果还有问题，可以考虑sharding拆分方案   提到延时不得不提到很坑人的Seconds behind master，使用过MySQL的应该很熟悉
这个值的源码里算法
long time_diff= ((long)(time(0) – mi-&amp;gt;rli.last_master_timestamp) – mi-&amp;gt;clock_diff_with_master);
Seconds_behind_master来判断延时不可靠，在网络抖动或者一些特殊参数配置情况下，会造成这个值是0但其实延时很大了。通过heartbeat表插入时间戳这种机制判断延时是更靠谱的
复制注意点：
 Binlog格式，建议都采用row格式，数据一致性更好   Replication filter应用   主从数据一致性问题：
 row格式下的数据恢复问题   InnoDB优化 成熟开源事务存储引擎，支持ACID，支持事务四个隔离级别，更好的数据安全性，高性能高并发，MVCC，细粒度锁，支持O_DIRECT。
主要优化参数：
 innodbfileper_table =1   innodbbufferpool_size，根据数据量和内存合理设置   innodbflushlog_attrxcommit= 0 1 2   innodblogfile_size，可以设置大一些   innodbpagesize   Innodbflushmethod = o_direct   innodbundodirectory 放到高速设备(5.6＋)   innodbbufferpool_dump   atshutdown ，bufferpool dump (5.6&#43;)    &amp;lt;p&amp;gt; 上图是5.5 4G的redo log和5.6 设置大于4G redo log文件性能对比，可以看到稳定性更好了。innodb&amp;lt;em&amp;gt;log&amp;lt;/em&amp;gt;file_size设置还是很有意义的 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; InnoDB比较好的特性： &amp;lt;/p&amp;gt; &amp;lt;ul class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; Bufferpool预热和动态调整大小，动态调整大小需要5.7支持 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Page size自定义调整，适应目前硬件 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; InnoDB压缩，大大降低数据容量，一般可以压缩50%，节省存储空间和IO，用CPU换空间 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Transportable tablespaces，迁移ibd文件，用于快速单表恢复 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; Memcached API，full text，GIS等 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt; InnoDB在SSD上的优化： &amp;lt;/p&amp;gt; &amp;lt;ul class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 在5.5以上，提高innodb&amp;lt;em&amp;gt;write&amp;lt;/em&amp;gt;io&amp;lt;em&amp;gt;threads和innodb&amp;lt;em&amp;gt;read&amp;lt;/em&amp;gt;io&amp;lt;/em&amp;gt;threads &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; innodb&amp;lt;em&amp;gt;io&amp;lt;/em&amp;gt;capacity需要调大 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 日志文件和redo放到机械硬盘，undo放到SSD，建议这样，但必要性不大 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; atomic write,不需要Double Write Buffer &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; InnoDB压缩 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 单机多实例 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt; 也要搞清楚InnoDB哪些文件是顺序读写，哪些是随机读写 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 随机读写： &amp;lt;/p&amp;gt; &amp;lt;ul class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; datadir &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; innodb&amp;lt;em&amp;gt;data &amp;lt;/em&amp;gt;file_path &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; innodb&amp;lt;em&amp;gt;undo &amp;lt;/em&amp;gt;directory &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt; 顺序读写： &amp;lt;/p&amp;gt; &amp;lt;ul class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; innodb&amp;lt;em&amp;gt;log&amp;lt;/em&amp;gt;group&amp;lt;em&amp;gt;home&amp;lt;/em&amp;gt;dir &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; log-bin &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt; InnoDB VS MyISAM： &amp;lt;/p&amp;gt; &amp;lt;ul class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 数据安全性至关重要，InnoDB完胜，曾经遇到过一次90G的MyISAM表repair，花了两天时间，如果在线上几乎不可忍受 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 并发度高 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; MySQL 5.5默认引擎改为InnoDB，标志着MyISAM时代的落幕 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt; TokuDB： &amp;lt;/p&amp;gt; &amp;lt;ul class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 支持事务 ACID 特性，支持多版本控制(MVCC) &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 基于Fractal Tree Index，非常适合写入密集场景 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 高压缩比，原生支持Online DDL &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 主流分支都支持，收费转开源 。目前可以和InnoDB媲美的存储引擎 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt; 目前主流使用TokuDB主要是看中了它的高压缩比，Tokudb有三种压缩方式：quicklz、zlib、lzma，压缩比依次更高。现在很多使用zabbix的后端数据表都采用的TokuDB，写入性能好，压缩比高。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 下图是我之前做的测试对比和InnoDB &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;img src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8massLdVUY8H5FWE5Yia5icx4mq86GyfMyn3XxuUzXQSnQlZxZuiaxy4lmxg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;#34; alt=&amp;#34;&amp;#34; data-s=&amp;#34;300,640&amp;#34; data-type=&amp;#34;jpeg&amp;#34; data-src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8massLdVUY8H5FWE5Yia5icx4mq86GyfMyn3XxuUzXQSnQlZxZuiaxy4lmxg/0?wx_fmt=jpeg&amp;#34; data-ratio=&amp;#34;0.8680688336520076&amp;#34; data-w=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;img src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maSb32YJMJ71MibICicnwayvhhKroqhTSPRu4vm1sXexA07vLa0aW3Vdxg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;#34; alt=&amp;#34;&amp;#34; data-s=&amp;#34;300,640&amp;#34; data-type=&amp;#34;jpeg&amp;#34; data-src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maSb32YJMJ71MibICicnwayvhhKroqhTSPRu4vm1sXexA07vLa0aW3Vdxg/0?wx_fmt=jpeg&amp;#34; data-ratio=&amp;#34;0.5736137667304015&amp;#34; data-w=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 上图是sysbench测试的和InnoDB性能对比图，可以看到TokuDB在测试过程中写入稳定性是非常好的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; tokudb存在的问题： &amp;lt;/p&amp;gt; &amp;lt;ul class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 官方分支还没很好的支持 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 热备方案问题，目前只有企业版才有 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 还是有bug的，版本更新比较快，不建议在核心业务上用 &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt; 比如我们之前遇到过一个问题：TokuDB的内部状态显示上一次完成的checkpoint时间是“Jul 17 12:04:11 2014”，距离当时发现现在都快5个月了，结果堆积了大量redo log不能删除，后来只能重启实例，结果重启还花了七八个小时 &amp;lt;/p&amp;gt; &amp;lt;h3&amp;gt; MySQL优化相关的case &amp;lt;/h3&amp;gt; &amp;lt;p&amp;gt; Query cache，MySQL内置的查询加速缓存，理念是好的,但设计不够合理，有点out。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 锁的粒度非常大MySQL 5.6默认已经关闭 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; When the query cache helps, it can help a lot. When it hurts, it can hurt a lot.明显前半句已经没有太大用处，在高并发下非常容易遇到瓶颈。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 关于事务隔离级别 ，InnoDB默认隔离级别是可重复读级别，当然InnoDB虽然是设置的可重复读，但是也是解决了幻读的，建议改成读已提交级别，可以满足大多数场景需求，有利于更高的并发，修改transaction-isolation。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;img src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maqqcbVpUByadpsfIB0bE03UZMj7xkm1DOA9fG1fZLd8vdic0JrnynwsA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;#34; alt=&amp;#34;&amp;#34; data-s=&amp;#34;300,640&amp;#34; data-type=&amp;#34;jpeg&amp;#34; data-src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maqqcbVpUByadpsfIB0bE03UZMj7xkm1DOA9fG1fZLd8vdic0JrnynwsA/0?wx_fmt=jpeg&amp;#34; data-ratio=&amp;#34;0.32122370936902483&amp;#34; data-w=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;img src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maw86TIWliaKhZrQBDBvwyLTJicb8w3h8sHLMGLsJywcluYCF578DRxu4g/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;#34; alt=&amp;#34;&amp;#34; data-s=&amp;#34;300,640&amp;#34; data-type=&amp;#34;jpeg&amp;#34; data-src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maw86TIWliaKhZrQBDBvwyLTJicb8w3h8sHLMGLsJywcluYCF578DRxu4g/0?wx_fmt=jpeg&amp;#34; data-ratio=&amp;#34;1.2&amp;#34; data-w=&amp;#34;20&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 上图是一个比较经典的死锁case，有兴趣可以测试下 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;关于SSD&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 关于SSD，还是提一下吧。某知名大V说过“最近10年对数据库性能影响最大的是闪存”，稳定性和性能可靠性已经得到大规模验证，多块SATA SSD做Raid5，推荐使用。采用PCIe SSD，主流云平台都提供SSD云硬盘支持。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;最后说一下大家关注的单表60亿记录问题，表里数据也是线上比较核心的。&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 先说下当时情况，表结构比较简单，都是bigint这种整型，索引比较多，应该有2-3个，单表行数60亿＋，单表容量1.2TB左右，当然内部肯定是有碎片的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 形成原因：历史遗留问题，按照我们前面讲的开发规范，这个应该早拆分了，当然不拆有几个原因： &amp;lt;/p&amp;gt; &amp;lt;ol class=&amp;#34; list-paddingleft-2&amp;#34;&amp;gt; &amp;lt;li&amp;gt; 性能未遇到瓶颈 ，主要原因 &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; DBA比较“懒“ &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; 想看看InnoDB的极限，挑战一下。不过风险也是很大的，想想如果在一个1.2TB表上加个字段加个索引，那感觉绝对酸爽。还有就是单表恢复的问题，恢复时间不可控。 &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;p&amp;gt; 我们后续做的优化 ，采用了刚才提到的TokuDB，单表容量在InnoDB下1TB&#43;，使用Tokudb的lzma压缩到80GB，压缩效果非常好。这样也解决了单表过大恢复时间问题，也支持online DDL，基本达到我们预期。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 今天讲的主要针对MySQL本身优化和规范性质的东西，还有一些比较好的运维经验，希望大家能有所收获。今天这些内容是为后续数据库做平台化的基础。我今天分享就到这里，谢谢大家。 &amp;lt;/p&amp;gt; &amp;lt;h2&amp;gt; QA &amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q1：use schema;select * from table; 和select * from schema.table;两种写法有什么不一样吗？会对主从同步有影响吗？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 对于主从复制来说执行效率上差别不大，不过在使用replication filter时候这种情况需要小心，应该要使用Replicate&amp;lt;em&amp;gt;Wild&amp;lt;/em&amp;gt;Ignore&amp;lt;em&amp;gt;Table这种参数，如果不使用带wild&amp;lt;/em&amp;gt;ignore，第一种方式会有问题，过滤不起作用。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q2：对于用于MySQL的ssd，测试方式和ssd的参数配置方面，有没有好的建议？主要针对ssd的配置哈&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 关于SATA SSD配置参数，建议使用Raid5，想更保险使用Raid50，更土豪使用Raid 10 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;img src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maY2k8Cz8zibA33XQJy9R8976wRYxToKlbhzuLDawM0E9kVBAiarWSAcBg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;#34; alt=&amp;#34;&amp;#34; data-s=&amp;#34;300,640&amp;#34; data-type=&amp;#34;jpeg&amp;#34; data-src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOODltJiaib4ia4ydzokHzwW8maY2k8Cz8zibA33XQJy9R8976wRYxToKlbhzuLDawM0E9kVBAiarWSAcBg/0?wx_fmt=jpeg&amp;#34; data-ratio=&amp;#34;0.24665391969407266&amp;#34; data-w=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 上图是主要的参数优化，性能提升最大的是第一个修改调度算法的 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q3：数据库规范已制定好，如何保证开发人员必须按照规范来开发？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 关于数据库规范实施问题，也是有两个方面吧，第一、定期给开发培训开发规范，让开发能更了解。第二、还是在流程上规范，比如把我们日常通用的建表和字段策略固化到程序，做成自动化审核系统。这两方面结合 效果会比较好。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q4：如何最大限度提高innodb的命中率？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 这个问题前提是你的数据要有热点，读写热点要有交集，否则命中率很难提高。在有热点的前提下，也要求你的你的内存要足够大，能够存更多的热点数据。尽量不要做一些可能污染bufferpool的操作，比如全表扫描这种。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q5：主从复制的情况下，如果有CAS这样的需求，是不是只能强制连主库？因为有延迟的存在，如果读写不在一起的话，会有脏数据。&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 如果有CAS需求，确实还是直接读主库好一些，因为异步复制还是会有延迟的。只要SQL优化的比较好，读写都在主库也是没什么问题的。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q6：关于开发规范，是否有必要买国标?&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 这个国标是什么东西，不太了解。不过从字面看，国标应该也是偏学术方面的，在具体工程实施时候未必能用好。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q7：主从集群能不能再细化一点那？不知道这样问合适不？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 看具体哪方面吧。主从集群每个小集群一般都是采用一主多从方式，每个小集群对应特定的一组业务。然后监控备份和HA都是在每个小集群实现。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q8：如何跟踪数据库table某个字段值发生变化？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 追踪字段值变化可以通过分析row格式binlog好一些。比如以前同事就是通过自己开发的工具来解析row格式binlog，跟踪数据行变化。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q9：对超大表水平拆分，在使用MySQL中间件方面有什么建议和经验分享？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 对于超大表水平拆分，在中间件上经验不是很多，早期人肉搞过几次。也使用过自己研发的数据库中间件，不过线上应用的规模不大。关于目前众多的开源中间件里，360的atlas是目前还不错的，他们公司内部应用的比较多。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q10：我们用的MySQL proxy做读负载，但是少量数据压力下并没有负载，请问有这回事吗？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 少量数据压力下，并没有负载 ，这个没测试过，不好评价 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q11：对于binlog格式，为什么只推荐row，而不用网上大部分文章推荐的Mix ？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 这个主要是考虑数据复制的可靠性，row更好。mixed含义是指如果有一些容易导致主从不一致的SQL ，比如包含UUID函数的这种，转换为row。既然要革命，就搞的彻底一些。这种mix的中间状态最坑人了。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q12： 读写分离，一般是在程序里做，还是用proxy ，用proxy的话一般用哪个？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 这个还是独立写程序好一些，与程序解耦方便后期维护。proxy国内目前开源的比较多，选择也要慎重。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q13： 我想问一下关于mysql线程池相关的问题，什么情况下适合使用线程池，相关的参数应该如何配置，老师有这方面的最佳实践没有？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 线程池这个我也没测试过。从原理上来说，短链接更适合用线程池方式，减少建立连接的消耗。这个方面的最佳配置，我还没测试过，后面测试有进展可以再聊聊。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q14： 误删数据这种，数据恢复流程是怎么样的(从库也被同步删除的情况)？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 看你删除数据的情况，如果只是一张表，单表在几GB或几十GB。如果能有延时备份，对于数据恢复速度是很有好处的。恢复流程可以参考我刚才分享的部分。目前的MySQL数据恢复方案主要还是基于备份来恢复 ，可见备份的重要性。比如我今天下午15点删除了线上一张表，该如何恢复呢。首先确认删除语句，然后用备份扩容实例启动，假设备份时间点是凌晨3点。就还需要把凌晨3点到现在关于这个表的binlog导出来，然后应用到新扩容的实例上。确认好恢复的时间点，然后把删除表的数据导出来应用到线上。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;Q15： 关于备份，binlog备份自然不用说了，物理备份有很多方式，有没有推荐的一种，逻辑备份在量大的时候恢复速度比较慢，一般用在什么场景？&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; 物理备份采用xtrabackup热备方案比较好。逻辑备份一般用在单表恢复效果会非常好。比如你删了一个2G表，但你总数据量2T，用物理备份就会要慢了，逻辑备份就非常有用了。 &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;想和群内专家继续交流MySQL相关技术，请关注公众号后，回复arch，申请进群。&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;strong&amp;gt;本文策划 庆丰@微博, 内容由王杰编辑，刘伟@途牛、陈刚@北京智识 校对与发布，其他多位志愿者对本文亦有贡献。读者可以通过搜索“ArchNotes”或长按下面图片，关注“高可用架构”公众号，查看更多架构方面内容，获取通往架构师之路的宝贵经验。转载请注明来自“高可用架构（ArchNotes）”公众号，敬请包含二维码！&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p&amp;gt; &amp;lt;img src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPoaibhicCyMkia552rIu4wAtUThl4HiaABoLpmOkKMHVKHnprghrbTXQia0zgJuNmlU5icoKflhYdhtqPQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;#34; alt=&amp;#34;&amp;#34; data-src=&amp;#34;http://mmbiz.qpic.cn/mmbiz/8XkvNnTiapOPoaibhicCyMkia552rIu4wAtUThl4HiaABoLpmOkKMHVKHnprghrbTXQia0zgJuNmlU5icoKflhYdhtqPQ/0?wx_fmt=jpeg&amp;#34; data-ratio=&amp;#34;1&amp;#34; data-w=&amp;#34;430&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt;</content>
    </entry>
    
     <entry>
        <title>Docker初窥</title>
        <url>https://cppfans.org/2020.html</url>
        <categories>
          <category>技术文章</category><category>虚拟化</category>
        </categories>
        <tags>
          <tag>docker</tag><tag>服务器</tag><tag>虚拟化</tag>
        </tags>
        <content type="html"> 提前多说一句：后续的文章不会是直接发一整篇文章出来，而是有点顺手笔记的意思，想到哪儿写到哪儿，可能会写不完一片，会用TODO来标识出来，也有可能会跳过某一段直接写后面，写完后可能还会重新在整理，大家请知晓。
说到Docker这个东西，还是一个做IDC的朋友跟我提起来的，说他想做云主机，但是现在的技术完全买青云的，老的虚拟主机的路子想改造，且不知道从何下手，kangle那边的服务器也不打算开发了，在开发docker产品。因为之前docker的大热让我也稍微了解了下docker，这次正好趁着机会，再深入了解下。
什么是Docker？
// TODO
</content>
    </entry>
    
     <entry>
        <title>记录《QMWS》服务器性能优化过程</title>
        <url>https://cppfans.org/2018.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>优化</tag><tag>性能</tag><tag>服务器</tag>
        </tags>
        <content type="html"> 性能优化(图片来自网络)  本文是为了记录下《QMWS》项目服务器在对外测试期间，性能表现和技术审核时的性能表现差距很大，从而做出的一些优化过程，期间还是比较头疼，接近两个连续通宵来修改。第一个通宵一直在查找问题和猜问题，找问题是如何出现的，第二天主要是解决对应的性能问题。
性能问题主要集中在：
内存使用过快
内存泄露
某些时间内协议过多
逻辑功能处理不当
其他网络消耗什么的暂时也没有考虑，下面详细说说这几个问题是如何引起的以及如何一步步解决的。
1.内存使用过快问题
我们项目使用的是C&#43;&#43;后端，用了团队主程之前写的，后来我参与开发的一个开源的服务器数据管理框架NFrame，下面是github地址。
GitHub 仓库挂件 WordPress 插件
 ketoo
 / 
NoahGameFrame
  A fast, scalable, distributed game server engine/framework for C&#43;&#43;, include actor library, network library,can be used as a real time multiplayer game engine ( MMO RPG/MOBA ), which support C#/Lua script/ Unity3d, Cocos2dx and plan to support Unreal. https://github.com/ketoo/NoahGameFrame/wiki   2,129690
Download ZIP
  这个框架就不多做介绍了，有兴趣可以从github pull下来研究研究，或者加群讨论。
这个框架的主要问题就是小的变量和内存申请太多了，导致产生了很多碎片，在linux系统上回收不够及时导致的，而且我们错误的估计了shared_ptr的能力了，智能指针确实能减少很多内存管理，但是生命周期却不好把握，所以我们临时用了大google的TCMalloc，每5分钟主动回收一次内存，确实解决了我们的问题。
2.内存泄漏
内存泄漏这块主要的问题还是代码上的漏洞，逻辑不够严谨，释放对象的时候因为一些判断导致对象没有被释放。还有就是一些数据管理上的问题，不是特别严重。
3.某些操作下逻辑处理过多
因为NFrame采用的是事件回调的方式来处理数据变动，我们会在自己感兴趣的属性(Property)和表(Record)数据上注册回调函数，从而做一些逻辑。这个时候就得特别注意逻辑需求了，因为某些时候属性会有多次变化，导致多次计算其他属性，我们遇到的问题就是当属性变化时计算多个武将的战斗力，如果某个操作导致了多个属性变化，就会导致成倍的战斗力计算，加重了逻辑负担。修改方式是去掉部分回调，在逻辑操作中特定的时候处理回调做的事情，从而降低调用次数。
4.逻辑功能处理不当
这个就是一些常见的问题了，经过重构整理以及性能测试就可以很好的看出来问题，就不多说了。
&amp;nbsp;
推荐的一些工具：
VLD C&#43;&#43;内存泄漏检查工具
VTune C&#43;&#43;性能内存检查工具，完美和VS IDE结合，非常好用
Valgrind linux下内存检查工具，缺点是没有IDE环境，报告不太容易看，不过分析还是蛮准确的
Border check(DevPartner) 自动化测试/覆盖性测试工具，大borland_(估计很多人都没听过了)_出品，业界一流产品
&amp;nbsp;
好的结果是问题基本已经排查到了，所以后续的版本测试基本没有特别大的性能问题，不过还是得争取高的压测结果。
PS:线上环境和本地测试还是有很大差距，前些天看到一个测试方法，觉得很有意思，与大家分享下。是通过线上开一台功能服务器A，然后再开一台同样的功能服务器B，A和B做的事情完全相同，A是对外服务，B是内部测试服务器，A多做一件事情，将收到的消息顺便转发到B，B再按照收到的协议做处理，这样通过观察B的数据和性能就能模拟线上环境，从而更容易发现问题处理问题，这个东西github上也有对应的项目，叫TCP Copy，有兴趣的朋友可以看看。
</content>
    </entry>
    
     <entry>
        <title>最近我在做什么？</title>
        <url>https://cppfans.org/1997.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>近况</tag>
        </tags>
        <content type="html"> 已经很久没有更新过博客了，主要原因还是因为老样子——事情太多了，每天都在瞎忙活。之前几个月一直都在忙结婚的事情，拍婚纱照什么的事情还是比较多，不过好的结局是在九月初在老家接了婚，完成人生一件非常重要的事情。
最近博客不更新主要的原因是：真的不知道写什么，写C&#43;&#43;技术吧，写什么内容才能脱颖而出，毕竟网上文章一大把一大把的，写好了最多是持平，写差了就不好办了，脸面是小，误人子弟是大，所以一直在琢磨搞点什么呢？最近接触的东西都很杂，简单看了集中其他编程语言，发现都很优秀，C&#43;&#43;还是太老了，发展也有点慢，导致我现在都想换域名了。
后面会写一篇关于为什么要换语言的文章，简单写写，没有褒贬任何语言的意思。后续的博文不会再关注语言了，得弄点高达上的东西了，语言的格局还是有点小。主要会集中在架构、分布式等稍微抽象点的东西，单纯的技术展示还不如在思想上有进步呢。
大概说下后面会分享的文章：服务器架构设计，分布式数据库设计，分布式思想、actor，其他语言。
C&#43;&#43;并不是说直接就不用了或者放在箱底儿了，大多数时间还是C&#43;&#43;，不过是不会再纠结语言或者类库的层面了，该是时候进一步了。
大家共勉，欢迎多沟通。
</content>
    </entry>
    
     <entry>
        <title>[转]七个对我最重要的职业建议（译文）</title>
        <url>https://cppfans.org/1995.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>职场</tag><tag>进阶</tag>
        </tags>
        <content type="html"> 作者： 阮一峰  日期： 2015年9月18日   Nicholas C. Zakas 是全世界最著名的 JavaScript 程序员之一。  两年前，他写了一篇长文，回顾自己的职业生涯，提到七个对他来说最重要的建议。   我读完很受启发，决定做一点摘录。你可以先读下面的精简版，再去读全文。  ===============================  七个对我最好的职业建议（精简版）   作者：Nicholas C. Zakas  译者：阮一峰  原文网址：https://www.nczonline.net/blog/2013/10/15/the-best-career-advice-ive-received/  一、不要别人点什么，就做什么   我的第一份工作，只干了8个月，那家公司就倒闭了。我问经理，接下来我该怎么办，他说：   &#34;小伙子，千万不要当一个被人点菜的厨师，别人点什么，你就烧什么。不要接受那样一份工作，别人下命令你该干什么，以及怎么干。你要去一个地方，那里的人肯定你对产品的想法，相信你的能力，放手让你去做。&#34;   我从此明白，单单实现一个产品是不够的，你还必须参与决定怎么实现。好的工程师并不仅仅服从命令，而且还给出反馈，帮助产品的拥有者改进它。  二、推销自己   我进入雅虎公司以后，经理有一天跟我谈话，他觉得我还做得不够。   &#34;你工作得很好，代码看上去不错，很少出Bug。但是，问题是别人都没看到这一点。为了让其他人相信你，你必须首先让别人知道你做了什么。你需要推销自己，引起别人的注意。&#34;   我这才意识到，即使做出了很好的工作，别人都不知道，也没用。做一个角落里静静编码的工程师，并不可取。你的主管会支持你，但是他没法替你宣传。公司的其他人需要明白你的价值，最好的办法就是告诉别人你做了什么。一封简单的Email：&#34;嗨，我完成了XXX，欢迎将你的想法告诉我&#34;，就很管用。  三、学会带领团队   工作几年后，已经没人怀疑我的技术能力了，大家知道我能写出高质量的可靠代码。有一次，我问主管，怎么才能得到提升，他说：   &#34;当你的技术能力过关以后，就要考验你与他人相处的能力了。&#34;   于是，我看到了，自己缺乏的是领导能力，如何带领一个团队，有效地与其他人协同工作，取到更大的成果。  四、生活才是最重要的   有一段时间，我在雅虎公司很有挫折感，对公司的一些做法不认同，经常会对别人发火。我问一个同事，他怎么能对这种事情保持平静，他回答：   &#34;你要想通，这一切并不重要。有人提交了烂代码，网站下线了，又怎么样？工作并不是你的整个生活。它们不是真正的问题，只是工作上的问题。真正重要的事情都发生在工作以外。我回到家，家里人正在等我，这才重要啊。&#34;   从此，我就把工作和生活分开了，只把它当作&#34;工作问题&#34;看待。这样一来，我对工作就总能心平气和，与人交流也更顺利了。  五、自己找到道路   我被提升为主管以后，不知道该怎么做。我请教了上级，他回答：   &#34;以前都是我们告诉你做什么，从现在开始，你必须自己回答这个问题了，我期待你来告诉我，什么事情需要做。&#34;   很多工程师都没有完成这个转变，如果能够做到，可能就说明你成熟了，学会了取舍。你不可能把时间花在所有事情上面，必须找到一个重点。  六、把自己当成主人   我每天要开很多会，有些会议我根本无话可说。我对一个朋友说，我不知道自己为什么要参加这个会，也没有什么可以贡献，他说：   &#34;不要再去开这样的会了。你参加一个会，那是因为你参与了某件事。如果不确定自己为什么要在场，就停下来问。如果这件事不需要你，就离开。不要从头到尾都静静地参加一个会，要把自己当成负责人，大家会相信你的。&#34;   从那时起，我从没有一声不发地参加会议。我确保只参加那些需要我参加的会议。  七、找到水平更高的人   最后，让我从自己的经历出发，给我的读者一个建议。   &#34;找到那些比你水平更高、更聪明的人，尽量和他们在一起，吃饭或者喝咖啡，向他们讨教，了解他们拥有的知识。你的职业，甚至你的生活，都会因此变得更好。&#34;   （完）  原文出处：阮一峰的网络日志
</content>
    </entry>
    
     <entry>
        <title>[转]做技术的你，如果别人找你创业，该怎么办?</title>
        <url>https://cppfans.org/1993.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>创业</tag><tag>选择</tag>
        </tags>
        <content type="html"> 这个文章总结的简直不能再赞了，所有点基本都说到了。
转载自：http://blog.eood.cn/business-plan
由于技术背景的原因，每结交认识一位新朋友，无论是之前在国内还是先在在英国，都会跟我说：我有一个 business idea 你花时间帮我做出来，过几年我们都会成为亿万富翁。每当这时，我都笑笑，也不知道该如何回应。一般我会说我考虑一下，做一些市场调研。
直到发现这个商业计划书模板。这下好了，我可以说先给你个 BP 模板，你再仔细考虑一下。其实这不是在敷衍，假如真是不错的 BP ，会容易找到合作伙伴，也容易找到投资人。假如你也有一个 idea ，但是还处于想法阶段，这个商业计划书模板能够帮你理清思路。
这个一页 BP 模板简单实用，分几个部分：
1. 问题 (Problem) 项目解决什么问题？满足什么需求？
2. 一句话介绍 (Elevator pitch) 用一句话概括问题、受众、解决方案、创新点。
3. 解决方案 (Solution) 如何解决问题，给受众带来哪些价值。
4. 目标用户 (Audience) 用户是哪个人群？哪些人时重要用户？他们如何评价产品或者服务质量？
5. 渠道 (Channels) 如何接触目标用户？他们常常出现在哪里？他们如何找到你的产品？
6. 关键指标 (Key metrics) 如何测量决定某个用户有这个问题需要你的产品？
7. 创新点 (Differentiator) 你的解决方案的不同点和创新之处在哪？
8. 收入模式(Revenue) 你卖什么？卖多少钱？
9. 成本(Cost) 运营需要的成本和活动有哪些？除了你自身外还需要哪些资源？
10. 商业优势(Business Boosters) 你有哪些别人不具备的优势？比如社会关系、行业经验、特殊渠道。你的 idea 如何不被其他人复制？
11. 个人适合度 (Personal Fit) 这个商业模式适合你吗？你是否之后会失去兴趣？
自己想清楚如何回答这些问题，并且能够说服自己的话，估计就会是个比较靠谱的 Business Plan了。另外，idea 其实并不是最重要，重要的是日复一日的精细执行。
</content>
    </entry>
    
     <entry>
        <title>boost::flat_map性能测试</title>
        <url>https://cppfans.org/1948.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>boost</tag><tag>flat_map</tag><tag>性能</tag>
        </tags>
        <content type="html">  文章转自：boost::flat_map and its performance compared to map and unordered_map
have run a benchmark on different data structures very recently at my company so I feel I need to drop a word. It is very complicated to benchmark something correctly.
Benchmarking On the web we rarely find (if ever) a well engineered benchmark. Until today I only found benchmarks that were done the journalist way (pretty quickly and sweeping dozens of variables under the carpet).
1) You need to consider about cache warming
Most people running benchmarks are afraid of timer discrepancy, therefore they run their stuff thousands of times and take the whole time, they just are careful to take the same thousand of times for every operation, and then consider that comparable.
The truth is, in real world it makes little sense, because your cache will not be warm, and your operation will likely be called just once. Therefore you need to benchmark using RDTSC, and time stuff calling them once only. Intel has made a paper describing how to use RDTSC (using a cpuid instruction to flush the pipeline, and calling it at least 3 times at the beginning of the program to stabilize it).
2) rdtsc accuracy measure
I also recommend doing this:
&amp;lt;span class=&#34;pln&#34;u64 g_correctionFactor&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span &amp;lt;span class=&#34;com&#34;// number of clocks to offset after each measurment to remove the overhead of the measurer itself.&amp;lt;/span&amp;lt;span class=&#34;pln&#34; u64 g_accuracy&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;static&amp;lt;/span&amp;lt;span class=&#34;pln&#34; u64 &amp;lt;/span&amp;lt;span class=&#34;kwd&#34;const&amp;lt;/span&amp;lt;span class=&#34;pln&#34; errormeasure &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span &amp;lt;span class=&#34;pun&#34;~((&amp;lt;/span&amp;lt;span class=&#34;pln&#34;u64&amp;lt;/span&amp;lt;span class=&#34;pun&#34;)&amp;lt;/span&amp;lt;span class=&#34;lit&#34;0&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span &amp;lt;span class=&#34;com&#34;#ifdef&amp;lt;/span&amp;lt;span class=&#34;pln&#34; _MSC_VER &amp;lt;/span&amp;lt;span class=&#34;com&#34;#pragma&amp;lt;/span&amp;lt;span class=&#34;pln&#34; intrinsic&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;pln&#34;__rdtsc&amp;lt;/span&amp;lt;span class=&#34;pun&#34;)&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;inline&amp;lt;/span&amp;lt;span class=&#34;pln&#34; u64 &amp;lt;/span&amp;lt;span class=&#34;typ&#34;GetRDTSC&amp;lt;/span&amp;lt;span class=&#34;pun&#34;()&amp;lt;/span &amp;lt;span class=&#34;pun&#34;{&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;int&amp;lt;/span&amp;lt;span class=&#34;pln&#34; a&amp;lt;/span&amp;lt;span class=&#34;pun&#34;[&amp;lt;/span&amp;lt;span class=&#34;lit&#34;4&amp;lt;/span&amp;lt;span class=&#34;pun&#34;];&amp;lt;/span&amp;lt;span class=&#34;pln&#34; __cpuid&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;pln&#34;a&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span &amp;lt;span class=&#34;lit&#34;0x80000000&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span &amp;lt;span class=&#34;com&#34;// flush OOO instruction pipeline&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;return&amp;lt;/span&amp;lt;span class=&#34;pln&#34; __rdtsc&amp;lt;/span&amp;lt;span class=&#34;pun&#34;();&amp;lt;/span &amp;lt;span class=&#34;pun&#34;}&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;inline&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;void&amp;lt;/span &amp;lt;span class=&#34;typ&#34;WarmupRDTSC&amp;lt;/span&amp;lt;span class=&#34;pun&#34;()&amp;lt;/span &amp;lt;span class=&#34;pun&#34;{&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;int&amp;lt;/span&amp;lt;span class=&#34;pln&#34; a&amp;lt;/span&amp;lt;span class=&#34;pun&#34;[&amp;lt;/span&amp;lt;span class=&#34;lit&#34;4&amp;lt;/span&amp;lt;span class=&#34;pun&#34;];&amp;lt;/span&amp;lt;span class=&#34;pln&#34; __cpuid&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;pln&#34;a&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span &amp;lt;span class=&#34;lit&#34;0x80000000&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span &amp;lt;span class=&#34;com&#34;// warmup cpuid.&amp;lt;/span&amp;lt;span class=&#34;pln&#34; __cpuid&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;pln&#34;a&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span &amp;lt;span class=&#34;lit&#34;0x80000000&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span&amp;lt;span class=&#34;pln&#34; __cpuid&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;pln&#34;a&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span &amp;lt;span class=&#34;lit&#34;0x80000000&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span &amp;lt;span class=&#34;com&#34;// measure the measurer overhead with the measurer (crazy he..)&amp;lt;/span&amp;lt;span class=&#34;pln&#34; u64 minDiff &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;pln&#34; LLONG_MAX&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span&amp;lt;span class=&#34;pln&#34; u64 maxDiff &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span &amp;lt;span class=&#34;lit&#34;0&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span &amp;lt;span class=&#34;com&#34;// this is going to help calculate our PRECISION ERROR MARGIN&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;for&amp;lt;/span &amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;kwd&#34;int&amp;lt;/span&amp;lt;span class=&#34;pln&#34; i &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span &amp;lt;span class=&#34;lit&#34;0&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span&amp;lt;span class=&#34;pln&#34; i &amp;lt;/span&amp;lt;span class=&#34;pun&#34;&amp;lt;&amp;lt;/span &amp;lt;span class=&#34;lit&#34;80&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span &amp;lt;span class=&#34;pun&#34;&#43;&#43;&amp;lt;/span&amp;lt;span class=&#34;pln&#34;i&amp;lt;/span&amp;lt;span class=&#34;pun&#34;)&amp;lt;/span &amp;lt;span class=&#34;pun&#34;{&amp;lt;/span&amp;lt;span class=&#34;pln&#34; u64 tick1 &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span &amp;lt;span class=&#34;typ&#34;GetRDTSC&amp;lt;/span&amp;lt;span class=&#34;pun&#34;();&amp;lt;/span&amp;lt;span class=&#34;pln&#34; u64 tick2 &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span &amp;lt;span class=&#34;typ&#34;GetRDTSC&amp;lt;/span&amp;lt;span class=&#34;pun&#34;();&amp;lt;/span&amp;lt;span class=&#34;pln&#34; minDiff &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span &amp;lt;span class=&#34;typ&#34;Aska&amp;lt;/span&amp;lt;span class=&#34;pun&#34;::&amp;lt;/span&amp;lt;span class=&#34;typ&#34;Min&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;pln&#34;minDiff&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span&amp;lt;span class=&#34;pln&#34; tick2 &amp;lt;/span&amp;lt;span class=&#34;pun&#34;-&amp;lt;/span&amp;lt;span class=&#34;pln&#34; tick1&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span &amp;lt;span class=&#34;com&#34;// make many takes, take the smallest that ever come.&amp;lt;/span&amp;lt;span class=&#34;pln&#34; maxDiff &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span &amp;lt;span class=&#34;typ&#34;Aska&amp;lt;/span&amp;lt;span class=&#34;pun&#34;::&amp;lt;/span&amp;lt;span class=&#34;typ&#34;Max&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;pln&#34;maxDiff&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span&amp;lt;span class=&#34;pln&#34; tick2 &amp;lt;/span&amp;lt;span class=&#34;pun&#34;-&amp;lt;/span&amp;lt;span class=&#34;pln&#34; tick1&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span &amp;lt;span class=&#34;pun&#34;}&amp;lt;/span&amp;lt;span class=&#34;pln&#34; g_correctionFactor &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;pln&#34; minDiff&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span&amp;lt;span class=&#34;pln&#34; printf&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;str&#34;&#34;Correction factor %llu clocks\n&#34;&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span&amp;lt;span class=&#34;pln&#34; g_correctionFactor&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span&amp;lt;span class=&#34;pln&#34; g_accuracy &amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;pln&#34; maxDiff &amp;lt;/span&amp;lt;span class=&#34;pun&#34;-&amp;lt;/span&amp;lt;span class=&#34;pln&#34; minDiff&amp;lt;/span&amp;lt;span class=&#34;pun&#34;;&amp;lt;/span&amp;lt;span class=&#34;pln&#34; printf&amp;lt;/span&amp;lt;span class=&#34;pun&#34;(&amp;lt;/span&amp;lt;span class=&#34;str&#34;&#34;Measurement Accuracy (in clocks) : %llu\n&#34;&amp;lt;/span&amp;lt;span class=&#34;pun&#34;,&amp;lt;/span&amp;lt;span class=&#34;pln&#34; g_accuracy&amp;lt;/span&amp;lt;span class=&#34;pun&#34;);&amp;lt;/span &amp;lt;span class=&#34;pun&#34;}&amp;lt;/span &amp;lt;span class=&#34;com&#34;#endif&amp;lt;/span This is a discrepancy measurer, and it will take the minimum of all measured values, to avoid to get a -10**18 (64 bits first negatives values) from time to time.
Notice the use of intrinsics and not inline assembly. First inline assembly is rarely supported by compilers nowadays, but much worse of all, the compiler creates a full ordering barrier around inline assembly because it cannot static analyze the inside, so this is a problem to benchmark real world stuff, especially when calling stuff just once. So an intrinsic is suited here, because it doesn&amp;rsquo;t break the compiler free-re-ordering of instructions.
3) parameters
The last problem is people usually test for too few variations of the scenario. A container performance is affected by:
 Allocator size of contained type cost of implementation of copy operation, assignment operation, move operation, construction operation, of the contained type. number of elements in the container (size of the problem) type has trivial 3.-operations type is POD  Point 1 is important because containers do allocate from time to time, and it matters a lot if they allocate using the CRT &amp;ldquo;new&amp;rdquo; or some user defined operation, like pool allocation or freelist or other&amp;hellip;
Point 2 is because some containers (say A) will loose time copying stuff around, and the bigger the type the bigger the overhead. The problem is that when comparing to another container B, A may win over B for small types, and loose for larger types.
Point 3 is the same than point 2, except it multiplies the the cost by some weighting factor.
Point 4 is a question of big O mixed with cache issues. Some bad complexities containers can largely outperform low complexity containers for small number of types (like map vs. vector, because their cache locality is good, but map fragments the memory). And then at some crossing point, they will lose, because the contained overall size starts to &amp;ldquo;leak&amp;rdquo; to main memory and cause cache misses, that plus the fact that the asymptoptic complexity can start to be felt.
Point 5 is about compilers being able to ellude stuff that are empty or trivial at compile time. This can optimize greatly some operations, because the containers are template, therefore each type will have its own performance profile.
Point 6 same as point 5, PODS can benefit from the fact that copy construction is just a memcpy, and some containers can have a specific implementation for these cases, using partial template specializations, or SFINAE to select algorithms according to traits of T.
About the flat map Apparently the flat map is a sorted vector wrapper, like Loki AssocVector, but with some supplementary modernizations coming with C&#43;&#43;11, exploiting move semantics to accelerate insert and delete of single elements.
This is still an ordered container. Most people usually don&amp;rsquo;t need to ordering part, therefore the existence of unordered...
Have you considered that maybe you need a flat_unorderedmap ? which would be something like google::sparse_map or something like that. An open address hash map.
The problem of open address hash maps, is that at the time of rehash they have to copy all around to the new extended flat land. When a standard unordered map just have to recreate the hash index, but the allocated data stays where it is. The disadvantage of course is that the memory is fragmented like hell.
The criterion of a rehash in an open address hash map is when the capacity overpasses the size of the bucket vector multiplied by the load factor.
A typical load factor is 0.8 therefore, you need to care about that, if you can pre-size your hash map before filling it, always presize to: intended_filling * (1/0.8) &#43; epsilon this will give you a guarantee of never having to spuriously rehash and recopy everything during filling.
The advantage of closed address maps (std::unordered..) is that you don&amp;rsquo;t have to care about those parameters.
But the boost flat_map is an ordered vector therefore it will always have a log(N) asymptoptic complexity, which is less good than the open address hash map (amortized constant time). You should consider that as well.
Benchmark results This is a test involving different maps (with int key and __int64/somestruct as value) and std::vector.
tested types information:
&amp;lt;span class=&#34;kwd&#34;typeid&amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;pln&#34;__int64 &amp;lt;/span&amp;lt;span class=&#34;pun&#34;.&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;sizeof&amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;lit&#34;8&amp;lt;/span &amp;lt;span class=&#34;pun&#34;.&amp;lt;/span&amp;lt;span class=&#34;pln&#34; ispod&amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;pln&#34;yes &amp;lt;/span&amp;lt;span class=&#34;kwd&#34;typeid&amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;kwd&#34;struct&amp;lt;/span &amp;lt;span class=&#34;typ&#34;MediumTypePod&amp;lt;/span &amp;lt;span class=&#34;pun&#34;.&amp;lt;/span &amp;lt;span class=&#34;kwd&#34;sizeof&amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;lit&#34;184&amp;lt;/span &amp;lt;span class=&#34;pun&#34;.&amp;lt;/span&amp;lt;span class=&#34;pln&#34; ispod&amp;lt;/span&amp;lt;span class=&#34;pun&#34;=&amp;lt;/span&amp;lt;span class=&#34;pln&#34;yes&amp;lt;/span Insertion
EDIT:
Ok, because my previous results included a bug, they actually tested ordered insertion, which exhibited a very fast behavior for the flat maps.
I left those results thereunder because they are interesting.
This is the correct test: I have checked the implementation, there is no such thing as a deferred sort implemented in the flat maps here. Each insertion sorts on the fly, therefore this benchmark exhibits the asymptotic tendencies:
map : N * log(N)
hashmaps : amortized N
vector and flatmaps : N * N
Warning: hereafter the test for std::map and both flat_maps here is buggy and actually testsordered insertion:
We can see that ordered insertion, results in back pushing, and is extremely fast. However, from non-charted results of my benchmark, I can also say that this is not near the optimiality of back-insertion in a vector. Which is 3Million cycles, we observe 4.8M here for boost (160% of the optimal).
Random search of 3 elements (clocks renormalized to 1)
in size = 100
in size = 10000
Iteration
over size 100 (only MediumPod type)
over size 10000 (only MediumPod type)
best regards
</content>
    </entry>
    
     <entry>
        <title>[转]linux下TCP/IP及内核参数优化调优</title>
        <url>https://cppfans.org/1945.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>tcp</tag><tag>优化</tag>
        </tags>
        <content type="html"> via:http://www.sudops.com/linux-kernel-tcp-ip-sysctl-optimize.html
Linux下TCP/IP及内核参数优化有多种方式，参数配置得当可以大大提高系统的性能，也可以根据特定场景进行专门的优化，如TIME_WAIT过高，DDOS攻击等等。
如下配置是写在sysctl.conf中，可使用sysctl -p生效，文中附带了一些默认值和中文解释（从网上收集和翻译而来），确有些辛苦，转载请保留链接，谢谢～。
相关参数仅供参考，具体数值还需要根据机器性能，应用场景等实际情况来做更细微调整。
net.core.netdev_max_backlog = 400000 #该参数决定了，网络设备接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。 net.core.optmem_max = 10000000 #该参数指定了每个套接字所允许的最大缓冲区的大小 net.core.rmem_default = 10000000 #指定了接收套接字缓冲区大小的缺省值（以字节为单位）。 net.core.rmem_max = 10000000 #指定了接收套接字缓冲区大小的最大值（以字节为单位）。 net.core.somaxconn = 100000 #Linux kernel参数，表示socket监听的backlog(监听队列)上限 net.core.wmem_default = 11059200 #定义默认的发送窗口大小；对于更大的 BDP 来说，这个大小也应该更大。 net.core.wmem_max = 11059200 #定义发送窗口的最大大小；对于更大的 BDP 来说，这个大小也应该更大。 net.ipv4.conf.all.rp_filter = 1 net.ipv4.conf.default.rp_filter = 1 #严谨模式 1 (推荐) #松散模式 0 net.ipv4.tcp_congestion_control = bic #默认推荐设置是 htcp net.ipv4.tcp_window_scaling = 0 #关闭tcp_window_scaling #启用 RFC 1323 定义的 window scaling；要支持超过 64KB 的窗口，必须启用该值。 net.ipv4.tcp_ecn = 0 #把TCP的直接拥塞通告(tcp_ecn)关掉 net.ipv4.tcp_sack = 1 #关闭tcp_sack #启用有选择的应答（Selective Acknowledgment）， #这可以通过有选择地应答乱序接收到的报文来提高性能（这样可以让发送者只发送丢失的报文段）； #（对于广域网通信来说）这个选项应该启用，但是这会增加对 CPU 的占用。 net.ipv4.tcp_max_tw_buckets = 10000 #表示系统同时保持TIME_WAIT套接字的最大数量 net.ipv4.tcp_max_syn_backlog = 8192 #表示SYN队列长度，默认1024，改成8192，可以容纳更多等待连接的网络连接数。 net.ipv4.tcp_syncookies = 1 #表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭； net.ipv4.tcp_timestamps = 1 #开启TCP时间戳 #以一种比重发超时更精确的方法（请参阅 RFC 1323）来启用对 RTT 的计算；为了实现更好的性能应该启用这个选项。 net.ipv4.tcp_tw_reuse = 1 #表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭； net.ipv4.tcp_tw_recycle = 1 #表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。 net.ipv4.tcp_fin_timeout = 10 #表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。 net.ipv4.tcp_keepalive_time = 1800 #表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为30分钟。 net.ipv4.tcp_keepalive_probes = 3 #如果对方不予应答，探测包的发送次数 net.ipv4.tcp_keepalive_intvl = 15 #keepalive探测包的发送间隔 net.ipv4.tcp_mem #确定 TCP 栈应该如何反映内存使用；每个值的单位都是内存页（通常是 4KB）。 #第一个值是内存使用的下限。 #第二个值是内存压力模式开始对缓冲区使用应用压力的上限。 #第三个值是内存上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的 BDP 可以增大这些值（但是要记住，其单位是内存页，而不是字节）。 net.ipv4.tcp_rmem #与 tcp_wmem 类似，不过它表示的是为自动调优所使用的接收缓冲区的值。 net.ipv4.tcp_wmem = 30000000 30000000 30000000 #为自动调优定义每个 socket 使用的内存。 #第一个值是为 socket 的发送缓冲区分配的最少字节数。 #第二个值是默认值（该值会被 wmem_default 覆盖），缓冲区在系统负载不重的情况下可以增长到这个值。 #第三个值是发送缓冲区空间的最大字节数（该值会被 wmem_max 覆盖）。 net.ipv4.ip_local_port_range = 1024 65000 #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。 net.ipv4.netfilter.ip_conntrack_max=204800 #设置系统对最大跟踪的TCP连接数的限制 net.ipv4.tcp_slow_start_after_idle = 0 #关闭tcp的连接传输的慢启动，即先休止一段时间，再初始化拥塞窗口。 net.ipv4.route.gc_timeout = 100 #路由缓存刷新频率，当一个路由失败后多长时间跳到另一个路由，默认是300。 net.ipv4.tcp_syn_retries = 1 #在内核放弃建立连接之前发送SYN包的数量。 net.ipv4.icmp_echo_ignore_broadcasts = 1 # 避免放大攻击 net.ipv4.icmp_ignore_bogus_error_responses = 1 # 开启恶意icmp错误消息保护 net.inet.udp.checksum=1 #防止不正确的udp包的攻击 net.ipv4.conf.default.accept_source_route = 0 #是否接受含有源路由信息的ip包。参数值为布尔值，1表示接受，0表示不接受。 #在充当网关的linux主机上缺省值为1，在一般的linux主机上缺省值为0。 #从安全性角度出发，建议你关闭该功能。  </content>
    </entry>
    
     <entry>
        <title>介绍一个headonly的log库easylogging&#43;&#43;</title>
        <url>https://cppfans.org/1901.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>easyloggingpp</tag><tag>headonly</tag><tag>log</tag>
        </tags>
        <content type="html"> 因为TX的log要求按照小时滚动，并且按照大小滚动，原来的glog设置完大小后，容量了就不会再写入了，而且按小时滚动也很麻烦，所以就找了找其他的log库。
主要要求简单上手，支持大小和时间滚动，不需要改动太多。
看了之前用过的log4cxx等库，发现编译成静态文件后太大了，我们又必须要求静态，所以就很麻烦。
github上找到了一个easylogging&#43;&#43;的库，headonly，只有一个头文件，看起来非常炫酷，决定试一试，结果上手确实很简单，支持配置，配置也很强大
项目地址：https://github.com/easylogging/easyloggingpp
一个简单的使用例子：
#include &#34;boost/filesystem.hpp&#34; #include &#34;easylog/easylogging&#43;&#43;.h&#34; INITIALIZE_EASYLOGGINGPP static unsigned int idx = 0; void rolloutHandler(const char* filename, std::size_t size) { std::stringstream stream; stream &amp;lt;&amp;lt; filename &amp;lt;&amp;lt; &#34;.&#34; &amp;lt;&amp;lt; &#43;&#43;idx; boost::filesystem::rename(filename, stream.str().c_str()); } int main(int argc, char** argv) { el::Loggers::addFlag(el::LoggingFlag::StrictLogFileSizeCheck); el::Configurations conf(&#34;log.conf&#34;); el::Loggers::reconfigureAllLoggers(conf); el::Helpers::installPreRollOutCallback(rolloutHandler); for (int i = 0; i &amp;lt; 100000; &#43;&#43;i) { LOG(INFO) &amp;lt;&amp;lt; &#34;Test==========================================================&#34;; } el::Helpers::uninstallPreRollOutCallback(); return 0; }  上面注册过滚动函数后就可以按照大小滚动了，不过注意一定要加上StrictLogFileSizeCheck的flag。
按照小时滚动的我加了一些简单粗暴的代码实现了，就不放出来献丑了，如果大家需要，可以单独找我获取。
其中log.conf是配置文件，大致内容如下：
* GLOBAL: FORMAT = &#34;[%level | %datetime] | %msg&#34; ENABLED = true TO_FILE = true TO_STANDARD_OUTPUT = true MILLISECONDS_WIDTH = 3 PERFORMANCE_TRACKING = false MAX_LOG_FILE_SIZE = 209715200 ## Throw log files away after 2097152 2MB / 209715200 200MB / 4398046511104 1GB * INFO: LOG_FLUSH_THRESHOLD = 10 FILENAME = &#34;log/game_server_info_%datetime{%Y%M%d%H}.log&#34; ENABLED = true * DEBUG: FILENAME = &#34;log/game_server_debug_%datetime{%Y%M%d%H}.log&#34; ENABLED = true * WARNING: LOG_FLUSH_THRESHOLD = 0 FILENAME = &#34;log/game_server_warn_%datetime{%Y%M%d%H}.log&#34; ENABLED = true * TRACE: * VERBOSE: FORMAT = &#34;%level-%vlevel | %datetime{%d/%M/%y} | %msg&#34; ## Error logs * ERROR: LOG_FLUSH_THRESHOLD = 0 ENABLED = true FILENAME = &#34;log/game_server_error_%datetime{%Y%M%d%H}.log&#34; * FATAL: LOG_FLUSH_THRESHOLD = 0 ENABLED = true FILENAME = &#34;log/game_server_fatal_%datetime{%Y%M%d%H}.log&#34;  生成出来的log非常整齐，整体满足了我的需求，而且只有头文件，不需要编译库，实在是方便。
</content>
    </entry>
    
     <entry>
        <title>[转]怎样尊重一个程序员</title>
        <url>https://cppfans.org/1847.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html">  先在前面写一些，这篇文章提到的一些问题应该很多人都碰到过，很多IT类公司都存在这样的毛病，也存在文中提到的那些人。最后提到的git难用，失败的设计等等都是很正确的。虽然王垠有时候挺偏激的，但是这篇文章我完全赞同。
正文开始：
得知一位久违的同学来到了旧金山湾区，然而我见到他时，这人正处于一生中最痛苦的时期。他告诉我，自己任职的公司在他加入之前和之后，判若两人。录取的时候公司对他说，我们对你在实习期间的表现和学术背景非常满意，你不用面试，甚至不用毕业拿学位，直接就可以加入我们公司成为正式员工。然而短短一年后的今天，这位同学已经完全感觉不到公司对自己技能的尊重。Manager让他做一些乱七八糟没技术含量的事情，还抱怨说他做事太慢，并且在他的evaluation上很是写了一笔。在人格尊严和工作安全感的双重打击之下，这位同学压力非常大，周末经常偷偷地加班，仍然无法让manager满意。
我很了解这位同学的能力，在任何一流公司任职，肯定是绰绰有余了。他的名字我当然保密，然而他所任职的公司因为太过嚣张，我不得不直接指出来——这就是被很多人向往得像天堂一样的地方，Google。这位同学所描述的遭遇，跟我几年前在Google的实习经历如出一辙。我仍然记得，Google的队友在旁边看着我用Emacs，用小学老师似的口气对我说：“按Ctrl-k！” 我仍然记得，在提交队友完全无法写出来的高难度代码时，被指责和嘲笑不会用Perforce。我仍然记得，吃饭时同事们对所谓“Google牛人”眉飞色舞的艳羡。我仍然记得，最后我一个人做出整个团队做梦都做不出来的项目的时候，有人发出沉闷的咆哮：“快——写——测——试！” ……
就算你受到过世界上最好的教育，能完成世界上没有第二个人能够完成的工作，比起Googler们心目中的所谓“大牛”，你仍然什么都不是。在Google的每一天，我都感觉自己在上演《皇帝的新装》。我在给皇帝做一件美轮美奂的衣服，愚蠢或者不称职的人都看不见这件衣服。皇帝的大臣时不时来视察一下，却发现无法看见我织的布料…… 我又像是在上演《叶公好龙》，有一位叫叶公的人，声称要寻找世界上最有创造力，掌握精髓知识，不循规蹈矩的人才。可当真的见到这种人的时候，他害怕了。他无法理解这种能力，不知道如何尊重它，保护它，使用它。他闭上眼默念，我才是世界上最厉害最聪明最伟大的！他吹毛求疵，用肤浅愚蠢的标准来评判龙的价值……
我的这位同学也算得上本领域顶尖的专家了。如此的践踏一个专家的价值，用肤浅的标准来评判和对待他们，Google并不是唯一一个这样的公司。我之前任职的好几个公司，或多或少都存在类似的问题。很多时候也不一定是公司管理层无端施加压力，而是程序员之间互斗的厉害，互相judge，伤害自尊。从最近Linus Torvalds在演讲现场公然对观众无理，你可以看出这种只关心技术，不尊重人的思潮，在程序员的社区里是非常普及的。
后来我发现，并不是程序员故意想要藐视对方或者互相攻击，而是他们真的不明白什么叫做“尊重”，他们不知道如何说话才可以不伤害另一个程序员，所以有时不小心就让人怒火中烧。所以说，尊重他人其实是一个“技术问题”，而不是有心就可以做到的。因为这个原因，我想在下文里从心理和技术角度出发，指出IT业界不尊重人现象的起源，同时提出几点建议，告诉人们如何真正的尊重一个程序员。我希望这些建议对公司的管理层有借鉴意义，也希望它们能给与正在经受同样痛苦的程序员们一些精神上的鼓励。
我觉得为了建设一个程序员之间互相尊重的公司文化，应该注意以下几个要点。
认识和承认计算机系统里的历史遗留糟粕 很多不尊重人现象的起源，都是因为某些人偏执的相信某种技术就是世界上最好的，每个人都必须知道，否则他就不是一个合格的程序员。这种现象在Unix（Linux）的世界尤为普遍。Unix系统的鼓吹者们（我曾经是其中之一）喜欢到处布道，告诉你其它系统的设计有多蠢，你应该遵从Unix的“哲学”。他们仿佛认为Unix就是世界终极的操作系统，然而事实却是，Unix是一个设计非常糟糕的系统。它似乎故意被设计为难学难用，容易犯错，却美其名曰“强大”，“灵活”。眼界开阔一点的程序员都知道，Unix的设计者其实基本不懂设计，他们并不是世界上最好的程序员，却有一点做得很成功，那就是他们很会制造宗教，煽动人们的盲从心理。Unix设计者把自己的设计失误推在用户身上，让用户觉得学不会或者搞错了都是自己的错。
如果你对计算机科学理解到一定程度，就会发现我们其实仍然生活在计算机的石器时代。特别是软件系统，建立在一堆历史遗留的糟糕设计之上。各种蹩脚脑残的操作系统（比如Unix，Linux），程序语言（比如C&#43;&#43;，JavaScript，PHP，Go)，数据库，编辑器，版本控制工具，…… 时常困扰着我们，这就是为什么你需要那么多的所谓“经验”和“知识”。然而，很多IT公司不喜欢承认这一点，他们一向以来的作风是“一切都是程序员的错！”，“作为程序员，你应该知道这些！” 这就造成了一种“皇帝的新装现象”——大家都不喜欢用一些设计恶劣的工具，却都怕别人嘲笑或者怀疑自己的能力，所以总是喜欢显示自己“会用”，“能学”，而没有人敢说它难用，敢指出设计者的失误。
我这个人呢，就是这种“黑客文化”的一个反例。我所受到的多元化教育，让我从这些偏激盲从，教条主义的心理里面跳了出来。每当有人因为不会某种工具或者语言来请教我时，我总是很轻松的调侃这工具的设计者，然后告诉他，你没理由知道这些破玩意儿，但其实它就是这么回事。然后我一针见血的告诉他这东西怎么回事，怎么用，是哪些设计缺陷导致了我们现在的诡异用法…… 我觉得所有的IT从业人员对于这些工具，都应该是这样的调侃态度。只有这样，软件行业才会得到实质性的进步，而不是被一些自虐的设计所困扰，造成思维枷锁。
总之，这是一个非常重要的“态度问题”。虽然在现阶段，我们有必要知道如何绕过一些蹩脚的工具，利用它们来完成自己的任务。然而在此同时，我们必须正视和承认这些工具的恶劣本质，而不能拿它们当教条，把什么事都怪罪于程序员。只有分清工具设计者的失误和程序员自己的失误，不把工具的设计失误怪罪于程序员，我们才能有效地尊重程序员们的智商，鼓励他们做出简单，优雅，完善的产品。
分清精髓知识和表面知识，不要太拿经验当回事 在任何领域，都只有少数知识是精髓的，另外大部分都是表面的，肤浅的，是从精髓知识衍生出来的。精髓知识和表面知识都是有用的，然而它们的分量和重要性却是不一样的。所以必须区分精髓知识和表面知识，不能混为一谈，对待它们的态度应该是不一样的。由于表面知识基本是死的，而且很容易从精髓知识推导衍生出来。我们不应该因为自己知道很多表面知识，就自以为比掌握了精髓知识的人还要强。不应该因为别人不知道某些表面知识，就以为自己高人一等。
IT公司经常有这样的人，以为精通一些看似复杂的命令行，或者某些难用的程序语言就很了不起似的。他们如果听说你不知道某个命令的用法，那简直就像法国人不知道拿破仑，美国人不知道华盛顿一样。这些人没有发现，自己身边有些同事其实掌握着精髓的知识，他们完全有能力从自己已有的知识，衍生制造出所有这些工具，而不只是使用它们，甚至设计得更加完善和方便易用。这种能够设计制造出更好工具的人，往往身负更加重要的任务，所以他们往往会在被现有工具的用法迷惑的时候，非常谦虚的请同事帮助解决，大胆的承认自己的糊涂。
如果你是这个精通工具用法的人，切不可以把同事的谦虚请求当成可以显摆自己“资历”的时候。这同事往往真的是在“不耻下问”。他并不是搞不懂，而是根本不屑于，也没有时间去考虑这种低级问题。他的迷惑，往往来源于工具设计者的失误。他很清楚这一点，他也知道自己的技术水平其实是高于这工具的设计者的。然而为了礼貌，他经常不直接批评这工具的设计，而是谦虚的责怪自己。所以同事向你“虚心请教”，完全是为了制造一种友好融洽的气氛，这样可以节省下时间来干真正重要的事情。这种虚心并不等于他在膜拜你，承认自己的技术能力不如你。
所以正确的对待方式应该是诚恳的表示对这种迷惑的理解，并且坦率的承认工具设计上的不合理，蹩脚之处。如果你能够以这种谦和的态度，而不是自以为专家的态度，同事会高兴地从你这里“学到”他需要的，肤浅的死知识，并且记住它，避免下次再为这种无聊事来打扰你。如果你做出一副“天下只有我知道这奇技淫巧”的态度，同事往往会对你，连同这工具一起产生鄙视的情绪。他下次会照样记不住这东西的用法，然而他却再也不会来找你帮忙，而是一拖再拖。
不要自以为聪明，不要评判别人的智商和能力 在IT公司里，总是有很多人觉得自己聪明，想显示自己比别人聪明。这种人似乎随时都在评判（judge）别人，你说的任何话，不管认真的还是开玩笑的，都会被他们拿去作为评估你智商和能力的依据。
有时候你写了一些代码，自己知道时间不够，可是当时有更重要的事情要做，所以打算以后再改进。如果你提交代码时被这种人看到了，他们就会坚定地认为你一辈子只能写出那样的代码。这就是所谓“wishful thinking”，人只能看到他希望看到的东西。这种人随时都在希望自己比别人聪明，所以他们随时都在监听别人显得不如他聪明的时候，而对别人比他高明的时候视而不见。他们只能看到别人疏忽的时候，因为那是可以证明他们高人一等的有利证据。
当然，谁会喜欢这样的人呢，可是他们在IT公司里相当的普遍。你不敢跟他们说话，特别是不敢开玩笑，因为他们会把你稀里糊涂的玩笑话全部作为你智商低下或者经验不足的证据。你不敢问他们问题，因为他们会认为你问问题，说明你不懂！我发现具有这种心理的人，一般潜意识里都存在着自卑。他们有某些方面（包括智力在内）不如别人，所以总是找机会显得高人一等。我还没有想出可以纠正这种心理问题的有效方法，但如我上节所说，意识到整个行业，包括你仰慕的鼻祖们，其实都不懂很多东西，都是混饭吃的，是一个有效的放松这种心理的手段。
有时候我喜欢自嘲，对人说：“我们这行业的祖先做了这么多BUG来让我们修补。现在你做了一坨屎，我也做了一坨屎，我的屎貌似比你的屎香一点。”这样一来，不但显示出心理的平等和尊重，而且避免了因为谦虚而让对方产生高人一等的情绪。说真的，做这行根本不需要很高的智力，所以最好是完全放弃对人智力的判断。你不比任何人更聪明，也不比他们笨。
解释高级意图，不要使用低级命令 随时都要记住，同事和下属是跟你智力相当的人。他们是通情达理的人，然而却不会简单地服从你的低级命令。像我在Google的队友的做法，就是一个很好的反面教材。其实这位Googler只是想告诉我：“删掉这行文本，然后改成这样……” 就是如此一个简单的事情，然而她却故弄玄虚，不直接告诉我这个“高级意图”，而是使用非常低级的指令：“按Ctrl-k！……” 语气像是在对一个不懂事的小学生说话，好像自己懂很多，别人什么都不知道似的。
有哪个Emacs用户不知道Ctrl-k是删掉一行字呢，况且你现在面对的其实是一个资深Emacs用户。我想大家都看出来这里的问题了吧。这样的低级命令不但逻辑不清楚，而且是对另一个人的智力的严重侮辱。你当我是什么啊？猴子？如果这位Googler表明自己的高级意图，就会很容易在心理上和逻辑上让人接受，比如她可以说：“配置文件的这行应该删掉，改成……”
在项目管理的时候也需要注意。在让人做某一件事之前，应该先解释为什么要做这件事，以及它的重要性。这样才能让人理解，才能尊重程序员的智商。
不要期望新人向自己学习 很多IT公司喜欢把新人当初学者，期望他们“从新的起跑线出发”，向自己“学习”。比如，Google把新员工叫做“Noogler”（Newbie Googler的意思），甚至给他们发一种特殊的螺旋桨帽子，其寓意在于告诉他们，小屁孩要谦虚，要向伟大的Google学习，将来才可以飞黄腾达。
这其实是非常错误的作法，因为它完全不尊重新员工早已具备的背景知识，把自己的地位强加于他们头上。并不是你说“新的起跑线”就真的可以把人的过去都抹杀了的。新人不了解你们的代码结构和工程方式，并不等于你们的方式就会先进一些。Google里面真的有很多值得学习的东西吗？学校的教育真的一文不值吗？其实恰恰相反。我可以坦然的说，我从自己的教授身上学会了最精髓的知识，而从Google得到的，只是一些很肤浅的，死记硬背就可以掌握的技能，而且其中有挺多其实是糟粕。我在Google做出的所有创新成果，全都是从学校获得的精髓知识的衍生物。很多PhD学生鄙视Google，就是因为Google不但自己技术平庸，反倒喜欢把自己包装成最先进的，超越其它公司和学校的，并且嚣张的期望别人向他们“学习”。
一个真正尊重人才的公司会去了解，尊重和发挥新人从外界带来的特殊技能，施展他们特有的长处，而不是一味期望他们向自己“学习”。只有这样，我们才能保持这些锐利武器的棱角，在激烈的竞争中让自己立于不败之地。如果你一味的让新人“学习”，而无视他们特有的长处，最后就不免沦为平庸。
不要以老师自居，分清“学习”和“了解” 如上文所说，IT行业的很多所谓“知识”，只不过是一些奇技淫巧，用以绕过前人设计上的失误。所以遇到别人不知道一些东西的时候，请不要以为你“教会”了别人什么东西，不要以为自己可以当老师了。以老师自居，使用一些像“跟我学”一类的语言，其实是一种居高临下，不尊重人的行为。
人们很喜欢在获得了信息的时候用“学习”这个词，然而我觉得这个词被滥用了。我们应该分清两种情况：“学习”和“了解”。前者指你通过别人的指点和自己的理解，获得了精髓的，不能轻易制造出来的知识。后者只是指你“了解”了原来不知道的一些事情。举个例子，如果有人把一件物品放在了某个你不知道的地方，你找不到，问他，然后他告诉你了。这种信息的获取，显然不叫“学习”，这种信息也不叫做“知识”。
然而，IT行业很多时候所谓的“学习”，就是类似这种情况。比如，有人写了一些代码，设计了一些框架模块。有人不知道怎么用，然后有人告诉他了。很多人把这种情况称为“学习”，这其实是对人的不尊重。这跟有人告诉你他把东西放在哪里了，是同样性质的。这样的代码和设计，我也可以做，甚至做得更好，凭什么你说我在向你学习呢？我只是了解了一下而已。
所谓学习，必须是更加高级的知识和技能，必须有一种“有收获”，“有提高”的感觉。简单的信息获取不能叫做“学习”，只能叫做“了解”。分清“了解”和“学习”，不以老师自居，是尊重人的一个重要表现。
明确自己的要求，不要使用指责的语气 有些人很怪异，他根本没告诉过你他想要什么，有什么特别的要求，可他潜意识里假设已经告诉你了。到了后来，他发现你的作法不符合要求，于是严厉指责你没有按照他“心目中的要求”办事。这种现象不止限于程序员，而且包括日常生活中的普通人。举个例子，我妈就是这种人的典型，所以我以前在家生活经常很辛苦。她心目中有一套“正确”的做事方式，如果你没猜出来就会挨骂。你为了避免挨骂，干脆什么事都不要做，然后她又会说你懒，所以你就左右不是人 :)
IT公司里面也有挺多这样的人，他们假设有些信息他已经告诉你了，而其实根本没告诉你。到了后来，他们开始指责你没有按照要求做事。有些极其奇葩的公司，里面的程序员不但喜欢以老师自居，而且他们“传授”你“知识”的主要方式是指责。他们事先不告诉你任何规则，然后只在你违反的时候来责备你。我曾经在这样一个公司待过，名字就不提了。
现在举一个具体的场景例子：
A: 你push到master了？
B: 是啊？怎么了？
A: 不准push到master！只能用pull request！
B: 可是你们之前没告诉过我啊……
A: 现在你知道了？！
注意到了吗？这不是一个技术问题，而是一个礼节（etiquette）问题。你没有事先告诉别人一些规则，就不该用怪罪的语气来对人说话，况且你的规则还不一定总是对的。所以我现在提醒各位IT公司，在技术上的某些特殊要求必须事先提出来，确保程序员知道并且理解。如果没有事先提出，就不要怪别人没按要求做，因为这是非常伤害人自尊的作法。其实，在任何时候都不应该使用指责的语气，它不但对解决问题没有任何正面作用，而且会恶化人际关系，最终导致更加严重的后果。
不要公开膜拜所谓 程序员的工作量不可用时间衡量 很多IT公司管理层不懂得如何估算程序员的工作量，所以用他们坐在自己位置上工作的时间来估算。如果你能力很强，在很短的时间内把最困难的问题解决了，接下来他们不会让你闲着，而会让你做另外一些很低级的活。这是很不合理的作法。打个比方，能力强的员工就像一辆F1赛车，马力和速度是其他人的几十倍。当然，普通人需要很长时间才能解决，甚至根本没法解决的问题，到他手里很快就化解掉了。这就像一辆F1赛车，眨眼工夫就跑完了别人需要很久的路程。如果你用时间来衡量工作量，那么这辆赛车跑完全程只需要很短时间，所以你算出来的工作量就比普通车子小很多。你能因此说赛车工作不够努力，要他快马再加鞭吗？这显然是不对的。
物理定律是这样：能量 = 功率 x 时间。工作量也应该是同样的计算方法。英明的，真正理解程序员的公司，就不会指望高水平的程序员不停地工作。高水平程序员由于经常能够另辟蹊径，一个就可以抵好几个甚至几十个普通程序员。他们处理的问题比常人的困难很多，费脑力多很多，当然他们需要更好的休息，保养，娱乐，…… 如果你让高水平的程序员太忙了，一刻都不停着，有趣有挑战性的事情做完了就让他们做一些低级无聊的事情，他们悟出这个道理之后，就会故意放慢速度，有时候明明很快做完了也会说没做完。与其这样，不如只期望他们工作短一点的时间，把事情做完就可以。
当然这并不是说初级的程序员就应该过量工作。编程是一项艰苦的脑力活动，超时超量的工作再加上压力，只会带来效率的低下，质量的降低。
不要让其他人修补自己的BUG 这个我已经在一篇专门的文章里讨论过。让一个程序员修补另外一个程序员的BUG，不但是效率低下，而且是不尊重程序员个人价值的作法，应该尽量避免。
在软件行业，经常看到有的公司管理让一个人修补另一个人代码里的BUG。有时候有人写了一段代码，扔出来不管了，然后公司管理让其他工程师来修复它。我想告诉你们，这种方法会很失败。
首先，让一个人修复另一个人的BUG，是不尊重工程师个人技术的表现。久而久之会降低工程师的工作积极性，以至于失去有价值的员工。代码是人用心写出来的作品，就像艺术家的作品一样，它的质量牵挂着一个人的人格和尊严。如果一个人A写了代码，自己都不想修复里面的BUG，那说明A自己都认为他自己的代码是垃圾，不可救药。如果让另一个人B来修复A代码里的BUG，就相当于是让B来收拾其他人丢下的垃圾。可想而知，B在公司的眼里是什么样的地位，受到什么样的尊重。
其次，让一个人修复另一个人的BUG，是效率非常低下的作法。每个人都有自己写代码的风格和技巧，代码里面包含了一个人的思维方式。人很难不经解释理解别人的思想，所以不管这两人的编程技术高下，都会比较难理解。不能理解别人的代码，不能说明这人编程技术的任何方面。所以让一个人修补另一个人的BUG，无论这人技术多么高明，都会导致效率低下。有时候技术越是高的人，修补别人的BUG效率越是低，因为这人根本就写不出来如此糟糕的代码，所以他无法理解，觉得还不如推翻重写一遍。
当我在大学里做程序设计课程助教的时候，我发现如果学生的代码出了问题，你基本是没法简单的帮他们修复的。我的水平显然比学生的高出许多，然而我却经常根本看不懂，也不想看他们的代码，更不要说修复里面的BUG。就像上面提到的，有些人自己根本不知道自己在写什么，做出一堆垃圾来。看这样的代码跟吃屎的感觉差不多。对于这样的代码，你只能跟他们说这是不正确的。至于为什么不正确，你只能让他们自己去改，或者建议他们推翻重写。也许你能指出大致的方向和思路，然而深入到具体的细节却是不可能的，而且不应该是你的职责。这就是我的教授告诉我的做法：如果代码不能运行，直接打一个叉，不用解释，不用推敲，等他们自己把程序改好，或者实在没办法，来office hours找你，向你解释他们的思想。
如果你明白我在说什么，从今天起就对自己的代码负起责任来，不要再让其它人修补自己的BUG，不要再修补其他人的BUG。如果有人离开公司，必须要有人修补他遗留下来的BUG，那么说话应该特别特别的小心。你必须指出需要他帮忙的特殊原因，强调这件事本来不是他的错，本来是不应该他来做的，但是有人走了，没有办法，并且诚恳的为此类事情的发生表示歉意。只有这样，程序员才会心甘情愿的在这种特殊关头，修补另外一个人的BUG。
不要嚷着要别人写测试 在很多程序员的脑子里，所谓的“流程”和“测试”，比真正解决问题的代码还重要。他们跟你说起这些，那真的叫正儿八经，义正言辞啊！所以有时候你很迷惑，这些人除了遵守这些按部就班的规矩，还知道些什么。大概没有能力的人都喜欢追究各种规矩吧，这样可以显得自己“没有功劳有苦劳”。这些人自己写的代码很平庸，不知道如何简单有效地解决困难的问题，却喜欢在别人提交代码让他review的时候叫喊：“测试很重要！覆盖很重要！你要再加一些测试才能通过我的review！”
本来code review是让他们帮忙发现可能存在的问题，有些人却仿佛把它作为了评判（judge）其他人能力，经验，甚至智商的机会。他们根本不明白别人代码的实质价值，就知道以一些表面现象来判断。我在Google实习，最后提交了质量和难度都非常高的代码，然而一些完全没能力写出这样代码的人，不但没表示出最基本的肯定，反而发出沉闷的咆哮：“快——写——测——试！” 你觉得我会高兴吗？
我并不否认测试的用处，然而很多人提起这些事情时候，语气和态度是非常不尊重，让人反感的。这些人不但没有为解决问题作出任何实质贡献，当有人提交解决方案的时候，他们没有表达对真正做出贡献的人的尊重和肯定，反而指责别人没写测试。好像比他高明的人解决了问题，他反倒才是那个有发言权的，可以评判你的代码质量似的：“我管你代码写得多好，我完全没能力写出来，但你没写测试就是不够专业。你懂不懂测试的重要性啊，还做程序员！”
人际交往的问题经常不在于你说了什么，而在于你是怎么说的。所以我的意思并不是说你不该建议写测试，然而建议就该有建议的语气和态度。因为你没有做实际的工作，所以一些礼貌用语，比如“请”，“可不可以”……是必须的。经常有人说话不注意语气和态度，让人反感，却以自己是工程师，不善于跟人说话为借口。永远要记住，你没有做事，说话就应该委婉，切不可使用光秃秃的祈使句，说得好像这事别人非做不可，不做就是不懂规矩一样。
礼貌的语言，跟人的职业完全没有关系。身为工程师，完全不能作为说话不礼貌的借口。
关于Git的礼节 Git是现在最流行的代码版本控制工具。用外行话说，Git就是一个代码的“仓库”或者“保管”，这样很多人修改了代码之后，可以知道是谁改了哪一块。其实不管什么工具，不管是编辑器，程序语言，还是版本控制工具，比起程序员的核心思想来，都是次要的东西，都是起辅助作用的。可是Git这工具似乎特别惹人恼火。
Git并不像很多人吹嘘的那么好用，其中有明显的蹩脚设计。跟Unix的传统一脉相承，Git没有一个良好的包装，设计者把自己的内部实现细节无情地泄露给了用户，让用户需要琢磨者设计者内部到底怎么实现的，否则很多时候不知道该怎么办。用户被迫需要记住挺多稀奇古怪的命令，而且命令行的设计也不怎么合理，有时候你需要加-f之类的参数，各个参数的位置可能不一致，而且加了还不一定能起到你期望的效果。各种奇怪的现象，比如&amp;rdquo;head detached&amp;rdquo;，都强迫用户去了解它内部是怎么设计的。随着Git版本的更新，新的功能和命令不断地增加，后来你终于看到命令行里出现了foreach，才发现它的命令行就快变成一个（劣质的）程序语言。如果你了解ydiff的设计思想，就会发现Git之类基于文本的版本控制工具，其实属于古代的东西。然而很多人把Git奉为神圣，就因为它是Linus Torvalds设计的。
Git最让人恼火的地方并不是它用起来麻烦，而是它的“资深用户”们居高临下的态度给你造成的心理阴影。好些人因为自己“精通Git”就以为高人一等，摆出一副专家的态度。随着用户的增加，Git最初的设计越来越被发现不够用，所以一些约定俗成的规则似乎越来越多，可以写成一本书！跟Unix的传统一脉相承，Git给你很多可以把自己套牢的“机制”，到时候出了问题就怪你自己不知道。所以你就经常听有人煞有介事的说：“并不是Git允许你这么做，你就可以这么做的！Unix的哲学是不阻止傻人做傻事……” 如果你提交代码时不知道Git用户一些约定俗成的规则，就会有人嚷嚷：“rebase了再提交！” “不要push到master！” “不要merge！” “squash commits！” 如果你不会用git submodule之类的东西，有人可能还会鄙视你，说：“你应该知道这些！”
打个比方，这样的嚷嚷给人的感觉是，你得了奥运会金牌之后，把练习用的器材还回到器材保管科，结果管理员对你大吼：“这个放这边！那个放那边！懂不懂规矩啊你？” 看出来问题了吗？程序员提交了有高价值的代码（奥运金牌），结果被一些自认为Git用的很熟的人（器材保管员）厉声呵斥。
一个尊重程序员的公司文化，就应该把程序员作为运动健将，把程序员的代码放在尊贵的地位。其它的工具，都应该像器材保管科一样。我们尊重这些器材保管员，然而如果运动员们不懂你制定的器材摆放规矩，也应该表示出尊重和理解，说话应该和气有礼貌，不应该骑到他们头上。所以，对于Git的一些命令和用法，我建议大家向新手介绍时，这样开场：“你本来不该知道这些的，可是现在我们没有更好的工具，所以得这样弄一下……”
</content>
    </entry>
    
     <entry>
        <title>[转载]理解云计算：SaaS、PaaS与IaaS</title>
        <url>https://cppfans.org/1840.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>cloud</tag><tag>云计算</tag>
        </tags>
        <content type="html"> 作为一个广义的术语，云计算描述了一种范围广泛的服务。许多IT厂商都抓住了“云”这个概念，并将其作为产品的一种通用技术。对于公司而言，为了真正了解并利用云计算的价值，首先要了解什么是云计算，及其不同的组成部分。由于云服务是一个广泛的服务集合，因此用户可以选择何时、何地以及如何使用云计算。在这份报告中，我们将解释不同类型的云计算服务，包括软件即服务（SaaS），平台即服务（PaaS）和基础架构即服务（IaaS）；并给出一些例子来说明他们如何工作。我们也将说明云计算在什么情况下，不是最好的选择。
&amp;nbsp;
云计算层次（Stack）
云计算常被描述为一个层次堆栈（Stack），每个层次建立在另一个层次的顶部，并向上提供服务接口，因此被称为“云”。通常，对于云计算的的定义来自于美国国家标准与技术研究院（NIST）。NIST将云计算定义为一个模型，简易的管理即可方便地按需配置网络访问，并可以配置计算资源（如网络，服务器，存储，应用程序和服务）。
&amp;nbsp;
这意味着最终用户可以方便快捷地利用大块资源。NIST还提供了几个特点，并且这些特点被认为是“云”服务中必不可少的。这些特征包括：
&amp;nbsp;
 按需自助式服务。用户通过注册获得服务，而传统的IT技术需要很长时间才能为最终用户提供服务。 广泛的网络访问资源。可以通过标准平台（如台式机，笔记本电脑，手机等）来访问服务。 资源池。资源可被多个客户享用。 拥有快速的扩展性。可以随突发需求高峰来快速扩展。 计费服务。按照使用协定来进行计费。  &amp;nbsp;
近几年，向市场推出的“云计算”概念，已经被传统软件厂商普遍接受。下图描绘了云计算堆栈的三个不同的类别：软件即服务（SaaS），平台即服务（PaaS）和基础设施即服务（IaaS）。
在这份报告中，我们将对所有三个类别进行区分，而区分这三种方式有一个非常简单的方法：
&amp;nbsp;
 SaaS通过网络运行，为最终用户提供应用服务。 PaaS是一套工具服务，可以为编码和部署应用程序提供快速、高效的服务。 IaaS包括硬件和软件，例如服务器，存储，网络，操作系统。  &amp;nbsp;
有人曾将这3个组件相互关联，并写了一个比喻为了帮助理解：就其本身而言，单独的IaaS基础设施毫无作用，它只能为上一层的资源提供帮助来发挥其生产力，就好比道路的存在是为了汽车和卡车来运送乘客与货物。在这个比喻中，道路被比作为IaaS基础设施，而汽车和卡车是坐落在基础设施之上的工具（PaaS），运送的货物和人员则可被比作软件和信息（SaaS）。
&amp;nbsp;
需要注意的是，虽然本文对SaaS，PaaS和IaaS的差异进行了区分，但是PaaS和IaaS的概念已日趋模糊。现在我们对这些组件的交互有了大致的了解，下面将会把注意力转向堆栈的顶层——SaaS。
SaaS：软件即服务
软件即服务（SaaS）被定义为部署在互联网上的软件。通过SaaS授权后，可以订阅按需服务，即“支付使用”的模式，或通过广告等方式提供免费服务。这种服务的快速增长使得SaaS迅速流行，因此用户必须了解，什么是SaaS，以及在哪些场合下SaaS是重要的。
&amp;nbsp;
SaaS的特点
SaaS遵守广义云计算中的定义，并有如下特点：
&amp;nbsp;
 可通过Web访问的商业软件。 软件集中式管理。 软件通过“一对多”模式进行交付使用。 最终用户无需处理软件升级和补丁。 应用程序接口（API）可在不同软件之间集成。  SaaS的适用场合
SaaS为云计算的最终交付提供了一项技术方法。当使用云计算时，公司必须考虑所迁移的应用程序是否合适SaaS。在以下场合中将应用程序移植到SaaS是个不错选择：
&amp;nbsp;
 Vanilla提供的SaaS功能更为全面。一个很好的例子是Vanilla提供的众多服务中包含了电子邮件；而原先使用的是单一功能的软件，尽管也能满足商务需求，但并没有竞争优势。 需要网络或可通过移动设备访问的应用。例如，移动销售管理软件 用于短期需求的软件，例如一个特定项目的协作软件。 在特定时间需求使用的软件，例如每月使用一次税收或收费软件。  &amp;nbsp;
SaaS在引入到商业界后，被Salesforce作为客户关系管理（CRM）产品广泛接受。CRM是最流行的SaaS应用之一，同样，电子邮件，财务管、客户服务和费用管理也通过SaaS取得了良好的吸收。
SaaS不适用的场合
SaaS是一种非常有价值的工具，但是在一些特定的情况下，SaaS并不是软件交付的最佳选择。例如，SaaS可能不适合于以下场景：
&amp;nbsp;
 在需要实时处理数据，以及高速的数据处理应用 不允许数据被外部托管的情况 已有现有的内部部署解决方案能够满足所有需求  &amp;nbsp;
SaaS，即“软件即服务”是云计算最广为人知的一种服务，世界各地都在利用云平台做为服务，但是它使得SaaS的易用性和IaaS变得更为混淆。
&amp;nbsp;
案例分析：SaaS使得Groupon公司按需为客户提供服务
&amp;nbsp;
Groupon网站于2008年11月推出，提供了横跨40多个国家，500多个市场的购物、消费交易平台。公司拥有的数千名员工分布在芝加哥以及帕洛阿尔托办事处，并且在欧洲、拉丁美洲、亚洲和非洲区域设立了办事处。Groupon公司为客户提供了优质的产品和出色的服务。
&amp;nbsp;
Groupon公司的客户服务主任Harrow介绍道：在公司成立的几个月内，客户数量以指数级上升。起初，Groupon公司几乎花费了10％的时间来响应客户请求。这些事务甚至需要几个员工才得以应付。随后，Groupon公司意识到，在没有一个真正的解决方案前，无法继续运行下去。
&amp;nbsp;
在确信了Groupon的快速增长将继续后，他对几个企业级的系统解决方案进行了研究。企业级解决方案非常复杂，并且很难建立，并且会阻碍客户体验。Harrow随后在网上搜索了在线支持软件，发现了Zendesk。通过对Zendesk进行评估后，Harrow得出了正确的解决方案。
&amp;nbsp;
并且他认为Zendesk使用直观。和其他平台相比，Zendesk更强大，并且评价更高。此外，由于它是一个基于Web的解决方案，能够对其进行扩展，以支持更多用户。
&amp;nbsp;
现在Groupon雇佣了150多个客户支持代理，能够每天处理近15,000个请求。在代理为客户提供公司服务的过程中，Groupon的宏帮助（即一些FAQ的模板）为公司建立起了一键式解决的客户形象。
&amp;nbsp;
同时，Groupon认为Zendesk能够与其他解决方案更容易地集成，通过在Zendesk中加入GoodData，Groupon能够扩展和增强其报告，并且不受电子表格的限制。
PaaS：平台即服务
&amp;nbsp;
在软件开发时，平台即服务（PaaS）为SaaS提供了基础。PaaS被定义为一个计算平台，它使得用户能够快速、方便地创建web应用，并且无需担心维护下层软件。
&amp;nbsp;
PaaS类似于SaaS，不同之处在于其通过网络建立一个软件平台，而不是通过Web软件提供服务。
PaaS的特点
PaaS由许多不同的特征构成，以下是一些基本的特征：
&amp;nbsp;
 在相同的集成开发环境中用来开发、测试、部署、托管和维护的应用。 基于Web的用户界面来创建工具，可用于创建、修改、测试和部署不同的UI场景 多客户架构，可使多个并发用户使用相同的开发应用 内置部署软件的可扩展性，包括负载平衡和故障转移 通过公共标准集成Web服务和数据库 支持开发团队协作，包括一些PaaS解决方案以及项目规划、沟通工具 用来处理帐单和订阅管理的工具  &amp;nbsp;
尽管PaaS在许多方面类似于第三部分的IaaS，但PaaS有附加的服务价值以及两个显著特征：
1、它是软件开发的协作平台，可用于管理应用程序的数据源和工作流。一个例子是Heroku的PaaS的，其利用Ruby on Rails语言开发。
2、它允许用户来利用应用程序的公共数据来创建软件，该类型的PaaS可以被看作是一种方法来创建具有一系列具有公共数据格式或类型的应用程序。Force.com的PaaS便是一个很好的例子。
&amp;nbsp;
PaaS的重要性
当多个开发人员对同一个项目进行开发或者需要外部人员对开发进行交互时，PaaS特别有用。下面的案例表明，对于那些拥有客户关系管理工具（例如销售信息）并希望应用程序能充分利​​用这些数据的人而言，PaaS被证明是无价的。同时，对于那些希望自动化测试和部署服务的开发人员，PaaS是非常有用的。
&amp;nbsp;
基于迭代和增量开发的方法使得软件开发加快并得以普及，它简化了PaaS的开发和软件迭代的困难度。
PaaS的一些例子有：谷歌的App Engine，微软Azure服务，以及Force.com平台。
不适合使用PaaS的场合
我们认为，PaaS将成为软件开发的主流方法。实现流程自动化、并且使用预先定义的组件和构件，自动部署到生产的能力将提供足够的价值，并且非常有说服力的。虽然如此，但是在一定的情况下，PaaS可能并不太理想，例如：
&amp;nbsp;
 当应用在托管时需要较高的可移植性 当专用开发语言会妨碍今后的另一提供商的上层服务 当应用程序性能需要通过底层硬件和软件来进行定制  案例分析：Menumate公司部署使用PaaS
Menumate为澳大利亚的整个酒店行业销售硬件和软件。使用PaaS的优势使得Menumate在Force.com在迁移的过程中，能够使用相同的应用程序。
为其负责软件开发的Trineo公司的执行董事Fowlie说，使用Force.com的PaaS平台允许Menumate得以集中控制。
Trineo的执行董事Keswani觉得传统方式需要显著增加基础设施、连接以及安全性需求，而Force.com平台本身提供的这些非功能性需求，使得Menumate和Trineo能够纯粹专注于开发所需的功能。此外，利用PaaS的做法意味着Trineo可以采取现有的集成和自动化部署工具来简化整个软件的开发过程。
&amp;nbsp;
通过使用PaaS，Trineo已经能够在不同业务中利用一系列现成的应用程序来开发新应用。以下是PaaS的一些应用：
&amp;nbsp;
许可证密钥：Menumate软件通过使用许可证密钥来激活客户已支付的功能。PaaS编程语言的强大功能允许Menumate软件快速部署到Force.com（其许可证密钥通过Salesforce.com的CRM中链接），这使得销售和支持人员可以快速查看许可证的状态。
&amp;nbsp;
案例管理增强：Menumate处理的很多案例与消耗品订单有关。为了解决这个问题，Menumate拥有一个单独的基于DOS的应用程序，允许用户创建订单和发票。Menumate能够在支持案例中添加产品，并用现有的集成软件自动将发票发送到会计软件上。
标签印刷：另一项传统应用，能够为耗材和硬件创建货运标签，并将其发送给发送客户。使用PaaS技术，可以将这些标签直接打印到客户记录中。
&amp;nbsp;
IaaS：基础设施即服务
基础设施即服务（IaaS）提供了云计算基础架构，包括服务器、存储、网络和操作系统。它作为一种按需服务，使得客户无需购买服务器、软件、数据库空间或网络设备，而只要按需购买这些资源的外包服务。
正如以往的白皮书介绍过，IaaS也有一些值得注意的地方。通常它可以分为公共和私有两种基础设施或是两者的组合。“公共云”被认为是包含了共享资源并在互联网上部署了自助式服务的基础设施。
相比之下，“私有云”也集成了一些诸如虚拟化等的云计算功能，但它是运行在专用网络上的基础设施。此外，一些托管服务提供商已经开始在提供传统托管服务的同时，也提供公共或私有云的网络组合。这种组合方式通常被称为“混合云”。
IaaS的特点
与之前两个部分的SaaS和PaaS相比，IaaS的是一个迅速发展的领域。可以说，它普遍遵守以下几个核心特征：
 以资源分配作为服务 允许动态调整 成本可变，以效用定价 通常在单一硬件上支持多用户  &amp;nbsp;
目前已有大量的IaaS供应商，其中既有诸如Amazon和Rackspace的超大型云供应商，也有区域型的佼佼者。
&amp;nbsp;
正如之前所述，PaaS和IaaS的之间的界限正变得越来越模糊，因为供应商正将平台工具作为IaaS的一部分来帮助云的多种类型的部署。
IaaS的适用场合
IaaS在与云计算密切相关的场合下将会发挥效益，这些场合包括：
 要求基础设施能在任意时刻能适应变化多端的需求量 当新公司没有预算投资于硬件 当公司发展迅速，在扩展硬件时遇到问题 当公司迫于预算限制，需要将资金转移到经营开支上 一些特定的商务领域，也可用于测试或临时性的设施需求  &amp;nbsp;
不适合使用IaaS的场合
虽然IaaS有可扩展性强和大规模部署迅速的优势，但在某些情况下也有它的局限性。在以下场合中，建议慎用IaaS：
 限于法律的规定，要求数据存储和处理进行隔离 对基础设施有非常高的性能要求，或原先的内部部署或专用托管基础设施已经满足需求  案例分析：Live Smart通过采取基础设施来帮助减肥者
&amp;nbsp;
Live Smart是推广该饮食解决方案的幕后公司，主要出版饮食类书籍和策划在线活动。Beyond Diet是该公司旗下的一个与减肥者互动的社区网站。
从2008年起该公司的业绩增长迅猛，甚至在2010年有了50倍的收益增长。这相当于网站有30万日的均实访客量，峰值甚至高达100万人次。当在考虑基础设施的架构时，Beyond Diet需要的是可托管性和可扩展性。重要的是，Beyond Diet网站规模需要动态的扩大或缩小的能力，以来应对定期的大流量高峰。
&amp;nbsp;
Live Smart首席技术官Rob·Volk说：“迁移到云基础设施后他省心了，而在此之前Live Smart在其网站上需要有一个兼职系统管理员，这是显然不是最好的选择；现在有了Managed Cloud（由云提供商Rackspace提供的IaaS服务），Rackspace基本上可以扮演我们的Linux和Windows系统管理员，全天24小时任何时刻如果发生当机，几分钟之内他们的工程师就会来解决这些问题，这个云改变了我们的工作，因此我们需要这种基础设施。”
&amp;nbsp;
对于Volk来说，将其网站移动到云的主要动力是他可以更加专注核心业务，而让那些基础设施的专家来日常管理云的运维，因为云供应商提供多级冗余的硬件、快速的配置和高度的灵活性，这些都起了决定性因素。有趣的是，Volk甚至从未考虑过经营自己的物理服务器，而是考虑究竟选择托管服务器还是云中的一个。
&amp;nbsp;
他选择了云还因为它降低了成本，相比那些专用服务器，云的选择有更高的灵活性。
&amp;nbsp;
Volk正在使用多个云服务提供商：他有三个Web服务器，多个数据库服务器和一个Rackspace的负载平衡器，同时也使用Amazon的S3服务。
&amp;nbsp;
Volk认为其中最大的好处是云基础设施的可扩展性。他解释说：“每当过年的时候很多人都去节食，我们的服务器的高峰时间正是在每年的1月到到3月之间，此时网站的流量是平时的三倍，而利用云服务器，我们只需在几分钟之内就能建立好新的Web前端。一旦流量下降，我们可以关闭这些前端。只有在云虚拟化环境中，我们才可能有这样的可扩展性。”
&amp;nbsp;
结论
云计算不是一个单一的术语，而是一个总称，它提出了IasS作为基础、PaaS作为开发工具、SaaS作为顶层应用，来取代以往的内部部署应用服务。
对于那些打算迁移到云计算的公司而言，非常重要的一点，是需要了解云计算的每个层面，并结合自己的情况来决定哪些是适合他们需求的解决方案。
随着IT的发展，云计算将加速变革，并将成为未来IT默认的交付方式，所以公司应该尽早考虑将其业务迁移到云计算上。
</content>
    </entry>
    
     <entry>
        <title>*.pvr.ccz与png格式的互转</title>
        <url>https://cppfans.org/1778.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>2d</tag><tag>spirit</tag><tag>图片</tag><tag>游戏资源</tag>
        </tags>
        <content type="html"> 这两天在看一个安卓游戏，资源挺不错的，解压后发现animation里的图片格式全是pvr.ccz，查了下，这是做2D游戏spirit图打包后的格式，用的软件是‍‍TexturePacker，知道了软件那就知道如何解回去了。‍‍
  下载‍‍TexturePacker&amp;nbsp;‍‍    安装TexturePacker    将如下代码存成批处理 @echo&amp;nbsp;off path&amp;nbsp;%path%;&#34;C:\Program&amp;nbsp;Files&amp;nbsp;(x86)\TexturePacker\bin&#34; for&amp;nbsp;/f&amp;nbsp;&#34;usebackq&amp;nbsp;tokens=*&#34;&amp;nbsp;%%d&amp;nbsp;in&amp;nbsp;(`dir&amp;nbsp;/s&amp;nbsp;/b&amp;nbsp;*.pvr&amp;nbsp;*.pvr.ccz&amp;nbsp;*.pvr.gz`)&amp;nbsp; do&amp;nbsp;(TexturePacker.exe&amp;nbsp;&#34;%%d&#34;&amp;nbsp;--sheet&amp;nbsp;&#34;%%~dpnd.png&#34;&amp;nbsp;--data&amp;nbsp;&#34;%%~dpnd.plist&#34;&amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;--opt&amp;nbsp;RGBA8888&amp;nbsp;--allow-free-size&amp;nbsp;--algorithm&amp;nbsp;Basic&amp;nbsp;--no-trim&amp;nbsp;--dither-fs) pause     将上面的批处理放在你的文件夹目录下，运行即可(支持遍历子目录)    将图片打包成pvr.czz，同样是需要一个批处理
‍‍
@echo&amp;nbsp;off path&amp;nbsp;%path%;&#34;C:\Program&amp;nbsp;Files&amp;nbsp;(x86)\CodeAndWeb\TexturePacker\bin&#34; for&amp;nbsp;/f&amp;nbsp;&#34;usebackq&amp;nbsp;tokens=*&#34;&amp;nbsp;%%d&amp;nbsp;in&amp;nbsp;(`dir&amp;nbsp;/s&amp;nbsp;/b&amp;nbsp;*.png`)&amp;nbsp;do&amp;nbsp;( TexturePacker.exe&amp;nbsp;&#34;%%d&#34;&amp;nbsp;--sheet&amp;nbsp;&#34;%%~dpnd.pvr&#34;&amp;nbsp;--data&amp;nbsp;&#34;%%~dpnd.plist&#34;&amp;nbsp; &amp;nbsp;&amp;nbsp;--opt&amp;nbsp;PVRTC4&amp;nbsp;--allow-free-size&amp;nbsp;--algorithm&amp;nbsp;Basic&amp;nbsp;--no-trim&amp;nbsp;--dither-fs ) pause ‍‍
</content>
    </entry>
    
     <entry>
        <title>感谢网友[Chen Hypo]帮我设计2015年新年banner</title>
        <url>https://cppfans.org/1769.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>2015</tag><tag>新年</tag>
        </tags>
        <content type="html"> 今天突然看到有一位朋友在我博客留言说送了一个新年礼物给我，打开邮箱看了下，果然有惊喜，
 引用邮件原文：
哈喽，新年马上就要来了，我在自己的博客广告位添加了几张图片。
我发现你的博客也是D8主题，因此也做了张图片送给你，
我的博客是在2014年9月开始搭建，在搭建期间遇到过各种问题，谢谢你在2014年对我的帮助！
注：
这张图片是950*100，对于D8，可以放在【广告：首页 - 正文最前上】或【广告：文章页 - 相关文章下】
代码是块糖
梦续代码/执着于代码间的乐趣！
http://www.hypo.xyz
 &amp;nbsp;
附件是一张图片，如下：
2015新年  图片还是很有诗情画意的，气氛很好，非常感谢这位朋友。
这里想说的是，这位网友说过我曾经帮助他搭建个人博客，其实我早已经忘了这件事了，帮过不少人，不过还能在新年伊始的时候记起我的屈指可数，我认为这是一个好的开始，互相帮助，互相进步。
&amp;nbsp;
这张图片已经放在了首页顶部了，看着很不错，大家感受下。
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>protobuf通过反射来赋值</title>
        <url>https://cppfans.org/1758.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>google</tag><tag>protobuf</tag><tag>反射</tag><tag>自动</tag>
        </tags>
        <content type="html"> 最近因为项目逻辑方面都做的差不多了，于是赶紧去做做测试工作，免得项目上线之后出问题，于是打算用配置的形式做一个类似与白盒测试工具的东西出来。
因为项目使用pb来做协议通讯，所以配置的xml也是类似于pb，将pb的字段和类型配置进去，然后加上值，一个协议结构就可以了，现在只能通过修改值来做测试，后面会改动的更智能化一些，例如某个行为的次数，某个行为更随机等等。
去读了一下陈硕的关于pb处理协议的反射，学到了不少东西，同时对pb的一些东西理解更深刻了，google还是大牛很多。
1.如何处理pb的反射，通过协议字串动态生成一个协议
pb提供了一个强大的DescriptorPool::generated_pool()
代码如下：
inline google::protobuf::Message* CreateMessage(const std::string&amp; msg) { google::protobuf::Message* message = NULL; const google::protobuf::Descriptor* descriptor = google::protobuf::DescriptorPool::generated_pool()-&amp;gt;FindMessageTypeByName(&#34;ProtoMsg.&#34; &#43; msg); if (descriptor) { const google::protobuf::Message* prototype = google::protobuf::MessageFactory::generated_factory()-&amp;gt;GetPrototype(descriptor); if (prototype) { message = prototype-&amp;gt;New(); } } return message; } inline void ReleaseMessage(google::protobuf::Message* pMsg) { if (NULL != pMsg) { pMsg-&amp;gt;Clear(); delete pMsg; } }  这两个函数可以动态生成pb的message,其中ProtoMsg是你pb package的名字
&amp;nbsp;
2.通过反射将配置中的值设置进pb字段
pb的Message基类提供了一个Reflection，这个类非常强大
代码如下
// mstrCurMsg 当前正在执行的协议 google::protobuf::Message* pMsg = Test::CreateMessage(mstrCurMsg); const google::protobuf::Descriptor* pDescriptor = google::protobuf::DescriptorPool::generated_pool()-FindMessageTypeByName(&#34;ProtoMsg.&#34; &#43; mstrCurMsg); assert(NULL != pDescriptor); // 这一个可以获取到反射类，然后可以将配置中值赋值进去 const google::protobuf::Reflection* pReflection = pMsg-GetReflection(); assert(NULL != pReflection); for (int i = 0; i &amp;lt; pDescriptor-field_count(); &#43;&#43;i) { const google::protobuf::FieldDescriptor* pFieldDescriptor = pDescriptor-field(i); assert(NULL != pFieldDescriptor); const std::string&amp; strFieldName = pFieldDescriptor-name(); const TestConfigModule::MsgEntry* pMsgEntry = pMsgStruct-GetMsgEntry(strFieldName); assert(NULL != pMsgEntry); // 读取字段类型，顺带可以做类型检查 assert(pMsgEntry-mnType == pFieldDescriptor-type()); // 设置值 switch (pMsgEntry-mnType) { case Test::TYPE_STRING: pReflection-SetString(pMsg, pFieldDescriptor, pMsgEntry-mstrValue); break; // ... default: break; } } std::string strData; if (!pMsg-SerializeToString(&amp;strData)) { m_pLogModule-LogNormal(&#34;Test stop, cannot SerializeToString &#34;, mstrCurMsg, __FUNCTION__, __LINE__); return; } Test::ReleaseMessage(pMsg);  通过这样的步骤，就可以自动创建message和对field赋值了，如果你也有pb的使用经验和技巧，欢迎分享
</content>
    </entry>
    
     <entry>
        <title>收集的几个xshell的配色方案</title>
        <url>https://cppfans.org/1749.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>xshell</tag><tag>配色</tag>
        </tags>
        <content type="html"> 经常使用xshell来操作Linux，不过现在xshell的School/home免费版本那几个配色方案都不怎么好看，在网上搜刮了几个配色方案，奉献给各位！
以下方案可以存入txt文本中，然后修改后缀名为xcs就可以了
&amp;nbsp;
方案1：Solarized Dark
[Names]
count=1
name0=Solarized Dark
[Solarized Dark]
text(bold)=839496
magenta(bold)=6c71c4
text=00ff40
white(bold)=fdf6e3
green=859900
red(bold)=cb4b16
green(bold)=586e75
black(bold)=073642
red=dc322f
blue=268bd2
black=002b36
blue(bold)=839496
yellow(bold)=657b83
cyan(bold)=93a1a1
yellow=b58900
magenta=dd3682
background=042028
white=eee8d5
cyan=2aa198
&amp;nbsp;
方案2：自定义方案
[myxshell]
text(bold)=e9e9e9
magenta(bold)=ff00ff
text=00ff80
white(bold)=fdf6e3
green=80ff00
red(bold)=ff0000
green(bold)=3c5a38
black(bold)=808080
red=ff4500
blue=00bfff
black=000000
blue(bold)=1e90ff
yellow(bold)=ffff00
cyan(bold)=00ffff
yellow=c0c000
magenta=c000c0
background=042028
white=c0c0c0
cyan=00c0c0
[Names]
count=1
name0=myxshell
&amp;nbsp;
具体颜色就不上图了，各位自己导入看吧，在xshell界面右键选择配色方案-&amp;gt;导入，就可以看到了
</content>
    </entry>
    
     <entry>
        <title>[转]程序员真正的价值</title>
        <url>https://cppfans.org/1744.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>价值</tag><tag>程序员</tag>
        </tags>
        <content type="html"> 看到这篇文章有一些感触，所以就转过来了。虽然我也不是什么大牛，但是文章中提到的情况也遇到过，各位共勉吧。
&amp;nbsp;
-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;分割线-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;
&amp;nbsp;
文章出处：池建强
 问：池老师，我是个不爱互动的人，但是您所有的文章我都看了，非常感谢您的引导，我入手了人生第一台 MBP。现在问题来了，但是找不到更合适的人解答，只能求助于您了，如果您有时间的话。问题是这样的：我有个32bit unix file（开启一个服务进程），在 Mac 上执行时错误提示是：exec format error，但是在 Linux 服务器却可以执行，为何？Mac 上有可以运行的方案吗？期待您的回复，不胜感激。
答：Linux 和 OS X 是不同的操作系统，可以尝试在 OS X 里重新编译这个文件。
问：非常感谢！如果没有文件源码是不是就只能认命了？
答：可以在 Mac 上装 Docker，然后对服务进行端口映射就可以了。
答：茅塞顿开。谢池老师。
 以上是我和一位读者的对话，这位小伙子在拿到答案之后像一缕烟尘一样消失无踪，之后再也没有出现过。
在微信上加了很多 MacTalk 的读者之后，经常会收到一些奇奇怪怪的问题，关于职场、关于选择、关于朋友、关于 Mac、关于技术等等，不一而足。但是我能回答的却很少。问题不好没法回答，问题太复杂没法回答，问题领域超出我的认知也没法回答，耗时太长的问题我也没 时间回答，实在是惭愧的紧。好在偶尔也能够帮助一些小伙伴解决一些实际问题，心理上略感安慰，比如上面这个问题。
把这段程序员之间的对话翻译一下，大致是这么个故事：
一 位读者有一个32位的 Unix 可执行文件，可以在某种版本的 Linux 服务器上正常运行，运行这个文件作用就是起个进程，开端口，然后与其他程序进行交互。但是这个文件拿到 Mac 上完全没办法运行。就在他趴在 Mac 上愁肠百结万念俱灰的时候，突然想到了「池老师」。不就是这个老家伙把 Mac 夸的像一朵玫瑰一样，让每个程序员都去采摘么？现在扎手了，你不管谁管？于是他给我发来消息，意思就是管也得管，不管也得管，您看着办。
我 拿到问题一看，不难。Linux 和 OS X 虽然师出同门，都是从老前辈 Unix 那儿毕业的，但是后来毕竟各练各的，在 Linux 编译好的程序不可能在 OS X 上用，但是在 OS X 上重新编译一下可能就没事了。我把这个想法告诉了这位程序员，得到的反馈是：对不起哥，没有源代码！
我被这个冷酷的回复震惊了，立刻意识到 刚才的想法并不是最优解决方案，因为在重新编译的过程中，各种包的依赖关系和编译错误足以让你焦头烂额，我随即提供了 B 计划：在 OS X 上安装 Docker，轻量级的容器 Docker 可以运行各种版本的 Linux，把文件扔到 Docker 里，然后通过主机和 Docker 之间的端口映射即可轻松解决这一问题。
虽然这里面会涉及很多技术细节，但是方向是没有问题的，所以这位程序员立刻表示「茅塞顿开」，然后「biu 」的一声就在屏幕对面消失了，没有留给我说「不客气」的机会。
这个问题装个 Linux 虚拟机也可以解决，但是虚拟机过于耗费资源，而且不如 Docker 灵活，所以不是最佳解决方案。Docker 是。
做 为一个程序员，我们除了要掌握多门程序语言和多种数据库，了解前端技术、后端技术，通晓网络七层架构，知道 TCP/IP三次握手和四次挥手，编写漂亮的代码，设计优美的架构……之外，我们还要解决研发、程序运行和产品上线过程中遇到的各种问题，而且被要求以最 小的代价来解决问题……我们容易吗？
除了编程技巧和程序设计能力，解决问题的稳准狠是衡量一个程序员是否优秀的重要因素之一，也是资深技术 人员真正的价值所在。在科技浪潮澎湃、技术信息扑面而来的今天，一位刚毕业的大学生如果足够勤奋，他可以在两三个月之内掌握一门编程语言，并编写出像模像 样的软件，他们的学习速度甚至超过了我们这些老程序员，但是解决问题的能力是无法速成的，只能依靠时间、经验和惨痛的教训历练而成。有时候还需要灵感和运 气。
很多军迷读了大量的军事著作和历史小说，常常羡慕那些名将的风采，并浩叹自己「生不逢时」。但是名将不是那么容易炼成的。历史上叱诧风 云的名将凤毛麟角，他们亲自持刀上阵追击敌人，见识战场的惨烈，目睹敌人的尸体，看到战友被杀，知道被刀看中会流血死去，他们冷酷无情，坚如磐石，在全军 即将崩溃的时候发现敌人的弱点并进行攻击，在瞬息万变的战场进行决断，在多次失败后从无数士兵的尸体里站起来重新出发去挑战那个战胜你的对手，在所有人对 你说「指导员，我们上吧」的时候，坚定的说出那三个字：再等等！
如果你做不到这些，那还是做个最终会被张飞枪挑的小兵吧。
优 秀的程序员同样如此，菜鸟常常羡慕高手在谈笑之间让难题灰飞烟灭，而自己却苦苦思索而不得入门之法，殊不知这些高手同样经历了名将的那些腥风血雨。他们在 清晨的微光里编写代码，在轰鸣的机房中调试程序，他们彻夜不眠就是为了解决一个 bug，他们要承受数据丢失或上线失败的痛苦，默默吞下眼泪，准备下一次的战斗。不停的学习、实践和思索，成千上万个小时之后，高手史成。
同 样的问题，高手的解决思路和小球是截然不同的。一般来说，只要不是世界难题，给足时间、空间和人力，都能解决。如果你遇到问题告诉上级，这个问题交给我 了，两年之内搞的妥妥哒，那就不要怪项目组组团把你打出翔来，因为大家要的是分分钟解决，不是两年。在这个唯快不破的年代，我们没有这么多的时间，所以要 通过逆向思维、经验教训、辗转腾挪、借力打力等方式以最小的代价快速解决问题。这才是老程序员的价值。
再举个例子，一个运行良好的线上应用在你修改 bug 增加功能之后重新上线出现了一些莫名其妙的问题，比如占用资源增加或运行一段时间宕机等等，怎么解决？
常规的做法就是通过阅读日志、模拟线上环境和调试程序来定位错误。容易的 bug 用这些方式基本就能搞定了，但是更隐蔽的 bug 会耗费大量的时间和人力。更好的方式是什么？
首先，排查是程序问题还是环境问题，把线上程序恢复到运行正常时的老版本，如果出现了同样的问题，那就是生产环境发生了改变。如果运行正常，要么是你修改老 bug 时引入了新 bug，要么是新增加的代码出现了问题。
其次，阅读产品的 changelog，根据代码提交的时间线构建系统，通过二分法排查，定位是哪部分代码引起的问题。
第三，排除了所有的不可能，剩下的无论看起来如何不可能，就是它干的。
以上只是一个简单的例子，实际的情况可能比这个例子复杂一百倍，需要我们综合使用各种方式进行交叉比对和错误排查才能解决。这仅仅是遇到问题解决问题，更多的时候是需要你提出问题，并解决问题，那是更高的境界。
很多人学了那么多编程语言，写了十几年程序，最终依然无法做到以最小的代价解决问题，不禁让人扼腕叹息。
程序员真正的价值是什么？以最小的代价解决问题！知行合一，方可无敌于天下。
</content>
    </entry>
    
     <entry>
        <title>[转]22条日常技巧助程序员提高工作效率、节约时间</title>
        <url>https://cppfans.org/1737.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>效率</tag><tag>时间</tag><tag>程序员</tag>
        </tags>
        <content type="html">  我一直在测试和调整各种生产效率的技术，在过去的五年中，阅读了大量的书籍（其中大多数是重复的） ，这里是我的一些结论：
这不是一个关于时间的问题，而是关于精力。 为了“有效率”，我们试图在一个工作日内塞进尽可能多的小时，但最终一切都更多地取决于你的注意力，积极性和良好状态（这些都是直接与精力等级联系在一起）而不是工作时间 。
我最近在葡萄柚的一个内部演示上提及了我提高效率的想法，结果性的演示是在Slideshare上的：producitivity porn.
其中一些关键结论：  决定什么是重要的事，因为在5年之内，你现在做的80%的事情都不会有任何结果。那只是无用功，没有有用的结果。
 睡眠，饮食和运动可以让你的成果提高到三倍，因为他们可以帮助你增强你的注意力，动力和精力水平。
 两分钟法则：如果你可以在两分钟内做完一件事（比如回复邮件或是一个家务），那就现在做。计划着一会儿完成它，记着它，并在未来完成它会花费五分钟甚至更多的时间。
 五分钟法则：治疗拖延症最好的办法不是定目标去完成一个可怕的大任务，而是只在那件事上花五分钟。你会发现在大多数情况下，它在超出五分钟的时候依旧很顺利，因为你进入了平坦期。
 Seinfeld生产链：如果你想做好一件事，那就每天去做。包括圣诞节，复活节和审判日。没有例外。
 微小的生活习惯：与五分钟法则高度结合起来，你可以很快地形成好习惯。这个很有用，我测试过的。
 你的记忆力烂透了。 即使你是一个天才也要把每件事都从你的脑子里清出来。把他们写在一个笔记本上，放进待办事项列表的应用程序里，记在手机里，或是告诉Siri，我不在意你使用的方法。
 尽量少使用工具。我曾经测试过大多数代办事件管理器，并最终保持使用Cultured Code的Thing app和谷歌日历（iCal 是不错，但是谷歌日历和我的默认客户端Gmail结合得很好）。如果你了解了下一条规则，你用什么就并不重要了（铅笔或是钢笔都是可以的）。
 规则强于工具。你需要纪律，这对我来说意味着两件事：我每天早晨做得第一件事是计划我的一天，并且我每天都写一个简短的工作日志。这有助于帮助我保持清醒，有良好的优先级排序，去掉无用的任务，并且做有意义的事情。这节约了我很多时间。
 番茄计时器，这是一个时间盒。在30分钟内只做手头的事情，不做任何其他的事情：没有电话，邮件，不和别人说话，没有社交网站。除了记得在发生火灾时从楼里跑出来外，没有别的了。
 总是带着耳机。 你没必要在听音乐，但是这会阻碍别人接近你。
 邮箱调度和收件箱清零。不要把查邮箱当做你一天里的第一件事，也不要在晚上看它（这件事毁掉了我的很多 个晚上），试着一天只查三次：早上十一点，下午两点和下午五点。你的收件箱并不是一个待办事项列表。把它清空：每一封邮件都应该是一个可操作的任务（把它 和待办列表连在一起），或是一个参考文献（把它发到Evernote或存档），或是现在就应该删掉。
 对手机来说也是一样的。不要总是能被联系到，我总是把手机静音，并分批回电话。
 把小事情分批，比如邮件，电话，或是facebook等等。
 MI3，最重要的三件事（或是改成一件必做的，3件应该做的，或是五件可以做的）。早晨开始做最重要的一件事。
 意志力是有限的。不要认为在你遇到麻烦的时候意志力会帮你。把最重要的事情放在早晨做，并且尽可能地让所有事情自动化（委托，分批等等）。美国总统不需要每天选择他们的菜单和衣服颜色，否则他们的意志力会在晚些他们需要按下（或不按）红色按钮时耗尽。
 最有驱使力的事情。总是问问自己，你现在能做的最有驱使力的事情是什么，然后应用规则14。
 经常推出新产品。不要过分地润色它。就像他们在创业公司圈所说的，“如果你不因你的产品感到难堪，你已经推出得太晚了。”
 压力会带来奇迹。使用奖励或是社会承诺。我们最近在新的葡萄柚网站上实施了这一点。之前的那个网站投入使用花了两年半的时间，而新的这个只花了两天半，我们用了一个周末进行编程马拉松（外加周一）。
 有计划的拖延。你的大脑需要休息，并且有时候新一期的绿箭侠可以比最好的TED演讲创造更大的奇迹。
 删除，说不，忽略，不要坚守日程表。我喜欢最后一点，它来自于马克·安德森，因为这样可以让他立即见任何他想见的人。这样很多人会恨你，但是你有时间做相关的事情。你认为你会在20年后后悔这样做吗？或是为了一些人做一些你不在意的事情，只是为了表面上的赞赏。
 假装无能。这是一个应用之前规矩的很有策略的方法。
  这次就到这里，我的拖沓休息结束了，我要回去工作了。
【补充】： Colin Shillingford 在他的回复中认为，“节约”时间的最好方法是充分利用我们的时间。我们无法创建之前不存在的时间。我们所能做的，改变任务的优先级，或者调整任务的顺序。 我们中的大多数，正是在这方面出问题了。此外，Colin 在回复中也推荐了他认为很不错的番茄时间管理方法。
稿源：程序师
</content>
    </entry>
    
     <entry>
        <title>google-breakpad在C&#43;&#43; 11下编译错误修改</title>
        <url>https://cppfans.org/1730.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>breakpad</tag><tag>C&#43;&#43;</tag><tag>google</tag>
        </tags>
        <content type="html"> 我只用到了exception_handler模块，暂时还未用到Server模块，因为用到了C&#43;&#43; 11的一些特性，而google-breadpad还没有C&#43;&#43;11版本，所以做了一些修改，集中在类型定义处
1.
typedef typeof(((struct user*) 0)-&amp;gt;u_debugreg[0]) debugreg_t;
修改为
#if __cplusplus &amp;gt; 199711L&amp;lt;br /&amp;gt; typedef std::remove_reference&amp;lt;decltype(((struct user*) 0)-&amp;gt;u_debugreg[0])&amp;gt;::type debugreg_t;&amp;lt;br /&amp;gt; #else&amp;lt;br /&amp;gt; typedef typeof(((struct user*) 0)-&amp;gt;u_debugreg[0]) debugreg_t;&amp;lt;br /&amp;gt; #endif
&amp;nbsp;
2.
typedef typeof(((elf_aux_entry*) 0)-&amp;gt;a_un.a_val) elf_aux_val_t;
修改为
#if __cplusplus &amp;gt; 199711L&amp;lt;br /&amp;gt; typedef decltype(((elf_aux_entry*) 0)-&amp;gt;a_un.a_val) elf_aux_val_t;&amp;lt;br /&amp;gt; #else&amp;lt;br /&amp;gt; typedef typeof(((elf_aux_entry*) 0)-&amp;gt;a_un.a_val) elf_aux_val_t;&amp;lt;br /&amp;gt; #endif
&amp;nbsp;
因C&#43;&#43;11中用了decltype来声明类型，所以做了兼容
</content>
    </entry>
    
     <entry>
        <title>[投稿]operator delete异常分析</title>
        <url>https://cppfans.org/1716.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>delete</tag><tag>异常</tag>
        </tags>
        <content type="html"> C 中delete表达式执行的操作是：1，调用析构函数；2，释放对象内存（operator delete(&amp;hellip;)）。
如果父类的析构函数没有声明为virtual函数，且子类中至少存在一个virtual函数，此时将子类的对象地址赋值给父类指针。当对父类的指针执行delete操作时,会调用父类析构函数，然后在释放内存时（即delete表达式执行的操作的2，释放对象内存）出现崩溃。
然而如果子类中不存在一个virtual函数时，执行上面同样的操作就不会出现崩溃。
原因分析如下：
//已知本示例 父类的析构函数应声明为virtual函数。但是由于本程序不需要析构函数执行特殊的操作，所以delete父类指针pB同样可以释放内存，然而引起出乎意料的内//存释放异常。因此对本程序进行如下分析
#include
#include 
using namespace std;
class Base
{
public:
~Base() {printf(&amp;rdquo;\nBase::destructor.&amp;ldquo;);}
};
class Derived: public Base
{
virtual void show()
{
cout&amp;lt;&amp;lt;&amp;ldquo;show&amp;rdquo;&amp;lt;&amp;lt;endl;
}
public:
~Derived(){printf(&amp;rdquo;\nDerived::destructor.&amp;ldquo;);}
};
int main()
{
Base* pB=NULL;
Derived *pD= new Derived;
pB=pD;//此时pD得到的是(unsigned char*)pD 4的地址，所以执行operator delete时会发生崩溃（因为此时把vptr的内存当成了待释放的内存块的大小）。
/*unsigned char *pC=(unsigned char*)pB;
pC=pC-4;
delete pC;//这样就可以释放new Derived分配的内存,而不会发生崩溃。
*/
delete pB;
}
其main函数对应的汇编代码如下(VC6.0)：
int main()
23: {
00401060 push ebp
00401061 mov ebp,esp
00401063 push 0FFh
00401065 push offset __ehhandler$_main (00416a0b)
0040106A mov eax,fs:[00000000]
00401070 push eax
00401071 mov dword ptr fs:[0],esp
00401078 sub esp,64h
0040107B push ebx
0040107C push esi
0040107D push edi
0040107E lea edi,[ebp-70h]
00401081 mov ecx,19h
00401086 mov eax,0CCCCCCCCh
0040108B rep stos dword ptr [edi]
24：Base* pB=NULL;
0040108D mov dword ptr [ebp-10h],0
25: Derived *pD= new Derived;
00401094 push 4
00401096 call operator new (00403780)
0040109B add esp,4
0040109E mov dword ptr [ebp-1Ch],eax //eax保存的是operator new（&amp;hellip;）函数分配的内存的首地址。
004010A1 mov dword ptr [ebp-4],0
004010A8 cmp dword ptr [ebp-1Ch],0 //判断operator new(&amp;hellip;)函数分配内存是否成功。
004010AC je main 5Bh (004010bb)
004010AE mov ecx,dword ptr [ebp-1Ch] //调用Derived::Derived（）函数，ecx保存的是内存指针。
004010B1 call @ILT 35(Derived::Derived) (00401028)
004010B6 mov dword ptr [ebp-28h],eax
004010B9 jmp main 62h (004010c2)
004010BB mov dword ptr [ebp-28h],0
004010C2 mov eax,dword ptr [ebp-28h]
004010C5 mov dword ptr [ebp-18h],eax
004010C8 mov dword ptr [ebp-4],0FFFFFFFFh
004010CF mov ecx,dword ptr [ebp-18h]
004010D2 mov dword ptr [ebp-14h],ecx
26: pB=pD;
004010D5 cmp dword ptr [ebp-14h],0
004010D9 je main 86h (004010e6)
004010DB mov edx,dword ptr [ebp-14h]
004010DE add edx,4
004010E1 mov dword ptr [ebp-2Ch],edx
004010E4 jmp main 8Dh (004010ed)
004010E6 mov dword ptr [ebp-2Ch],0
004010ED mov eax,dword ptr [ebp-2Ch]
004010F0 mov dword ptr [ebp-10h],eax //pB=(unsinged char*)(pD) 4
27:
28: delete pB;
004010F3 mov ecx,dword ptr [ebp-10h]
004010F6 mov dword ptr [ebp-24h],ecx
004010F9 mov edx,dword ptr [ebp-24h]
004010FC mov dword ptr [ebp-20h],edx
004010FF cmp dword ptr [ebp-20h],0
00401103 je main 0B4h (00401114)
00401105 push 1
00401107 mov ecx,dword ptr [ebp-20h]
0040110A call @ILT 20(Base::`scalar deleting destructor
来源：http://blog.chinaunix.net/uid-26807100-id-4246741.html
</content>
    </entry>
    
     <entry>
        <title>linux下升级gcc的方法 - 亲测可用</title>
        <url>https://cppfans.org/1719.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>GCC</tag><tag>Linux</tag><tag>升级</tag>
        </tags>
        <content type="html"> 由于工作主要平台换到了linux上，而linux因为源上没有比较新的gcc，只有4.7，而我们用到了C&#43;&#43;11， 只好自己升级了，升级方法也比较简单，就是耗时间。
1.下载gcc最新的源码包 wget http://gcc.skazkaforyou.com/releases/gcc-4.9.1/gcc-4.9.1.tar.gz
2.解压缩 tar -xf gcc-4.9.1.tar.gz
 cd gcc-4.9.1  4.运行download_prerequisites脚本， ./contrib/download_prerequisites ，这个脚本会自动帮你下载所需要的依赖文件和库
5.建立输出目录，将所有的中间文件都放到该目录，
mkdir gcc_temp
cd gcc_temp
 运行 ../configure --enable-checking=release --enable-languages=c,c&#43;&#43; --disable-multilib
 make -j 8 &amp;amp; make install
  (make参数中的8是CPU线程数)
&amp;nbsp;
相关参考：http://www.21ops.com/linux/14922.html
</content>
    </entry>
    
     <entry>
        <title>使用boost进行CRC64计算</title>
        <url>https://cppfans.org/1713.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>boost</tag><tag>CRC64</tag>
        </tags>
        <content type="html"> 因接入平台，平台提供的是一个字符串的key作为用户标识，而且要用到分布式，所以没法用以前的数据库递增来做用户ID，于是用CRC64来生成uint64_t来作为用户ID，做法也比较简单。如下：
std::map&amp;lt;size_t, size_t&amp;gt; xLongMap; char szTemp[128] = {0}; boost::crc_optimal&amp;lt;64, 0x04C11DB7, 0, 0, false, false&amp;gt; crc; for (uint32_t i = 0; i &amp;lt; 1000000000; &#43;&#43;i) { memset(szTemp, 0, sizeof(szTemp)); sprintf_s(szTemp, &#34;%d%s%s%s&#34;, i, &#34;1a2b3c&#34;, &#34;4d5e6f&#34;, &#34;7g8h9i&#34;); crc.process_bytes(szTemp, strlen(szTemp)); size_t nPos = crc.checksum(); crc.reset(); if (!xLongMap.insert(std::map&amp;lt;size_t, size_t&amp;gt;::value_type(nPos, 0)).second) { std::cout &amp;lt;&amp;lt; &#34;重复了，当前数量：&#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &#34;, 字串为：&#34; &amp;lt;&amp;lt; szTemp &amp;lt;&amp;lt; &#34;, hash pos: &#34; &amp;lt;&amp;lt; nPos &amp;lt;&amp;lt; std::endl; system(&#34;pause&#34;); break; } }  需要包含boost/crc.hpp
测试下来1.3亿没有重复，还是比较给力的。
可惜的是后来也没用到这个算法，因为key中有URL转义，导致有%这样的字符，后来就用了别的方法。
</content>
    </entry>
    
     <entry>
        <title>[转]一致性hash算法 - consistent hashing</title>
        <url>https://cppfans.org/1703.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>consistent hashing</tag><tag>一致性哈希</tag><tag>分布式</tag>
        </tags>
        <content type="html">  via.http://blog.csdn.net/sparkliang/article/details/5279393
一致性 hash 算法（ consistent hashing ） 张亮
consistent hashing 算法早在 1997 年就在论文 Consistent hashing and random trees 中被提出，目前在cache 系统中应用越来越广泛；
1 基本场景 比如你有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache ；
hash(object)%N
一切都运行正常，再考虑如下的两种情况；
1 一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1) ；
2 由于访问加重，需要添加 cache ，这时候 cache 是 N&#43;1 台，映射公式变成了 hash(object)%(N&#43;1) ；
1 和 2 意味着什么？这意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；
再来考虑第三个问题，由于硬件能力越来越强，你可能想让后面添加的节点多做点活，显然上面的 hash 算法也做不到。
有什么方法可以改变这个状况呢，这就是 consistent hashing&amp;hellip;
2 hash 算法和单调性 Hash 算法的一个衡量指标是单调性（ Monotonicity ），定义如下：
单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
容易看到，上面的简单 hash 算法 hash(object)%N 难以满足单调性要求。
3 consistent hashing 算法的原理 consistent hashing 是一种 hash 算法，简单的说，在移除 / 添加一个 cache 时，它能够尽可能小的改变已存在 key 映射关系，尽可能的满足单调性的要求。
下面就来按照 5 个步骤简单讲讲 consistent hashing 算法的基本原理。
3.1 环形hash 空间 考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环，如下面图 1 所示的那样。
图 1 环形 hash 空间  3.2 把对象映射到hash 空间 接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布如图 2 所示。
hash(object1) = key1;
… …
hash(object4) = key4;
图 2 4 个对象的 key 值分布  3.3 把cache 映射到hash 空间 Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash算法。
假设当前有 A,B 和 C 共 3 台 cache ，那么其映射结果将如图 3 所示，他们在 hash 空间中，以对应的 hash 值排列。
hash(cache A) = key A;
… …
hash(cache C) = key C;
图 3 cache 和对象的 key 值分布  &amp;nbsp;
说到这里，顺便提一下 cache 的 hash 计算，一般的方法可以使用 cache 机器的 IP 地址或者机器名作为 hash输入。
3.4 把对象映射到cache 现在 cache 和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，接下来要考虑的就是如何将对象映射到 cache 上面了。
在这个环形空间中，如果沿着顺时针方向从对象的 key 值出发，直到遇见一个 cache ，那么就将该对象存储在这个 cache 上，因为对象和 cache 的 hash 值是固定的，因此这个 cache 必然是唯一和确定的。这样不就找到了对象和 cache 的映射方法了吗？！
依然继续上面的例子（参见图 3 ），那么根据上面的方法，对象 object1 将被存储到 cache A 上； object2 和object3 对应到 cache C ； object4 对应到 cache B ；
3.5 考察cache 的变动 前面讲过，通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时， cache会失效，进而对后台服务器造成巨大的冲击，现在就来分析分析 consistent hashing 算法。
3.5.1 移除 cache
考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象，也即是本来映射到 cache B 上的那些对象。
因此这里仅需要变动对象 object4 ，将其重新映射到 cache C 上即可；参见图 4 。
图 4 Cache B 被移除后的 cache 映射  3.5.2 添加 cache
再考虑添加一台新的 cache D 的情况，假设在这个环形 hash 空间中， cache D 被映射在对象 object2 和object3 之间。这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache （ cache B ）之间的对象（它们是也本来映射到 cache C 上对象的一部分），将这些对象重新映射到 cache D 上即可。
&amp;nbsp;
因此这里仅需要变动对象 object2 ，将其重新映射到 cache D 上；参见图 5 。
图 5 添加 cache D 后的映射关系  4 虚拟节点 考量 Hash 算法的另一个指标是平衡性 (Balance) ，定义如下：
平衡性
平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。
hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，比如在上面的例子中，仅部署 cache A 和 cache C 的情况下，在 4 个对象中， cache A 仅存储了 object1 ，而 cache C 则存储了object2 、 object3 和 object4 ；分布是很不均衡的。
为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义：
“虚拟节点”（ virtual node ）是实际节点在 hash 空间的复制品（ replica ），一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。
仍以仅部署 cache A 和 cache C 的情况为例，在图 4 中我们已经看到， cache 分布并不均匀。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了cache A ； cache C1, cache C2 代表了 cache C ；假设一种比较理想的情况，参见图 6 。
图 6 引入“虚拟节点”后的映射关系  &amp;nbsp;
此时，对象到“虚拟节点”的映射关系为：
objec1-&amp;gt;cache A2 ； objec2-&amp;gt;cache A1 ； objec3-&amp;gt;cache C1 ； objec4-&amp;gt;cache C2 ；
因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。
引入“虚拟节点”后，映射关系就从 { 对象 -&amp;gt; 节点 } 转换到了 { 对象 -&amp;gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如图 7 所示。
图 7 查询对象所在 cache  &amp;nbsp;
“虚拟节点”的 hash 计算可以采用对应节点的 IP 地址加数字后缀的方式。例如假设 cache A 的 IP 地址为202.168.14.241 。
引入“虚拟节点”前，计算 cache A 的 hash 值：
Hash(“202.168.14.241”);
引入“虚拟节点”后，计算“虚拟节”点 cache A1 和 cache A2 的 hash 值：
Hash(“202.168.14.241#1”); // cache A1
Hash(“202.168.14.241#2”); // cache A2
5 小结 Consistent hashing 的基本原理就是这些，具体的分布性等理论分析应该是很复杂的，不过一般也用不到。
http://weblogs.java.net/blog/2007/11/27/consistent-hashing 上面有一个 java 版本的例子，可以参考。
http://blog.csdn.net/mayongzhan/archive/2009/06/25/4298834.aspx 转载了一个 PHP 版的实现代码。
http://www.codeproject.com/KB/recipes/lib-conhash.aspx C语言版本
&amp;nbsp;
&amp;nbsp;
一些参考资料地址：
http://portal.acm.org/citation.cfm?id=258660
http://en.wikipedia.org/wiki/Consistent_hashing
http://www.spiteful.com/2008/03/17/programmers-toolbox-part-3-consistent-hashing/
http://weblogs.java.net/blog/2007/11/27/consistent-hashing
http://tech.idv2.com/2008/07/24/memcached-004/
http://blog.csdn.net/mayongzhan/archive/2009/06/25/4298834.aspx
</content>
    </entry>
    
     <entry>
        <title>[转]国外程序员推荐：每个程序员都应该读的非编程书</title>
        <url>https://cppfans.org/1684.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>程序猿</tag><tag>读书</tag><tag>非编程</tag>
        </tags>
        <content type="html"> 五年前有网友在 Stackoverflow 发帖提问：『程序员应该读哪些非编程方面的书？』。有很多程序员响应，他们在推荐的同时也写下了自己的评语。本文摘编其中 29 本书，下面就按照各书的推荐数排列。另外，本月初我们在伯乐头条也发起了相同的讨论帖《你最喜欢的非编程书是哪一本？》，已有很多的朋友推荐了他们喜欢的书。 1.《银河系漫游指南》by Douglas Adams  推荐数：480 生活，宇宙，所有的一切。 “看在前，思考在后，然后去实践。但是看总是在最前面。否则，你只能看到你以为的样子。大多数的科学家忘记了这一点。”–Wonko的智慧 作为开发者以及曾经的技术支持，从这本书（以及整个系列）中我们能学到一件事情：不要恐慌！！！另外，这本书读起来的舒适程度远胜于你自己存在的问题。– SirDemon 2.《人性的弱点》 by Dale Carnegie 
&amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：322 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065519_l1C4.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 尽管这本书是在1936年首次出版的，书中给出的建议仍然是一如既往的新鲜和适当。不要被它的名字误导。这并不是给未知情的受害者找到自己做人的方式的欺骗性指南，而是关于如何与人相处，如何培养人际关系并充分利用你自己和你的男人（女人）方面很有意义的建议。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 众所周知，技术宅（包括程序员）经常被认为并不是非常的”以人为本（善于交际）“（这是不是一个合理的成见是另一个讨论的话题），那么这本书是一个教你更好的与人打交道方面的无价的资源。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 它温暖，真诚，全面，直白，持续写成。强烈推荐。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 3.《别逗了，费曼先生》 &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：317 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065519_ybxV.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本书将启发每一位读者思考，并回归原始。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 绝对惊奇的一本书！体现思考和与众不同的乐趣。他不只是赞美它，作者的生活本就如此并爱着它。这本书如此有趣。（另外，作者是如此有才，以至于本书深刻并让人着迷。）– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;6707 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/57120/beska&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Beska&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 4.《一九八四》 by George Orwell &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：312 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_8VaE.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 需要买来读吗？哼，我总觉得你会错过它的要点。 – &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;1537 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/44996/applepieisgood&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;ApplePieIsGood&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 5.《哥德尔、艾舍尔、巴赫:集异璧之大成》 by Douglas Hofstadter &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：275 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_uQ7N.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 我读到一半，并认为它被高估了。作者总是重复一些概念但这往往会变得烦人。很多时候我都想朝着作者大吼：”我已经懂了一次又一次！“。 – &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;1716 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/38893/heeen&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;heeen&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 6.《设计心理学》 by Donald A. Norman &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：243 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_UOyO.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 很棒的书，会让你更欣赏很棒的设计！ – &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;562 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/39040/danielb&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Danielb&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 我大概从上个月开始读这本书。真的会让你以不同的眼光（大多是愤怒）来看待事物。 – &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;1776 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/984/jammus&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;jammus&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 7.《搞定：无压工作的艺术》by David Allen &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：230 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_kaYL.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 我一直想读的一本书。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;3429 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/24913/kaz-dragon&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Kaz Dragon&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 我强烈推荐这本。它不会改变你的生活，但是它会帮助你思考解决效率和拖延的问题，而不再是你生活中必须忍受的固有的问题。这种心态的转变让像我这样的懒惰者变得很不一样。 – &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;8383 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/81491/brandon-yarbrough&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Brandon Yarbrough&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 8.《人月神话》by Fred Brooks &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：216 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_nEAs.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这怎么是非编程方面的书呢？ – &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;49068 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/14606/musigenesis&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;MusiGenesis&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 9.《点石成金：访客至上的网页设计秘笈》by Steve Krug &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：200 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_yhh7.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; web应用方面很有意义的一本书。正如作者所说：”常识并不总是显而易见的“。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 10.《人件：生产性项目和团队》by Tom DeMarco and Timothy Lister &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：186 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_dR2a.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本经典的书鼓励我们来思考人的重要性，而不是过程。它里面充满了关于团队建设，生产率以及办公环境的实践建议。它是一本必须读的书，不管是项目管理者还是任意的软件开发参与者。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 搞两本，一本自己读，一本给你的主管。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 11.《禅与摩托车维修的艺术》by Robert M. Pirsig &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：183 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_qETf.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本书讲了很多东西，但是你可以认为它是呈现”神交“在哲学上的意义。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 来自于&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://stackoverflow.com/users/9119/garth-gilmour&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Garth Gilmore&amp;lt;/a&amp;gt;的评论： &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;我敢笃定，这本书教会我的有关软件开发方面的东西远比其他任何一本编程书都多。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;这本书的主线是关于我们对于世界上浪漫主义（艺术）和现实主义（科学/理性）的认知是如何来自于，我们是怎样看待我们周围的环境的。这种理解然后被应用于一般性的任务,比如摩托车维修。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;给出几个这个理论如何应用于编程的例子：&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;如何处理摩托车的”质量理念“以引导进程的章节,也同样适用于编程区域。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;”进取心的陷阱（欲速则不达）“阻止了进程并导致你损坏机器的章节是无价的。解决方案也同样能在修改遗留代码而不引入新的bug中有效果。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;有一个纯粹描述发动机部分的经典章节是无用的（因为它没有任何地方可以让用户提出异议），但应该被每一个被卷入需求分析的人来阅读。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;总之它是一本好书。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; （编注：关于这本书，也可以看看&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://blog.jobbole.com/10309/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;阮一峰的读后感&amp;lt;/a&amp;gt;。） &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 12.《安德的游戏》 by Orson Scott Card &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：183 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_E28z.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本书被高估了，除非你在你还是一个性格阴郁的怪胎少年的时候第一次读它。我知道没有人（包括我自己）在自己年纪比较大的时候读完它会觉得它是一本必读的书。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;10493 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/44065/jmucchiello&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;jmucchiello&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 13.《 Cryptonomicon | 编码宝典 》 by Neal Stephenson &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：158 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_TX7S.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本书讲述的是关于第二次世界大战密码破解的真实故事，今天他的后代致力于计算机的发展（阿兰·图灵在书里单独作为一章来讲解）。是极客必读之书。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 14.《The Visual Display of Quantitative Information》by Edward Tufte &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：158 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_Snd1.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 讨论了如何以图形方式表示不同类型的复杂的数据。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 书中对于PPT的危害简短而又简单的评论也很有优秀。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;4052 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/112614/chet&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Chet&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 15.《风格的要素》by William Strunk &amp;amp; E.B. White &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：156 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_wUMS.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 在看过Joshua Bloch（因《Effective Java》而名言四海）对于此书的推荐后我们也在我们的R&amp;amp;D（研究与开发）图书馆引进了一本： &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本薄薄的小册子宣扬简单性和清晰性的信条,因为它适用于英语散文。如果你谨记在心，它不只会提高你写诗的水平，也会提高你的编码水平。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 在&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.oracle.com/technetwork/java/index.html&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;另一个专访&amp;lt;/a&amp;gt;中，Bloch阐述了为什么它对程序员有好处： &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;我认为阅读斯特伦克和怀 特（作者）会让你成为一名更优秀的程序员，因为好的编程与好的书写都是关于词句的简单性与简洁性的。如果你不知道你要表达什么，你是写不出好的代码和好的 散文的。斯特伦克和怀特里很多的警告在编程中也是类似的。比如，斯特伦克和怀特说：“去掉不必要的语句”。Andy Hunt 和Dave Thomas（“实效程序员”）也说：“不要重复造轮子”。斯特伦克和怀特说：“要推敲和重写”，马丁·福勒说：“要重构”。还有等等诸如此类的。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;现在，我个人认为《风格的要素》这本书中很多建议有点过时了，因为英语的使用出现了演化（比如，现在以”Hoverever”作为一个句子的开头是完全可以的，或者使用hopefully代替“I hope”）。但是大多数的地方我还是同意作者的，而且很享受阅读此书。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.codinghorror.com/blog/archives/001184.html&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;&amp;lt;span style=&amp;#34;color: #888888;&amp;#34;&amp;gt;这里&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;是阿特伍德对于《风格的要素》不得不说的更多的信息。也许它是比约书亚·布洛克说的更好的 更好的阅读指南。&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 16.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.com/dp/0441013597/?tag=job0ae-20&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;沙丘魔堡&amp;lt;/a&amp;gt;》by Frank Herbert &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：152 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_SHzs.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 《沙丘魔堡》是科幻小说的顶峰。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 17《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B0011CT3HW/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B0011CT3HW&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;孙子兵法&amp;lt;/a&amp;gt;》 &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这个就不需要介绍了 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 18.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/0241953189/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=0241953189&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;雪崩&amp;lt;/a&amp;gt;》By Neal Stephenson &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：120 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_ZMcI.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 最近我在某人的推荐下阅读了这本书，我非常失望，它都过时了。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;7901 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/6716/ian-dickinson&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Ian Dickinson&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 19.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B00AYBWRLA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B00AYBWRLA&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;爱丽丝漫游奇境记&amp;lt;/a&amp;gt;》by Lewis Carroll &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：114 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065520_FMkf.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; “《爱丽丝梦游仙境》是门外汉最好的编程书”，是因为对门外汉来说，对于任何事物它都是最好的。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;16337 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/131930/jeremy-friesner&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Jeremy Friesner&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 20.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.vavatch.co.uk/books/asimov/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;基地系列&amp;lt;/a&amp;gt;》by Isaac Asimov’s &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：114 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_0Xdv.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 很棒的图书。我发现这本书里的理论像是通过通过混沌理论来介绍社会学。关于社会发展很好的阐述。简单有趣，就是有点厚。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;6707 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/57120/beska&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Beska&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 21.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B0069HL656/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B0069HL656&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;魔戒&amp;lt;/a&amp;gt;》 &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：114 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_yq5s.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 除了它之一本科幻巨作外，这也是(几乎所有)的现代幻想小说的基础。（而且，对于一群计算机程序员来说更有意义的是，它也是龙与地下城的核心启示之一） &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 退几步说,为了能在午餐的时候加入到话题中，每个程序员必读的三本书是指环王,沙丘,银河系漫游指南。（这个有点夸张） &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 如果你只是看过电影，那么试着去读下书。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 从科技的角度，书里的不重要的人物能对世界有深刻而积极的影响的基本信息，以及他们周边的组织让大公司的编程看到了希望。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 我需要补充的是团队协作是很重要的，甚至是在团队里有些人有破坏作用，有的人很自私或者不能融入团队，当到了最后的期限或者索隆即将出现的时候，你仍然可以让他们做的很好而扭转战局。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;3323 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/26196/anonymous-coward&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;anonymous coward&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 22.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B00BOELK6E/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B00BOELK6E&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;平面国&amp;lt;/a&amp;gt;》by Abbott &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：111 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本书太旧了，以至于它现在都不出版了。你可以在这里阅读全书：&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.geom.uiuc.edu/~banchoff/Flatland/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34;&amp;gt;geom.uiuc.edu/~banchoff/Flatland&amp;lt;/a&amp;gt; – &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;34581 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/2635/simucal&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Simucal&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 23.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B00116OR88/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B00116OR88&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;时间简史&amp;lt;/a&amp;gt;》by Stephen Hawking &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：104 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_SAnb.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 24.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://en.wikipedia.org/wiki/The_Screwtape_Letters&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;地狱来鸿&amp;lt;/a&amp;gt;》by C. S. Lewis &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：83 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_D9nH.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 想象一个恶魔在编写一个关于人的程序….. &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 25.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B00DUNOVD6/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B00DUNOVD6&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;神经漫游者&amp;lt;/a&amp;gt;》By William Gibson &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：74 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_GSf5.jpg&amp;#34; alt=&amp;#34;&amp;#34; width=&amp;#34;217&amp;#34; height=&amp;#34;360&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 他创造了网络空间这个词，它延伸的三部曲是我想当一个编码仔的原因。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 具有讽刺意味的是，他写的这些书打击了技术迷，并渗透到社会的今天（和未来）– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;6505 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/64976/j-steen&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;J. Steen&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 26.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/0099470438/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=0099470438&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;深夜小狗神秘习题&amp;lt;/a&amp;gt;》by Mark Haddon &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：73 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_EBc8.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 它给出了有关你古怪同事的一些看法。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本书真的很不错。他帮助我认识了孤独症和阿斯伯格综合症患者（作者为了写书和孤独症患者一起工作了一些时间，从我和一些阿斯伯格综合症患者儿童的相处来看，它非常真实）。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;1327 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/46523/mongoose&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Mongoose&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 27.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B00FDJWLB4/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B00FDJWLB4&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;仿生人会梦见电子羊吗&amp;lt;/a&amp;gt;》by Philip K. Dick &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：66 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 作者写的其他东西当然也很棒。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 他的离奇古怪的故事肯定帮助人们有更多的思考。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 对于程序员来说是奇幻的一本书和一部电影。而且，对于PKD的其他书（也不尽然只是书，还有必须的电影，比如《致命报酬》）也很不错。不过显然总记得是一个很棒的电影。– &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; title=&amp;#34;615 reputation&amp;#34; href=&amp;#34;http://stackoverflow.com/users/88218/troy-nichols&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Troy Nichols&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 28.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B007Q2XXXG/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B007Q2XXXG&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;交互设计之路&amp;lt;/a&amp;gt;》by Alan Cooper &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：66 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_ZhXb.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 它讲述的用正确的语言来谈论项目–用故事（和角色模型）代替产品特点来谈论我们需要认识到的东西。还有一些在交互设计以及相关活动上的强调，要提供用户需要的而不是要求的。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;h2 style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 29.《&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.amazon.cn/gp/product/B00B4NTCT2/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3200&amp;amp;creativeASIN=B00B4NTCT2&amp;amp;linkCode=as2&amp;amp;tag=vastwork-23&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;高效能人士的7个习惯&amp;lt;/a&amp;gt;》by Stephen Covey &amp;lt;/h2&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 推荐数：61 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;http://static.oschina.net/uploads/img/201407/16065521_jvdV.jpg&amp;#34; alt=&amp;#34;&amp;#34; /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 如果你没有读过这本，你会错过很多你潜在的能力–最初摘自John Channing的文章。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 编辑：你可以获取它的&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://www.audible.com/pderror&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;免费有声读物&amp;lt;/a&amp;gt;。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 来自&amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://stackoverflow.com/users/8217/julie&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Julie&amp;lt;/a&amp;gt;的评论： &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 这本书具有普世价值–不仅仅是对于软件开发者来说。鉴于你做很多事来帮助你处理日常的事务，7个习惯能帮助你保持高效的生活和一个你需要转化为日常细节的普世方法论。这本书是从这方面考虑来处理事情的完美补充。 &amp;lt;/p&amp;gt; &amp;lt;p style=&amp;#34;color: #000000;&amp;#34;&amp;gt; 原文链接： &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://stackoverflow.com/questions/38210/what-non-programming-books-should-programmers-read&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;Stackoverflow&amp;lt;/a&amp;gt; 翻译： &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://blog.jobbole.com/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;伯乐在线 &amp;lt;/a&amp;gt;- &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://blog.jobbole.com/author/abell123/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;abell123&amp;lt;/a&amp;gt;&amp;lt;br /&amp;gt; 译文链接： &amp;lt;a style=&amp;#34;color: #3e62a6;&amp;#34; href=&amp;#34;http://blog.jobbole.com/72365/&amp;#34; target=&amp;#34;_blank&amp;#34; rel=&amp;#34;nofollow&amp;#34; &amp;gt;http://blog.jobbole.com/72365/&amp;lt;/a&amp;gt; &amp;lt;/p&amp;gt;</content>
    </entry>
    
     <entry>
        <title>Compile python to exe</title>
        <url>https://cppfans.org/1676.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>cx-freeze</tag><tag>py2exe</tag><tag>python</tag>
        </tags>
        <content type="html"> When we write a python file, we can use command line &amp;ldquo;python test.py&amp;rdquo; to execute this file, but we need python environment, when publish programs, most user don&amp;rsquo;t have python in their PC, so sometimes we need to transfer python to executable file, like exe.
&amp;nbsp;
Here are two methods to make it.
Suppose our code like below:
#encoding:utf-8 #test.py if __name__ == &#34;__main__&#34;: print(&#34;Hello world!&#34;) &amp;nbsp;
1. py2exe
project link: http://sourceforge.net/projects/py2exe/
latest version just support python 2.6
Install py2exe
Create a python file named setup.py, code is:
#encoding=utf-8 # test.py from distutils.core import setup import py2exe setup(console=[&#34;test.py&#34;])  then execute in command:
python setup.py py2exe
It will generate a dir named dist, dir dist include test.exe, python26.dll,library.zip, etc.
&amp;nbsp;
2.python.cx_freeze
project link: http://sourceforge.net/projects/cx-freeze/
support python version 2.x 3.x
install it
Create a python file named setup.py, code is:
# encoding:utf-8 from cx_Freeze import setup, Executable setup( name = &#34;test&#34;, version = &#34;0.1&#34;, descrīption = &#34;This is a test&#34;, executables = [Executable(&#34;test.py&#34;, icon = &#34;test.ico&#34;)]) Now you can see, cx_freeze can set an icon for your exe, default it based console application, also you can set application based win32gui like this
executables = [Executable(&amp;quot;test.py&amp;quot;, base=&amp;quot;Win32GUI&amp;quot; icon = &amp;quot;test.ico&amp;quot;)])
then execute in command
python setup.py build
build is a dir, it include some *.pyd, python26.dll, library.zip, test.exe, etc.
&amp;nbsp;
Then you can publish your application for user.
</content>
    </entry>
    
     <entry>
        <title>使用redis五倍加速WP博客</title>
        <url>https://cppfans.org/1665.html</url>
        <categories>
          <category>Wordpress</category><category>技术文章</category>
        </categories>
        <tags>
          <tag>redis</tag><tag>wordpress</tag><tag>加速</tag><tag>缓存</tag>
        </tags>
        <content type="html"> 
已经换了linode-vps有一段时间了，但是博客的访问速度一直不理想，使用了xcache和eAccelerator，但是速度还是不给力，于是想试试redis这个kv缓存服务，增加了之后，速度提升了5、6倍，下面是使用redis加速wordpress博客的过程。
1.在vps主机上安装redis
①我用的LNMP包，里面自带了redis，执行 ./redis.sh 就可以自动安装并加入自启动
②单独安装redis-server
# apt-get install redis-server
启动redis-server，并加入自启动项目(具体方法请自行查阅，因为部分linux上的方法是不同的)
&amp;nbsp;
2.在wordpress中增加redis-Server的PHP客户端
大家都推荐使用predis.php(下载地址)，将predis.php上传到wp的根目录
&amp;nbsp;
3.下载wp使用redis的新首页
index-with-redis.php(下载地址)，将原来wp中的index.php备份，修改index-with-redis.php为index.php
&amp;nbsp;
4.根据个人需求修改index-with-redis.php中的参数&amp;lt;br /&amp;gt; // change vars here&amp;lt;br /&amp;gt; $cf = 1; // set to 1 if you are using cloudflare&amp;lt;br /&amp;gt; $debug = 0; // set to 1 if you wish to see execution time and cache actions&amp;lt;br /&amp;gt; $display_powered_by_redis = 1; // set to 1 if you want to display a powered by redis message with execution time, see below&amp;lt;br /&amp;gt; 
5.上传到wp根目录，刷新网页即可
注意：如果wp升级了，那上述步骤中的两个文件需要重新设置一下
</content>
    </entry>
    
     <entry>
        <title>LNMP折腾小记</title>
        <url>https://cppfans.org/1653.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>linode</tag><tag>LNMP</tag><tag>php</tag><tag>VPS</tag>
        </tags>
        <content type="html"> 两天前刚刚买了linode的$20/mo 的vps，试了一下还是蛮爽的。因为Ubuntu Server实在太不熟悉了，所以装上之后又狠心换成了了debain7.5 x64的系统，2核2G的配置对我几个站来说够用了。
这次决定用LNMP集成包，因为nginx相对轻巧一些，更适合我的小站用，安装过程就不多说了，lnmp.org有详细的说明，主要说几个坑点。
&amp;nbsp;
1.执行./vhost.sh时多个域名的处理
官方写的是用空格分开即可，但是我发现不是每次都能成功的。空格分隔后$domain变量会无法识别，导致出现了vhonst/domain.conf无法创建的问题，就会导致域名绑定的web文件夹无法访问到，永远是default文件夹
&amp;nbsp;
2.打开网站后，空白
这个问题纠结了很久，开始以为是iptables的问题，找了挺多资料的，各种关iptables，不料却发现debain默认是不装iptables的，但是我却搜到了iptables的文件，很奇怪。
用chrome -&amp;gt; 审查元素 -&amp;gt; network查看了下，原来是500错误，修改php.ini中的 display_errors = On之后，发现提示无法识别scandir()函数，所以还是php的问题，这个函数被禁用了，php.ini中搜索 disable_functions，删掉scandir，刷新网站，发现可以上去了，没任何问题
&amp;nbsp;
坑点还在继续发掘中，欢迎大家交流。
&amp;nbsp;
PS；C&#43;&#43;爱好者博客暂时还没搬到vps上，因为我还打算把C&#43;&#43;爱好者论坛解析到cnboost.net上，但这个域名是朋友的，他还没解析过来，所以暂时还没搬，这周会慢慢都搬过去，如果出现短暂不能访问，请谅解。
</content>
    </entry>
    
     <entry>
        <title>[转]Leveldb实现原理</title>
        <url>https://cppfans.org/1652.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>leveldb</tag><tag>实现原理</tag>
        </tags>
        <content type="html">  看leveldb的时候搜到这篇文章，觉得很不错，就转过来了，原文地址：http://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html
&amp;nbsp;
郑重声明：本篇博客是自己学习 Leveldb 实现原理时参考了郎格科技系列博客整理的，原文地址：http://www.samecity.com/blog/Index.asp?SortID=12，只是为了加深印象，本文的配图是自己重新绘制的，大部分内容与原文相似，大家可以浏览原始页面 :-)，感兴趣的话可以一起讨论 Leveldb 的实现原理！** **
LevelDb日知录之一：**LevelDb 101 **
说起LevelDb也许您不清楚，但是如果作为IT工程师，不知道下面两位大神级别的工程师，那您的领导估计会Hold不住了：Jeff Dean和Sanjay Ghemawat。这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。
Jeff Dean其人：http://research.google.com/people/jeff/index.html，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。
Sanjay Ghemawat其人：http://research.google.com/people/sanjay/index.html，Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。
LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C&#43;&#43; 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。
LevelDb有如下一些特点：
首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。
其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。
再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。
另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。
除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。
LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。至于为何是这样，看了我们后续推出的LevelDb日知录，估计您会了解其内在原因。
LevelDb日知录之二：整体架构 LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。
本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb日知录后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。
LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：
图1.1：LevelDb结构  从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。
LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。
Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。
当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。
SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。
SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意：
图2.1：Manifest存储示意图 图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。
Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。
以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb日知录接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。
LevelDb日知录之三：log文件 上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。
下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。
图3.1 log文件布局  在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理，图3.2显示了一个记录在LevelDb内部是如何表示的。
&amp;nbsp;
图3.2 记录结构 记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。 如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。 假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。 LevelDb日知录之四：SSTable文件 SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。
本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb日知录之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。
LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。
图4.1 .sst文件的分块结构 　图4.1展示了一个.sst文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。
以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了.sst文件的内部逻辑解释。
图4.2 逻辑布局 　从图4.2可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。
LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。
图4.3 数据索引 图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i&#43;1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i&#43;1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i&#43;1的第一个字段则是“zoo”，即数据块i&#43;1的最大Key。 文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。 图4.4 Footer 　上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。
图4.5 数据Block内部结构 　从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。
“重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i&#43;1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i&#43;1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i&#43;1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。
图4.6 记录格式 　在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。
上面讲的这些就是.sst文件的全部内部奥秘。
LevelDb日知录之五：MemTable详解 LevelDb日知录前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。
LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。
需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。
SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。
SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。
关于SkipList的详细介绍可以参考这篇文章：http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html，讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。
SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。
LevelDb日知录之六 写入与删除记录 在之前的五节LevelDb日知录中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。
本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。 图6.1 LevelDb写入记录  图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。
从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。
levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。
LevelDb日知录之七：读取记录 LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。
假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。
图7-1 LevelDb读取记录流程 　LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。
那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L&#43;1找到同一个key，level L的信息一定比level L&#43;1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。
为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=&amp;ldquo;www.samecity.com&amp;rdquo; value=&amp;ldquo;我们&amp;rdquo;},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=&amp;ldquo;www.samecity.com&amp;rdquo; value=&amp;ldquo;69同城&amp;rdquo;}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=&amp;ldquo;www.samecity.com&amp;rdquo;,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。
前文有讲：对于SSTable文件来说，如果同时在level L和Level L&#43;1找到同一个key，level L的信息一定比level L&#43;1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L&#43;1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L&#43;1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么&amp;hellip;&amp;hellip;..也许以后会知道的），也就是说，您看到的现在的Level L&#43;1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L&#43;1的数据要新鲜。
SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。
最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。
从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。
LevelDb日知录之八：Compaction操作 前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。
levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。
LevelDb包含其中两种，minor和major。
我们将为大家详细叙述其机理。
先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。 图8.1 minor compaction  从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。
当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&amp;gt;0），将其和高一层级的level&#43;1的SSTable文件合并，这就是major compaction。
我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。 levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。 如果选好了level L的文件A和level L&#43;1层的文件进行合并，那么问题又来了，应该选择level L&#43;1哪些文件进行合并？levelDb选择L&#43;1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。 也就是说，选定了level L的文件A,之后在level L&#43;1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。  图8.2说明了这一过程。
图8.2 SSTable Compaction 　Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L&#43;1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L&#43;1层数据文件，之前的L层文件和L&#43;1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L&#43;1层文件记录的合并过程。
那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。
&amp;nbsp;
LevelDb日知录之九 levelDb中的Cache 书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。
levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。
图9.1 table cache  图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。
比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。
图9.2 block cache  Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。
如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。
LevelDb日知录之十 Version、VersionEdit、VersionSet {.western} 　Version 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做&amp;rdquo;current&amp;rdquo; version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？
当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。
当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。
　VersionSet 是所有Version的集合，管理着所有存活的Version。
　VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。
Version0 &#43;VersionEdit&amp;ndash;&amp;gt;Version1
VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。
leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。
比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。
leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。
注：博文参考了郎格科技博客：http://www.samecity.com/blog/Index.asp?SortID=12
</content>
    </entry>
    
     <entry>
        <title>leveldb小尝试</title>
        <url>https://cppfans.org/1651.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>google</tag><tag>K/V</tag><tag>leveldb</tag><tag>NoSQL</tag><tag>数据库</tag>
        </tags>
        <content type="html"> 最近项目挺忙的，也没什么时间写博客了，这篇也是工作中遇到mysql经常同时请求数据就CPU暴高，就看了下nosql，redis已经有同事尝试了，所以我就来试试leveldb。
leveldb是google开源的一个高效率的K/V数据库，地址：https://code.google.com/p/leveldb/
&amp;nbsp;
暂时不支持windows，虽然有windows分支，但是已经两年每更新了，按照网上的方法，折腾了一下，还是有几个函数无法链接，所以打算延后再折腾。
linux下就方便很多了，直接下载源码，make all编译，就会生成a和so文件，我用的是a文件
写了下面的一个例子，还是比较顺利
#include &amp;lt;iostream&amp;gt; #include &#34;leveldb/db.h&#34; int main() { leveldb::DB* db; leveldb::Options options; options.create_if_missing = true; // 如果没有则创建 leveldb::Status status = leveldb::DB::Open(options, &#34;/home/test/test_leveldb/testdb&#34;, &amp;db); std::string key = &#34;key123&#34;; std::string value = &#34;value123&#34;; status = db-&amp;gt;Put(leveldb::WriteOptions(), key, value); assert(status.ok()); std::string value1; status = db-&amp;gt;Get(leveldb::ReadOptions(), key, &amp;value1); assert(status.ok()); std::cout &amp;lt;&amp;lt; &#34;get, key1:&#34; &amp;lt;&amp;lt; key &amp;lt;&amp;lt; &#34; value1:&#34; &amp;lt;&amp;lt; value1 &amp;lt;&amp;lt; std::endl; std::string key1 = &#34;key456&#34;; status = db-&amp;gt;Put(leveldb::WriteOptions(), key1, value1); assert(status.ok()); status = db-&amp;gt;Delete(leveldb::WriteOptions(), key1); assert(status.ok()); delete db; return 0; }  结果不贴了，各位自己去试试就知道了。
在上面创建的文件夹里会有好几个文件，这里面就是记录了你的持久化数据。
linux是30秒才会将缓冲区的数据刷出到硬盘里，而且leveldb使用了mmap，所以可能会丢数据，看了下ideawu的博客里有写到，leveldb的作者认为 sync every second 机制应该是用户自己实现的，而不是leveldb提供，所以他基于leveldb写了一个SSDB，兼容redis协议，而且做到了每秒钟同步输出到硬盘，这样丢数据的几率就会大大降低，github地址：https://github.com/ideawu/ssdb
</content>
    </entry>
    
     <entry>
        <title>[转载]PM和程序员（RD）的相处之道－－写给那些血气方刚的产品经理（PM）</title>
        <url>https://cppfans.org/1645.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>PM</tag><tag>团队建设</tag><tag>沟通</tag><tag>程序猿</tag><tag>项目经理</tag>
        </tags>
        <content type="html"> 写在前面：
虽然我是程序猿，不是PM，但觉得这篇文章讲的思维方式比较好，适合团队内沟通，所以转了过来。
&amp;nbsp;
转载正文：最近有位刚做 PM（产品经理）的小伙跑来跟我控诉，说公司技术部的 RD 们（程序员）个个不给力。需求过了千百遍还是理解错，或者就是简单回一句“做不了”，表情如死灰。这位 PM 血气方刚，张牙舞抓，脑子里总有一千万个新产品需求的想法扑腾着。他咄咄不停的抱怨 RD 们不配合，能力差，懒惰，没思考能力，没品位，顺带连抠脚味儿太大这种事也强烈谴责了。“擦，老子明天就去学编程！” 哎，我发现 PM 们都特喜欢说这句无比励志的话呢！面对他，我的心突然惆怅起来。几年前的自己也差不多是这个模样，懵懂如白纸，但谁又知道这样的 PM，在很多 RD 的眼里就是个傻逼吧。身为一位女性 PM，我至今为止并肩合作过的 RD 团队超过 8 组共 200 多人（动荡曲折的职业生涯啊），受过的委屈流过的泪就不在这里赘述了，打算留着以后写小说。今天我只想浅谈一些自己总结的 PM 与 RD 相处之道，所谓人艰不拆，希望大家看完后能更理解彼此“都不容易”的立场。
PM眼里的RD分成两种：能沟通的，和不能沟通的。后者占90％。（呵呵）
如果你跟我一样，是个没有技术背景的 PM，估计你会觉得世界上 “不能沟通的 RD” 占九成以上。难道不是吗！每当你斗志昂扬讲完一个伟大的产品计划，期待看到 RD 激动的眼神，却发现他们真的一点儿不兴奋。给面子的 RD 会干巴巴的问：“什么时候要 什么时候开始 设计稿确定了没 产品文档写完整了没。” 不给面子的 RD 则会当场质疑你，“这个新功能你到底想清楚了吗？！老板又风花雪月拍脑子了吧？！这么做有数据依据吗？！做过市场调研吗？！老用户会因此流失吗？！能保证上线后不再改了吗！？@$%^^%%$$@% #$%^^% ” 真的是没法儿做朋友啊！
曾经有一个自以为很牛掰但其实能力已经跟不上时代的 RD 总监，在 kickoff 会议上把我所有的需求都推翻了，让我差点在十几个老男人面前哭鼻子。话说人在经历苦难后，要么变乖，要么变坏。这种迫切想要搞定 RD，让他们听命于我的心情，实在太强烈，于是我学会了通过非正规途径收买 RD 的心－－比如请他们吃 KFC 啦，陪他们聊黄色笑话啦，穿低胸装秀黑丝大腿啦。在这些努力之下，我和 RD 的关系改善很多，他们开始敞开心扉，解释他们对于新需求的负面情绪到底从何而来：有时是因为实在忙不过来，有时是因为实在无法理解这个功能有什么意义（至少他们自己肯定不会用），有时是因为 PM 不但不调解现有项目的优先级，反而还每天做梦，想些有的没的，让他们极为恼火。而负面情绪最大的根源，则是他们对这个项目失去了信心，觉得反复改版却一直没有大的突破，老板和 PM 都应该去吃 shi。
正当我沾沾自喜，认为自己靠美胸美腿赢得了这场战役时，一个 Ruby 程序员幽幽的跟我说 “我好喜欢你的门牙。” （鸦。。。你们果然是无法沟通的生物。。。）
RD眼里的PM也分成两种：有脑子的，和没脑子的。后者占90％。（呵呵呵）
没脑子的 PM，RD 们是打心底森森嫌弃你的。嫌弃你的理由可能有以下三点，欢迎对号入座，我们一起舔伤口：
嫌弃理由1：你没有自己的想法。听清楚哦，我说的是 RD 们“认为”你没有自己的想法。这个话题实在很辛酸，哪个 PM 会没有自己的想法呢，就是想法多的溢出了脑门儿才跑来当 PM 的啊魂淡！！但是 PM 的生存环境无比艰辛，很多决定都身不由己（尤其当你有一个心思活络的老板时）。于是，有些 PM 选择推卸责任，两手一摊 “老板说必须做” ，急着撇清关系强调只有老板是傻逼哦我不是哦。此言一出，你在 RD 心里的形象全毁。
PM 必须是产品的灵魂，无论老板决定闹哪样，你都要把这个决定翻译成大家能接受的理由，建立你自己的口碑和信任。在跟 RD 沟通的时候，不要说“我和老板争论了很久他就是不听我的”，这样更凸显你的无能；也不要撒谎说“其实我觉得老板的想法挺好的”然后硬掰些白痴的理由，这样显得你特别虚伪。比较好的应对方式是开诚布公，说你自己真实的想法，如果你觉得老板真是玩过火，也要解释下老板为何会有这样的执念（是被投资人逼的，还是被老婆逼的，还是看到竞争对手做的什么事情眼红了想抄袭），然后安慰体恤下 RD 们的辛苦，并表现出和他们同甘共苦的决心。
嫌弃理由2：你风花雪月没有逻辑。都说能做出牛逼产品的 PM 要感性和理性兼备，因为牛逼的产品能直戳人性，满足用户多层次的生理和情感需求，这就要求 PM 对生活细节敏感，情感丰富。可是情感丰富的 PM 通常思维比较跳跃（艺术家嘛都这样），情绪波动幅度巨大，郁闷时会在阳台发呆抽一下午的烟，兴奋时连坐在马桶上都拿着手机写文档，这样的节奏 RD 们真心吃不消。他们觉得你丫的赶紧吃点儿脑残片吧！（插播吐槽：我的上一篇文章发布后，就有人建议我服食脑残片！）因此，论起 PM 的自我修养，你必须有收放自如的情感，还得有理性的逻辑思维去支撑起每一次的灵感乍现。
你可以问自己三个问题：一、这个功能是否服务于产品的主线业务，比如一个听歌的软件是否要有日间／夜间模式切换？如果只是锦上添花，使用场景不足整体的 10％，那劝你还是等自己学会写代码以后在家做着玩吧；二、这个功能的技术实现成本有多大，如果用工时或天数来预计工作量不够直观，请去 HR 部门问一下 RD 全员每天的工资总额，再乘以所需要的开发时间，哈，这个金额应该足以让你好好思考“需求性价比”这件事了！（这招在创业公司尤为实用）三、这个功能的效果是否能被评估，这样至少你能检验自己的判断是否正确，无论如何都能积累宝贵的经验。
嫌弃理由3：不信任RD的能力。呵呵呵呵呵呵，说起这个真是百感交集。每一个有血有泪的日子里都在重复上演这样的剧集：PM 问 RD 这个功能要做多久，RD 说至少 3 周，PM 于是去问自己做技术的好基友 “真的需要 3 周吗？”，基友拍桌子说 “这有什么难的，换了我 3 天就搞定！” 然后两人忿忿不平的拍案皱眉，开始讨论公司里的 RD 们到底是能力差还是在偷懒。我曾经也这样，因为不懂技术害怕被骗，于是勾搭各种民间技术大牛让他们给我做狗头军师。军师们为了维护自己伟岸的形象，通常会拍胸脯各种夸大各种装逼。更糟糕的是，军师们也变相破坏了我和 RD 之间原本就已经很稀薄的信任。（哦多么痛的领悟～～～）
最后，RD 眼里的 RD，只有一种：比自己牛的人。
剩下那些能力不如自己的，他们的存在早已消失散尽在雾霾里了。
…………………………………….. 我是口沫横飞的分割线…………………………………….
让RD觉得你很优秀的方法…
 眼观四路耳听八方，知识渊博，掌握行业内的各种动态，分析市场趋势，没事就盯着友盟的数据看，各种国外新推出的牛逼产品统统用起来。RD 们会觉得你什么都知道，那你的判断八成是靠谱的。
 混对圈子，积攒几个牛逼人脉，难得和大人物有饭局的时候一定拍照发朋友圈，时不时去知乎回答些问题，去各种活动刷脸，撮合各种合作，尽一切可能把公司推到聚光灯下，这样也更容易招聘到优秀的程序员，产生良性循环。RD 们大多不喜欢抛头露面，所以他们会觉得你的付出无可取代（不然他们老觉得 PM 每天看看文章聊聊天，简直是悠闲的废物）。
 无论是口述的需求还是撰写的文档，文字和原型图的呈现都要有逻辑，有条理，最好用写代码的思路来写产品文档，功能细节上的逻辑处理无一遗漏，实乃 RD 们的心头好。
 在老板责问为什么还没上线的时候，冲上前去说，“都是我的错，前几天又改了个需求”。
 在 RD 们被各种部门的需求同时袭击的时候，为他们安排最合理的优先级，并承诺担起一切后果（包括被某部门主管批斗责骂等）。
 招到漂亮的实习生妹子给 RD 们养眼。
 给他们加薪，给他们加薪，给他们加薪。
  文章的最后，我想对所有还在拼搏的产品经理们说，就算你的行业环境不断限制你的创新和畅想，就算你身边的程序员总是打压你的积极性，攻击你的决策和判断，就算你觉得全世界都没有人肯定你的努力，没有人理解你的无奈，你都不可以放弃。勿忘理想，勿忘初心。你们是美好未来的希望
转自：36氪
</content>
    </entry>
    
     <entry>
        <title>share_ptr的几个注意点</title>
        <url>https://cppfans.org/1641.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>share_ptr</tag><tag>智能指针</tag>
        </tags>
        <content type="html"> 智能指针在boost中很早就有了，在tr1上也很早，但是没怎么用，后来0x标准出来之后，智能指针变成了标准库，所以现在用起来就不区分boost和std了。
主要说下share_ptr的几个注意点，待补全。
1.环状的链式结构可能会形成内存泄露
例如：
class BaseClass; class ChildClass; typedef std::shared_ptr&amp;lt;BaseClass&amp;gt; BaseClassPtr; typedef std::shared_ptr&amp;lt;ChildClass&amp;gt; ChildClassPtr; class BaseClass { public: ChildClassPtr childClass; protected: private: }; class ChildClass { public: BaseClassPtr baseClass; protected: private: }; int _tmain(int argc, _TCHAR* argv[]) { BaseClassPtr base(new BaseClass()); ChildClassPtr child(new ChildClass()); base-&amp;gt;childClass = child; child-&amp;gt;baseClass = base; system(&#34;pause&#34;); return 0; }  2.多线程环境下使用代价更大。
因为share_ptr内部有两个数据成员，一个是指向对象的指针 ptr，另一个是 ref_count 指针，指向堆上的 ref_count 对象，读写操作不能原子化，（具体的结构图可以查看 陈硕的文章《为什么多线程读写 shared_ptr 要加锁？》）所以多线程下要么加锁，要么小心翼翼使用share_ptr。
例如：
class Test { public: Test() {} ~Test() {} // ... protected: private: }; void func(std::shared_ptr test_ptr) { // 大量使用test_ptr std::shared_ptr temp_ptr = test_ptr; } int _tmain(int argc, _TCHAR* argv[]) { std::shared_ptr sp(new Test()); boost::thread th1(std::bind(&amp;func, sp)); boost::thread th2(std::bind(&amp;func, sp)); th1.join(); th2.join(); return 0; }  上面的代码不知道什么时候可能就宕了，而且不容易找到问题，这个时候你就得硬看代码了。
你也可以通过使用weak_ptr来解决这个问题，例如上述例子可以修改为：
class Test { public: Test() {} ~Test() {} // ... protected: private: }; void func(std::weak_ptr test_ptr) { // 大量使用test_ptr std::weak_ptr temp_ptr = test_ptr; } int _tmain(int argc, _TCHAR* argv[]) { std::shared_ptr sp(new Test()); std::weak_ptr wp(sp); boost::thread th1(std::bind(&amp;func, wp)); boost::thread th2(std::bind(&amp;func, wp)); th1.join(); th2.join(); return 0; }  weak_ptr是一种可构造可赋值的不增加引用计数来管理share_ptr的智能指针，它可以非常方便的通过weak_ptr.lock()转为share_ptr，通过weak_ptr.expired()来判断智能指针是否被释放，还是非常方便的。条目1中的例子使用weak_ptr就可以解决问题
3.share_ptr包装this的时候使用enable_shared_from_this
class Test { public: Test() {} ~Test() {} std::shared_ptr get_ptr() { return std::shared_ptr(this); } // ... protected: private: }; int _tmain(int argc, _TCHAR* argv[]) { Test t; std::shared_ptr t_ptr(t.get_ptr()); return 0; }  这样就会发生析构两次的问题，可以使用enable_shared_from_this来做共享，上面例子修改为
class Test : public std::enable_shared_from_this&amp;lt;Test&amp;gt; { public: Test() {} ~Test() {} std::shared_ptr get_ptr() { return shared_from_this(); } // ... protected: private: }; int _tmain(int argc, _TCHAR* argv[]) { std::shared_ptr t_ptr(new Test()); t_ptr-&amp;gt;get_ptr(); return 0; }  4.share_ptr多次引用同一数据会导致内存多次释放
int _tmain(int argc, _TCHAR* argv[]) { int* int_ptr = new int[100]; std::shared_ptr s_int_ptr1(int_ptr); // do something std::shared_ptr s_int_ptr2(int_ptr); return 0; }  而且C&#43;&#43;之父对share_ptr的初衷是：“shared_ptr用于表示共享拥有权。然而共享拥有权并不是我的初衷。在我看来，一个更好的办法是为对象指明拥有者并且为对象定义一个可以预测的生存范围。”
&amp;nbsp;
总结：智能指针虽然好，但是还需要谨慎的使用，C&#43;&#43;的新特性很不错，但是写C&#43;&#43;代码还是得非常注意，各位共勉吧
</content>
    </entry>
    
     <entry>
        <title>[转载]想提升工作效率，就別再做这七件事</title>
        <url>https://cppfans.org/1644.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>工作</tag><tag>效率</tag><tag>自动化</tag>
        </tags>
        <content type="html"> 原文出处： medium 译文出处： inside - elaine。 试想一位小公司老板每日孜孜不倦地工作，为何不能从为数众多的竞争者脱颖而出？ 一位创业家可以不眠不休一天工作24 小时，整整一周不休假。 然而，时间有限，且竞争者却永远可以投入更多钱与心力，让竞争更剧烈。 那么，为什么某些小型新创公司可以完成许多大型企业无法完成的事情呢？  Instagram──只有13 名员工却被Facebook 用几十亿买下的公司。   Snapchat──只有30 名员工却拒绝科技巨人Facebook、Google 的并购交易。   它们的成功部分来自于幸运──其余则是因为效率 。  成功的关键不是努力工作，而是用聪明的方式工作。  有效率并不是指良好的时间管理，而是──管理您的精力。 人们都需要学习如何花费最少的精力能够得到最大效益。 要提升生产力，下面这些事情绝对要避免： 一、停止加班，提升效率！  1926年，福特汽车工业亨利福特（Henry Ford）执行了一项实验发现有趣的结果：当把一日的工时从10 小时降到8 小时，从一周工作6 天减少至一周5 天，人们的生产力将会提高（注一）。 当您工作得越多，不论是短期或长期而言，您的效率、生产力都会降低。 1980 年由The Business Roundtable 的一篇研究〈Scheduled Overtime Effect on Construction Projects〉指出（注二）：  当每周工作时间超过60 小时，并持续超过两个月，生产力下降的累积效应将使完工日期推迟，而人数相同但每周只工作40 小时的团队执行同样工作，甚至还会更早完工。  在AlterNet的一篇文章中，Sara Robinson回顾美军执行的一项研究，这项发现「每晚都减少1小时睡眠，持续一周，将导致认知功能退化，等同于喝酒使血液酒精浓度升高至0.10 。  当个人过于劳累，使其以比平常还要负面的角度看事情，导致普遍地心情低落。 比心情更重要的是，其思维往往伴随着减少「主动思考与行动」──包括控制冲动、自我感觉良好、同情他人与情绪智力──的意愿（注三）。  维持高程度的生产力，避免让自己过度工作并睡眠充足很重要。 下次您思想为何工作缺乏生产力，原因很简单，您有可能缺乏睡眠。 二、不要太常说「yes」  根据80/20 法则（Pareto Principle），20% 的努力创造80% 的成果，20% 的成果消耗80% 的时间。 不是努力工作，我们应该把注意力放在创造80% 的结果并放弃其余的。 我们应该把更多时间放在最重要的任务。 我们应该停止对低效能与无效能的任务说：「好的，我来做」 。  「成功的人」与「非常成功的人」之间的差异在于，非常成功的人对几乎所有的事情都说不。
— Warren Buffet  激发一个问题：什么事情要说yes，什么事情说no？ 如果您不能想出某些值得花时间的地方，就考虑作个小测试找出答案：追踪您作的所有事情，可能的话持续优化处理的过程。 通常人们说「yes」的频率比实际上应该的次数还要多，因为说「yes」比说「no」要简单太多，没有想要当坏人。 2012 研究发表在Journal of Consumer Research，研究者将120 个学生分成两组。 一组被训练为说「我不能（I can’t）」，然而其他被训练为「我不要（I don’t）」。 结果很有趣：  对自己说「我不能吃X」的学生，61% 都会选择吃巧克力糖，同时，对自己说「我不要吃X」的学生，只有36 % 会选择吃巧克力糖。 光是简单的词汇替换，就能显著增加人们选择更健康食品的机率。 （延伸阅读： 拒当YES MAN，说「不」让生活更美好 。）  三、停止什么都事必躬亲，让其他人帮忙  在我职涯的某个点，我管理一个非常大的社群，而我无法处理得很好。 我试图每一件事情都自己来。 我疲倦不堪，但社群最终接管我的职责并自行治理。 因此我也学习到社群的力量，以及为什么品牌需要使用者创造的内容（user-generated content）。 消费者知道他们想要什么，以及他们想要如何让它更好，更甚于任何行销人员。 根据Octoly ，一支使用者自制影片的观看次数要比品牌自制影片多上十倍。 当寻找关于一个特定品牌的资讯，超过半数（51 %）的美国人相信使用者自制内容大过于品牌官网（16%）与媒体报导（14 %），对行销人员来说，寻求社群的帮忙至关重要。 除此之外， 当您需要时，很重要地是愿意求助，让其他人来帮您。 因为这样可以让您有更多时间将焦点放在更重要的任务上。 大多数的时候，即使您的朋友不能帮助您提升生产力。 光是陪在您身边就足够， 研究证实：分心的人在其他人也在场的情况，尽管那些人没有协助或指导，也可以完成更多的工作事项。 四、停止完美主义  Dalhousie University心理学教授Simon Sherry博士Simon Sherry执行一项完美主义与生产力的研究 ，她指出：我们发现完美主义是绊倒教授的研究生产力的大石头。 完美主义倾向越高的教授就越没有效率。 当一位完美主义者有以下问题：  他们在一项花费的时间比任务要求所花费的时间还多。   他们会拖延并等到最佳的时刻。 在企业中，如果这是最完美的时刻，就代表已经太迟了。   他们过度聚焦在细节，反而忽略整体。   五、停止作重复的事情，并使它自动化  根据一项Tethy Solutions的研究 ，一个5人团队分别花3%、20%、25%、30%与70%的时间处理相同的事情，导入工作自动化软体两个月后，分别将处理重复事情的时间降至3%、10%、15%、15% 与10%。 人们时常忘记时间就是金钱，因此经常土法炼钢地处理事情，因为这样比较容易，且不需要花费心力研究。 假设您办了一个Instagram 活动，号召网友上传的照片总数只有30 张，您可以手动一张一张处理。 但如果总共有从5个不同平台上传的30000张照片与影片时，您就需要一个好的数位管理系统了（例如Filemobile）。  给行销人员的小撇步 ：到GitHub或Google app script library,通常会发现免费且可马上使用的开源程式码，让您找到省去手动处理重覆工作的软体/程式。  六、停止猜测，并开始用数据支撑决策  如果您可以在搜寻引擎上优化网站，那么您也可以优化您的人生，让它成长并发挥最大的潜能。 不同领域的研究其实都可供参考，举例来说，宾州州立大学心理系助理教授Robert Matchock 所执行的研究发现，大部分的人们最容易分心的时间是从中午到下午四点。 此数据便提供您作工作相关决策的考量。 假使您无法从现有研究找到答案，那么您也可以自行执行简单的测试。 举例来说，Filemobile就制定了许多测试，试图找出如何优化Twitter的图片呈现 。 不断询问您自己：要如何测量并优化所有事情呢？ 七、停止工作，并拥有无所事事的时间  大部分的人都没有了解到，当我们专注在某件事上，基本上就像是把自己锁在一个箱子里。 很重要的是要每隔一段时间离开工作现场，享受独处的时光。 独处时光对大脑与灵魂都有益处（注四）：  一项哈佛研究指出，当人们相信他们是单独经验某项事情时，脑海的记忆会更持久且更精确。 另外一个研究也指出体验相当程度的孤独会让一个人更能够同理他人……相当程度的孤独可以帮助青少年改善心情与获得好成绩。  我们不会因为熬夜而更有效率。 就像是生命中的每件事情，需要耗费心力。 如果您什么都不做只是坐着等，不会有什么改变，所以我们要更了解自己的限制与潜能，并将精力作有效的配置，过一个更成功、更快乐的人生。 注释：  注一、注二：Calculating Loss of Productivity Due to Overtime Using Published Charts — Fact or Fiction 注三： The Secret World of Sleep: The Surprising Science of the Mind at Rest 注四： The power of lonely </content>
    </entry>
    
     <entry>
        <title>mysqlpp中一些特殊功能总结</title>
        <url>https://cppfans.org/1634.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>MySQL</tag><tag>mysqlpp</tag><tag>转义字符</tag>
        </tags>
        <content type="html"> 之前有写过一篇mysql&#43;&#43;的文章 《C&#43;&#43;使用MySql&#43;&#43;操作数据库实例》,里面讲了C&#43;&#43;如何用mysql&#43;&#43;的库来操作mysql数据库，现在这个手机项目原来的mysql操作库是从mysql原生封装的，大致做了三四层，看着挺麻烦的，就换成了mysql&#43;&#43;，不过这次用遇到了一些问题。
我们角色的一部分数据是使用了protobuf打包然后按照blob格式存入到数据库中，pb打包应该很多人在项目中用到过，特别是网络应用中，但是pb中的优化会导致数据里产生一些特殊字符，导致入库的时候数据无法存入，查了下，原来mysql&#43;&#43;中提供了转义和引用的接口，如下：
mysqlpp::quote_only 将数据用引号括起来，经常用在字符串入库
mysqlpp::quote 将数据用引号括起来，并增加转义，例如你的数据中有单引号，双引号，反斜杠等等
mysqlpp::escape 只处理特殊字符，一般用在blob字段上，但是quote足够用了
网上找到的一个mysql&#43;&#43;在项目中的资料，下载地址如下：
下载地址： mysql&#43;&#43;使用文档(PDF)  (资料来源网络，如有侵权，请留言说明)
</content>
    </entry>
    
     <entry>
        <title>boost相关小知识(长期顶置更新)</title>
        <url>https://cppfans.org/1534.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>boost</tag><tag>noncopyable</tag>
        </tags>
        <content type="html"> 2.boost throw_exception unresolved
在项目中(windows VS环境)增加了一些boost库，导致一个链接报错，
throw_exception unresolved (link error)
可以修改vs的工程属性，/EH 和 /GX属性
修改方法见：
http://msdn.microsoft.com/zh-cn/library/1deeycx5.aspx
http://msdn.microsoft.com/zh-cn/library/d42ws1f6(v=vs.80).aspx
1.boost::noncopyable
nonycopyable是一个可以通过继承来防止你自己的类拷贝构造或者拷贝赋值的类。有些复杂对象，并没有明确的拷贝构造/拷贝赋值函数，当你使用隐性的拷贝构造/拷贝赋值时，可能会出现一些不必要的bug。
boost::noncopyable将构造和析构函数设置为protected，子类可以调用，使得子类调用默认构造函数时不至于编译不过。将拷贝构造/拷贝赋值函数设置为private，子类没有定义自己的拷贝构造/拷贝赋值函数时，是无法拷贝构造和等号赋值的。
一般都是私有继承的：
class my_class : private boost::noncopyable
PS:也有用public继承的，这个其实就是继承的特性了。而noncopyable主要是防止拷贝构造/赋值，所以private继承和public继承差别不是很大。stackoverflow上也是如是说。
// to be continued
</content>
    </entry>
    
     <entry>
        <title>[投稿]一年工作总结 (单进程网游服务器框架介绍)</title>
        <url>https://cppfans.org/1624.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>总结</tag><tag>服务器</tag><tag>架构</tag>
        </tags>
        <content type="html"> 工作已经满一年了。。。记得还是去年十月多的时候来广州找工作的，找了大概一个星期左右，然后找到这家公司后就一直待到现在。今年毕业的时候回了趟学校，到现在工作时间大概有一年了。第一个手游项目已经上线有一段时间了，还不知道盈利情况怎么样，又开始了一个新的卡牌游戏。工作一直挺充实的，第一个项目的从零开始我就加入了项目组，从头至尾参与了项目的研发，感觉收获还是有点的，但一时又想不到怎么说。现在新的卡牌游戏用的是上一个项目的框架。既然不知道总结什么，我就把游戏服务端框架说一说吧。
对着上面的框架图来说，首先是网关FGGateway，作为一个连接服务器，处理服务端和客户端的连接，对应的数据分配。我公司是用libevent实现的。代码量很少，方便移植。
逻辑服务器FGServer和FGClient所使用的网络使用select实现的，同一套代码，从网络的角度这逻辑服务器也是一个客户端。
FGClient连接FGServer的过程图上没说到FGGateway的中转过程，这里简单说下流程：
FGServer
FGServer 调用 connect 连接FGGateway，
连接成功，FGServer发送第一条协议给FGGateway，携带设备信息告诉FGGateway说自己是服务端。
FGGateway 验证设备信息，成功则把FGServer加到在线服务器列表中。
FGClient
FGClient 调用 connect 连接FGGateway，
连接成功，FGClient发送第一条协议给FGGateway，携带设备信息告诉FGGateway是说自己是客户端。
FGGateway 把FGClient保存到客户端队列，
FGClient 发送第二条协议获取在线服务器列表，FGGateway返回在线服务器列表。
FGClient 发送第三条协议：选服协议，FGGateway把FGClient和FGServer绑定。
FGClient 接下来发送协议都会直接转发到FGServer。FGServer发送协议也会根据客户端的fd直接转发到FGClient。
FGServer和FGShmDB的交互，FGShmDB是用共享内存实现的内存数据库，只是简单的实现数据库的数据加载到内存，不支持数据从内存中移除，只是将用到的数据库中的数据按需加载到内存中，这样一来读取数据的速度会加快（第一次是从数据库中加载出来放到内存中，之后都是直接操作内存）。然后FGServer就是操作FGShmDB分享出来的内存。
FGLogin 是比较简单的一个http服务。主要是接收客户端的url请求，返回服务器列表给客户端。用于集合服务器。现在是直接用libevent的http实现的，用lua包装了一下。主要实现了用户注册，修改密码，用户登录，获取服务器列表等操作。其实可以用php实现它的，不知为啥会选用c。
来源：http://www.hanxi.info/2013/11/17/original-one-year/
</content>
    </entry>
    
     <entry>
        <title>[转]想要不加班，就先丢掉这7样东西...</title>
        <url>https://cppfans.org/1627.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>加班</tag><tag>工作</tag>
        </tags>
        <content type="html"> via: http://www.aow.me/jian-shao-gong-zuo-jian-dan-gong-zuo/
如果你的工作似乎总是做不完，每天都要加班，即使到了周末，也不能休息，还要拖着疲惫的身体继续去公司上班，你就需要停下来好好地思考自己的工作方法是否出了错误？连续加班，不仅工作效率低下，而且长期的疲累加班会影响身体健康，甚至因为工作压力，有性命之忧。
作为职场工作的上班族，工作的第一要义就是勇敢舍弃。不管你能力多强，首先要懂得舍弃。舍弃对你工作没有任何帮助的事情。简化工作方式，提高工作效率，并适时减少工作量，就可以做到轻松上班。
想要不加班，就先丢掉这7样东西：
 完美主义
先丢掉你的完美主义：不要试图在每一件事情上都力求完美。完美主义只会为你的工作招来混乱与停滞！你要明白，这世上没有完美的。每一份工作只是让事情更加接近完美。
 充当老好人
在办公室，团队合作过程中，有些人总是想做个好好先生或好好小姐，对每件事都说“YES”！对来自别人的请求，也都是YES。于是承担了大量来自他人的工作。而自己的工作却不能按时完成。这时一定要适时地拒绝别人。先完成自己的工作，再去分担或者是帮助他人顺利完成工作。千万不要代替别人工作，否则你会有做不完的事！
 拖延症
由于懒惰和拖延，会造成你手上的工作越积越多。我认为战胜拖延最好的办法，就是认清现实。按照工作清单，一样一样地完成工作，一旦完成，立刻将这份工作划出去。随时提醒自己：工作一旦分派到你的手里，一定要马上完成！
 过度不安的心理
有些时候，作为普通职员，不敢发出自己的声音。也不愿意对产品和项目表达自己的真实看法。每次开会时，也总想着：“如果说出来，应该会被嘲笑，或者被骂？基于这种不安的心理，在公司里，便越来越消极，工作也越做越不顺。于是工作效率也更加低下了。战胜不安，就是要足够自信。还要有乐观思考的习惯！
 总是一个人努力工作
别老是一个人扛起全部工作！善用团队的力量，才能成就大事！不凡事都自己一个人能从头负责到尾，懂得团队合作。听取别人的建议，就能事半功倍。
 无用的办公物品和文件
工作一天，你总是会找几次东西呢？因为桌子上，和文件柜里的杂物和资料太多，你每次都要花时间找出真正有用的。解决方案就是定期整理的你工作台面和你的工作文件。将没用的文件和杂物通通丢掉。直到你的桌面看起来一目了然，轻松找到常用的物品。你现在就要开始整理你的办公桌和抽屉。
 过去的自己
不管因为过去成功的或者失败的经历，影响到你现在的工作。怀念之前公司的轻松工作，或者为自己过去的失败经历而自卑，都对你的工作无益处。与其花时间为过去遗憾或骄傲，不如好好地把握现在，做好现在的工作。
  内容参考：《不想累死自己，一定要学会 把工作变简单》作者：中岛孝志
&amp;nbsp;
PS：国内貌似大多数公司是没事儿也得加班，因为很多人都在加班，fuck！
</content>
    </entry>
    
     <entry>
        <title>网游服务器中的GUID(唯一标识码)实现-基于snowflake算法</title>
        <url>https://cppfans.org/1623.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>GUID</tag><tag>UUID</tag><tag>唯一标示码</tag><tag>服务器</tag><tag>网游</tag>
        </tags>
        <content type="html"> 本文中的算法采用twitter的snowflake算法，具体请搜索介绍，原来是用Scala写的，因我项目需要，改写成C&#43;&#43;语言，主要用于高效的生成唯一的ID, 核心算法就是毫秒级时间(41位)&#43;机器ID(10位)&#43;毫秒内序列(12位).
网上也有好多PHP写的插件模块，核心用了网络通讯将生成的ID发送给PHP使用，没深入研究PHP的模块写法。
废话不多说了，还是直接上代码好了。
uuid.h
#ifndef __UTIL_UUID_H__ #define __UTIL_UUID_H__ #include &amp;lt;stdint.h&amp;gt; namespace utils { // twitter snowflake算法 // 64 63--------------22---------12---------0 // 符号位 | 41位时间 |10位机器码|12位自增码| extern uint64_t get_time(); class unique_id_t { public: unique_id_t(); ~unique_id_t(); void set_epoch(uint64_t epoch); void set_machine(int32_t machine); int64_t generate(); private: uint64_t epoch_; uint64_t time_; int32_t machine_; int32_t sequence_; }; } #endif // !__UTIL_UUID_H__ uuid.cpp
#include &#34;uuid.h&#34; #if defined(__GUNC__) #include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define EPOCHFILETIME 11644473600000000ULL #else #include &amp;lt;windows.h&amp;gt; #include &amp;lt;time.h&amp;gt; #define EPOCHFILETIME 11644473600000000Ui64 #endif namespace utils { uint64_t get_time() { #ifdef __GUNC__ struct timeval tv; gettimeofday(&amp;tv, NULL); uint64 time = tv.tv_usec; time /= 1000; time &#43;= (tv.tv_sec * 1000); return time; #else FILETIME filetime; uint64_t time = 0; GetSystemTimeAsFileTime(&amp;filetime); time |= filetime.dwHighDateTime; time &amp;lt;&amp;lt;= 32; time |= filetime.dwLowDateTime; time /= 10; time -= EPOCHFILETIME; return time / 1000; #endif } unique_id_t::unique_id_t() { epoch_ = 0; time_ = 0; machine_ = 0; sequence_ = 0; } unique_id_t::~unique_id_t() { } void unique_id_t::set_epoch(uint64_t epoch) { epoch_ = epoch; } void unique_id_t::set_machine(int32_t machine) { machine_ = machine; } int64_t unique_id_t::generate() { int64_t value = 0; uint64_t time = get_time() - epoch_; // 保留后41位时间 value = time &amp;lt;&amp;lt; 22; // 中间10位是机器ID value |= (machine_ &amp; 0x3FF) &amp;lt;&amp;lt; 12; // 最后12位是sequenceID value |= sequence_&#43;&#43; &amp; 0xFFF; if (sequence_ == 0x1000) { sequence_ = 0; } return value; } } #ifdef __TEST__ #include &amp;lt;iostream&amp;gt; void test() { utils::unique_id_t* u_id_ptr = new utils::unique_id_t(); u_id_ptr-&amp;gt;set_epoch(uint64_t(1367505795100)); u_id_ptr-&amp;gt;set_machine(int32_t(100)); for (int i = 0; i &amp;lt; 1024; &#43;&#43;i) { std::cout &amp;lt;&amp;lt; u_id_ptr-&amp;gt;generate() &amp;lt;&amp;lt; std::endl;; } } #endif 这样的唯一ID就可以用来表示你系统中使用的例如物品唯一ID，坐骑唯一ID等等数据，方便记录和追踪。
</content>
    </entry>
    
     <entry>
        <title>linux常见问题汇总(长期顶置更新)</title>
        <url>https://cppfans.org/1544.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>2003</tag><tag>codeblocks</tag><tag>httpd</tag><tag>Linux</tag><tag>MySQL</tag><tag>selinux</tag><tag>SIGSEGV</tag><tag>服务</tag><tag>自启动</tag><tag>问题</tag><tag>静态编译</tag>
        </tags>
        <content type="html"> 2014/12/23更新： 7.glibc版本查看
把libc.so.6当成执行文件运行下就可以看到版本号
6.GLIBCXX版本查看
strings /usr/lib64/libstdc&#43;&#43;.so.6 | grep GLIBCXX
&amp;nbsp;
5.mysql&#43;&#43;静态编译方法
mysql&#43;&#43;下载来后无法静态编译，加了 &amp;ndash;enable-static=yes也不行，不过我们可以直接使用ar命令编译.o文件，命令如下
ar rcu libmysqlpp.a mysqlpp_beemutex.o mysqlpp_cmdline.o mysqlpp_connection.o mysqlpp_cpool.o mysqlpp_datetime.o mysqlpp_dbdriver.o mysqlpp_field_names.o mysqlpp_field_types.o mysqlpp_manip.o mysqlpp_myset.o mysqlpp_mysql&#43;&#43;.o mysqlpp_mystring.o mysqlpp_null.o mysqlpp_options.o mysqlpp_qparms.o mysqlpp_query.o mysqlpp_result.o mysqlpp_row.o mysqlpp_scopedconnection.o mysqlpp_sql_buffer.o mysqlpp_sqlstream.o mysqlpp_ssqls2.o mysqlpp_stadapter.o mysqlpp_tcp_connection.o mysqlpp_transaction.o mysqlpp_type_info.o mysqlpp_uds_connection.o mysqlpp_utility.o mysqlpp_vallist.o mysqlpp_wnp_connection.o ssqls2parse_parsev2.o 然后直接使用libmysqlpp.a就好了
&amp;nbsp;
4.linux下服务自启动几种方法
(1)chkconfig
例如将httpd自启动，首先查看httpd服务是否已经自启动了
#chkconfig --list | grep httpd httpd 0:off 1:off 2:off 3:off 4:off 5:off 6:off 如果结果是上述，则使用下面命令打开自启动
#chkconfig httpd on httpd 0:off 1:off 2:on 3:on 4:on 5:on 6:off 如果httpd没有加入自启动列表，先增加进列表中
#chkconfig --add httpd (2)修改rc.local文件
例如我们想自启动mysqld_safe，在rc.local中增加如下命令
#mysql /usr/local/mysql/bin/mysqld_safe &amp; 保存后就可以了
(3)ln软链接的方法就不做介绍了，感觉太麻烦了，大家请自行查阅
&amp;nbsp;
3.SQLSTATE[HY000] [2003] Can&amp;rsquo;t connect to MySQL server on &amp;lsquo;ip&amp;rsquo; (13)
项目用的centos服务器无故死机，重启后发现上面安装的禅道项目管理软件无法打开，看了log之后发现是连不上数据库，查了好久，才发现是SELinux 不让 httpd 访问外网，使用如下命令查看httpd的参数配置
 [root@jzsj sbin]# getsebool -a | grep httpd
allow_httpd_anon_write &amp;ndash;&amp;gt; off
allow_httpd_mod_auth_ntlm_winbind &amp;ndash;&amp;gt; off
allow_httpd_mod_auth_pam &amp;ndash;&amp;gt; off
allow_httpd_sys_script_anon_write &amp;ndash;&amp;gt; off
httpd_builtin_scripting &amp;ndash;&amp;gt; on
httpd_can_check_spam &amp;ndash;&amp;gt; off
httpd_can_network_connect &amp;ndash;&amp;gt; off
httpd_can_network_connect_cobbler &amp;ndash;&amp;gt; off
httpd_can_network_connect_db &amp;ndash;&amp;gt; off
httpd_can_network_memcache &amp;ndash;&amp;gt; off
httpd_can_network_relay &amp;ndash;&amp;gt; off
httpd_can_sendmail &amp;ndash;&amp;gt; off
httpd_dbus_avahi &amp;ndash;&amp;gt; on
httpd_enable_cgi &amp;ndash;&amp;gt; on
httpd_enable_ftp_server &amp;ndash;&amp;gt; off
httpd_enable_homedirs &amp;ndash;&amp;gt; off
httpd_execmem &amp;ndash;&amp;gt; off
httpd_manage_ipa &amp;ndash;&amp;gt; off
httpd_read_user_content &amp;ndash;&amp;gt; off
httpd_run_stickshift &amp;ndash;&amp;gt; off
httpd_serve_cobbler_files &amp;ndash;&amp;gt; off
httpd_setrlimit &amp;ndash;&amp;gt; off
httpd_ssi_exec &amp;ndash;&amp;gt; off
httpd_tmp_exec &amp;ndash;&amp;gt; off
httpd_tty_comm &amp;ndash;&amp;gt; on
httpd_unified &amp;ndash;&amp;gt; on
httpd_use_cifs &amp;ndash;&amp;gt; off
httpd_use_fusefs &amp;ndash;&amp;gt; off
httpd_use_gpg &amp;ndash;&amp;gt; off
httpd_use_nfs &amp;ndash;&amp;gt; off
httpd_use_openstack &amp;ndash;&amp;gt; off
httpd_verify_dns &amp;ndash;&amp;gt; off
 果然httpd_can_network_connect &amp;ndash;&amp;gt; off，使用如下命令开启
[root@jzsj sbin]# setsebool httpd_can_network_connect 1
然后禅道访问正常了，用内网IP，127.0.0.1, 0.0.0.1均正常
&amp;nbsp;
2.codeblocks调试过程中出现Program received signal SIGSEGV, Segmentation fault弹窗
使用CB调试服务器过程中，出现了一个黄色的弹窗，上面提示 Program received signal SIGSEGV, Segmentation fault，而且断点光标停在了一个很明显没有错误的地方。google之signal SIGSEGV。
 SIGSEGV：在POSIX兼容的平台上，SIGSEGV是当一个进程执行了一个无效的内存引用，或发生段错误时发送给它的信号。SIGSEGV的符号常量在头文件signal.h中定义。因为在不同平台上，信号数字可能变化，因此符号信号名被使用。通常，它是信号#11。
 这个问题大多是因为内存越界，溢出等问题，不过我的并没有这些问题，找了半天也没发现，而且我的程序没有core dump。后来去掉了几个断点发现正常了，觉得应该还是CB的问题，如果你也有这样的问题，先检查代码，然后检查环境。
求一个cb下可以在调试查看指针数据内容的插件，VS用习惯了，用CB感觉不会再爱了
&amp;nbsp;
 apache httpd外部机器不能访问网站问题  安装了apache httpd之后，可以通过127.0.0.1或者localhost访问，别的机器不能通过该机器的IP访问，需要修改httpd.conf中的ServerName为本机的IP，这样别的机器就可以通过IP访问了
（本问题是在安装禅道项目管理软件中遇到的）
httpd.conf对于不同的linux系统可能放置的位置不同，可以使用查找命令 find / -name httpd.conf
</content>
    </entry>
    
     <entry>
        <title>glog使用与功能修改</title>
        <url>https://cppfans.org/1566.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C/C&#43;&#43;</tag><tag>glog</tag><tag>log库</tag><tag>修改</tag><tag>跨平台</tag>
        </tags>
        <content type="html"> 在写代码的过程中，打log肯定是少不了的，毕竟不能总靠调试来发现问题。log库的选用就很纠结了，成熟的log库非常多，log4cpp、log4cxx、poco.log、boost.log、glog等等，以前我用过log4cxx，觉得配置巨麻烦，一大段看着好纠结，不过用起来很舒服。这次我决定使用比较轻量的glog。
glog来自于google，google提供给大家不少好东西，所以功能和质量上都是可以保证的。而且很轻量，用起来很灵活。
glog项目地址：https://code.google.com/p/google-glog/
glog的文档：英文 http://google-glog.googlecode.com/svn/trunk/doc/glog.html
glog入门代码就不多写了，在文档中也有，网上也是一大片，大家请自行搜索。他提供了vs工程和configure文件，编译方法见文档。
&amp;nbsp;
我修改的部分
1.增加文件按天区分
glog是根据进程ID来区分文件的，如果你重新启动了程序，则log文件的名字就会变，这样似乎不太满足我的需求，我还要求它可以每天生成文件，方便我整理和分析log，其实也有办法，自己增加一个按天滚文件的函数就可以了。
在utilities.cc中增加函数如下，（因为PidHasChanged()在这个文件里）
static int32 g_main_day = 0; bool DayHasChanged() { time_t raw_time; struct tm* tm_info; time(&amp;raw_time); tm_info = localtime(&amp;raw_time); if (tm_info-&amp;gt;tm_mday != g_main_day) { g_main_day = tm_info-&amp;gt;tm_mday; return true; } return false; } 在logging.cc的LogFileObject::Write函数中将
if (static_cast&amp;lt;int&amp;gt;(file_length_ &amp;gt;&amp;gt; 20) &amp;gt;= MaxLogSize() || PidHasChanged()) { 改成
if (static_cast&amp;lt;int&amp;gt;(file_length_ &amp;gt;&amp;gt; 20) &amp;gt;= MaxLogSize() || PidHasChanged() || DayHasChanged()) { 这样就会按照天来输出log了。
&amp;nbsp;
2.glog默认有四种log级别，高级别的log中会包含低级别的log，这个我也是不需要的，我希望每一个分级一个文件。
我增加了一个宏来控制这个开关，以免影响到原来的功能。
在glog/src/windows/glog/logging.h (我在windows上用的，linux的请自己查找)
DECLARE_bool(servitysinglelog); 然后修改 logging.cc中的LogDestination::LogToAllLogfiles为如下
inline void LogDestination::LogToAllLogfiles(LogSeverity severity, time_t timestamp, const char* message, size_t len) { if ( FLAGS_logtostderr ) { // global flag: never log to file ColoredWriteToStderr(severity, message, len); } else { if (FLAGS_servitysinglelog) { LogDestination::MaybeLogToLogfile(severity, timestamp, message, len); } else { for (int i = severity; i &amp;gt;= 0; --i) LogDestination::MaybeLogToLogfile(i, timestamp, message, len); } } } 我整体的初始化函数如下：
bool Init() { google::InitGoogleLogging(&#34;&#34;); #ifdef DEBUG_MODE google::SetStderrLogging(google::GLOG_INFO); //设置级别高于 google::INFO 的日志同时输出到屏幕 #else google::SetStderrLogging(google::GLOG_FATAL);//设置级别高于 google::FATAL 的日志同时输出到屏幕 #endif FLAGS_colorlogtostderr = true; //设置输出到屏幕的日志显示相应颜色 FLAGS_servitysinglelog = true;// 用来按照等级区分log文件 google::SetLogDestination(google::GLOG_FATAL, &#34;./log/log_fatal_&#34;); // 设置 google::FATAL 级别的日志存储路径和文件名前缀 google::SetLogDestination(google::GLOG_ERROR, &#34;./log/log_error_&#34;); //设置 google::ERROR 级别的日志存储路径和文件名前缀 google::SetLogDestination(google::GLOG_WARNING, &#34;./log/log_warning_&#34;); //设置 google::WARNING 级别的日志存储路径和文件名前缀 google::SetLogDestination(google::GLOG_INFO, &#34;./log/log_info_&#34;); //设置 google::INFO 级别的日志存储路径和文件名前缀 FLAGS_logbufsecs = 0; //缓冲日志输出，默认为30秒，此处改为立即输出 FLAGS_max_log_size = 100; //最大日志大小为 100MB FLAGS_stop_logging_if_full_disk = true; //当磁盘被写满时，停止日志输出 //google::SetLogFilenameExtension(&#34;91_&#34;); //设置文件名扩展，如平台？或其它需要区分的信息 //google::InstallFailureSignalHandler(); //捕捉 core dumped (linux) //google::InstallFailureWriter(&amp;Log); //默认捕捉 SIGSEGV 信号信息输出会输出到 stderr (linux) return true; } 这些改动之后我的功能基本就满足了，修改下log输出的格式，原来的log格式大致是这样的 I1234 02/11 12:20:50.123456 xxx.cpp 12] 你的log内容，是 级别的首字母 线程ID 月/日 时分秒微秒 文件名 行号]，我将它修改成为 [级别名 线程ID 年/月/日 时分秒毫秒 文件名 行号]，在logging.cc的LogMessage::Init函数中修改
再加上一个log(severity_level, format, &amp;hellip;)函数就可以打印log了。
</content>
    </entry>
    
     <entry>
        <title>回复某在校学生的邮件问题</title>
        <url>https://cppfans.org/1618.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>行业</tag><tag>解答</tag><tag>软件</tag>
        </tags>
        <content type="html"> 原邮件如下：
 eliteYang:
您好.
我是一名软件工程专业的大学生,我们一门课的期末作业要求是访谈一位已经从业的前辈.我个人也是非常喜欢C&#43;&#43;,当老师留这个作业的时候我就想到了博主.希望博主能在百忙之中能抽出一点时间,简短的回答一下问题,不必要太专业和复杂.
1.访谈对象的个人信息:称呼;毕业大学;目前就职公司和职业.(如果不方便透漏的话,只说一下目前的工作就行了)
2.名牌大学毕业的学生相比于普通大学毕业的学生,他们哪一些方面强于普通大学的学生?他们比普通大学的学生多了什么?
3.在找工作方面,名牌大学这块&amp;rdquo;招牌&amp;rdquo;是不是有着决定性作用?普通大学的学生很难受到重视吗?
4.学校中的哪些课程对这个行业有非常大的帮助？
5.C&#43;&#43;会不会是以后的主流?把大量精力放在C&#43;&#43;编程上值不值得?以后容易找工作吗?
6.预测一下软件行业的主要发展方向,是Windows桌面,移动Web,移动客户端还是其他?
7.有没有想对在校的软件专业学生说的话?
感谢博主百忙之中能抽空点击这个邮件.
 首先非常抱歉我长期不登陆admin@cppfans.org这个邮箱，大部分人跟我交流都是通过我的QQ故意整个163邮箱，所以大概过了10多天我才看到这个邮件。等我回邮件给这位朋友时，发现他的作业已经完成了，不过他还是希望我能回答一下这些问题。所以就有了此文。
&amp;nbsp;
我逐条回答一下。
1.我毕业于西安邮电大学电子工程专业(当时还叫西安邮电学院)，职位是服务端软件开发工程师，工作内容基本就是开发网络游戏服务器端，以前做过端游服务器，目前在做手游服务器。
2.我有一部分名牌大学毕业的朋友和同学，个人觉得学校名气在工作内容上没什么大的作用，但是企业比较看重这个，算是敲门砖。名校学生更多的是在于见识广泛，他们的教育方式可能跟别的学校有些差别，他们大部分学生比较勤奋。剩下的我就不太清楚了，毕竟我没读过名校。
3.找工作上，名校招牌对企业的招聘规则有一定影响，但不是决定性因素。企业招人更多的是你的现在的能力和未来的潜力。
4.学校中的一些基础可能对你在这个行业帮助更大一些，例如：高数，C语言，微机原理，软件工程等等。对了解这个行业帮助更大一些，但并不是说其他课程没什么用啊。
5.我不能说C&#43;&#43;是否为主流，在目前来看，C&#43;&#43;保持在排行榜前三，算是非常主流了。具体你是否要从事C&#43;&#43;的行业，还是老话，看你的个人喜好程度和热情程度。C&#43;&#43;的工作还是比较好找的。
6.未来软件行业的发展大方向还是互联网和移动端方向，通过近年的手机的普及程度和APP的数量你应该可以看出来。
7.这条感觉有点专访的意思啊，哈哈…… 希望软件工程的学生能喜欢这个专业，热爱这个行业，做更多的实践工作，为以后工作做一些项目积累。如果你不想从事软件行业，那请你提前做到未雨绸缪，为自己的未来做打算。
&amp;nbsp;
收到这位朋友的邮件也让我有点惊讶，因为截至博客成立到现在只有两个人问我了一些关于这个行业的问题，他就是第二个，前面有一个问了编码风格。
希望我的回答对他有些用处，也欢迎有更多的问题提出，共同讨论。
</content>
    </entry>
    
     <entry>
        <title>静态编译libevent</title>
        <url>https://cppfans.org/1564.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C/C&#43;&#43;</tag><tag>libevent</tag><tag>网络库</tag><tag>跨平台</tag><tag>静态编译</tag>
        </tags>
        <content type="html">  libevent简介
libevent是一个事件触发的网络库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制。著名分布式缓存软件memcached也是libevent based，而且libevent在使用上可以做到跨平台，而且根据libevent官方网站上公布的数据统计，似乎也有着非凡的性能。
 linux下编译
这个就非常简单了,
./configure make make install 三部曲搞定
&amp;nbsp;
windows下编译就没这么简单了
最新的stable版本是2.0.21，对源码不需要任何修改即可，老的版本可以需要在event_iocp.c evthread_win32.c listener.c中加入
#define _WIN32_WINNT 0x0500 确保代码中用到某些windows的函数可以知道系统版本。
打开您visual studio tool中的开发人员工具，进入您libevent代码目录，(这里cd命令有个坑的，不同分区跳转有问题，需要 cd /d dir，强制跳转)，然后输入
nmake /f Makefile.nmake 使用vs自带的nmake来编译，之后会生成libevent.lib libevent_core.lib libevent_extras.lib，这样您所需要的libevent的静态文件库就生成了，下来就将include和lib引入到您的工程中就可以使用了。
</content>
    </entry>
    
     <entry>
        <title>2013结束语</title>
        <url>https://cppfans.org/1562.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>2013</tag><tag>2014</tag><tag>年会</tag><tag>目标</tag><tag>结束语</tag>
        </tags>
        <content type="html"> 我已经放假三天了，公司26号晚上开的年会，晚上快10点喝的晕晕的从奉贤区回来，感谢灵娱的那位朋友在我们出来的时候帮我们叫住了回去的大巴，以至于我们能更快的回来。年会上的菜真心不怎么的，不过那进口的红酒喝起来不错，比超市的好喝多了，跟其他部门的同事喝了不少，唯一遗憾的就是我们桌的同事都太闷了，而且喝酒都放不开，以至于我跟另外一个同是服务器的同事去别桌喝了好多，不过也是有好处的，聊了很多，增进了很多感情。就像我们制作人说的，要想美术好，要想策划案更准确，喝酒的时候到了。比较幸运的是中了三等奖，一个3克的招行金币，沾了前面端游项目主程的运气了。
年会整个都是灵娱的人比较活跃，毕竟人家好几款项目在同时赚钱，大闹更是获得了业内靠前的成绩，相比之下，我们这边就显得是陪衬了，不过展望2014年吧，我们的手游项目出来之后，看看效果如何，期待翻身，加油！
2013也就这么不经意之间就过完了，之前定的计划有完成的有未完成的，个人的拖延症和强迫症更严重了。2013年11月份换了工作，原因无他，工资和兴趣都不满意了，就走了。现在这家基本还可以，项目也做了一半了，等明年上半年上线了看看效果吧。
2014年的目标：通用服务器设计，通用网络底层和底层库(跨平台)，锻炼身体
&amp;nbsp;
2013结束了，2014开始了，心底给自己喊下口号，加油，继续努力，努力腾飞！
&amp;nbsp;
感谢大家对博客的继续支持，我会继续写下去的，一起加油！
</content>
    </entry>
    
     <entry>
        <title>[转]C&#43;&#43;强大背后</title>
        <url>https://cppfans.org/1557.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>0x标准</tag><tag>C&#43;&#43;</tag><tag>程序员</tag><tag>语言</tag><tag>跨平台</tag>
        </tags>
        <content type="html">  在31年前(1979年)，一名刚获得博士学位的研究员，为了开发一个软件项目发明了一门新编程语言，该研究员名为Bjarne Stroustrup，该门语言则命名为——C with classes，四年后改称为C&#43;&#43;。C&#43;&#43;是一门通用编程语言，支持多种编程范式，包括过程式、面向对象(object-oriented programming, OP)、泛型(generic programming, GP)，后来为泛型而设计的模版，被发现及证明是图灵完备的，因此使C&#43;&#43;亦可支持模版元编程范式(template metaprogramming, TMP)。C&#43;&#43;继承了C的特色，既为高级语言，又含低级语言功能，可同时作为系统和应用编程语言。
C&#43;&#43;广泛应用在不同领域，使用者以数百万计。根据近十年的调查，C&#43;&#43;的流行程度约稳定排行第3位(于C/Java之后)。 C&#43;&#43;经历长期的实践和演化，才成为今日的样貌。1998年，C&#43;&#43;标准委员会排除万难，使C&#43;&#43;成为ISO标准(俗称C&#43;&#43;98)，当中含非常强大的标准模版库(standard template library, STL)。之后委员会在2005年提交了有关标准库的第一个技术报告(简称TR1)，并为下一个标准C&#43;&#43;0x而努力。可惜C&#43;&#43;0x并不能在200x年完成，各界希望新标准能于2011年内出台。
流行的C&#43;&#43;编译器中，微软Visual C&#43;&#43; 2010已实现部分C&#43;&#43;0x语法并加入TR1扩充库，而gcc对C&#43;&#43;0x语法和库的支持比VC2010更多。
应否选择C&#43;&#43; 哪些程序适宜使用C&#43;&#43;? C&#43;&#43;并非万能丹，我按经验举出一些C&#43;&#43;的适用时机。
 C&#43;&#43;适合构造程序中需求较稳定的部分，需求变化较大的部分可使用脚本语言； 程序须尽量发挥硬件的最高性能，且性能瓶颈在于CPU和内存； 程序须频繁地与操作系统或硬件沟通； 程序必须使用C&#43;&#43;框架/库，如大部分游戏引擎(如Unreal/Source)及中间件(如Havok/FMOD)，虽然有些C&#43;&#43;库提供其他语言的绑定，但通常原生的API性能最好、最新； 项目中某个目标平台只提供C&#43;&#43;编译器的支持。  按应用领域来说，C&#43;&#43;适用于开发服务器软件、桌面应用、游戏、实时系统、高性能计算、嵌入式系统等。
使用C&#43;&#43;还是C? C&#43;&#43;和C的设计哲学并不一样，两者取舍不同，所以不同的程序员和软件项目会有不同选择，难以一概而论。与C&#43;&#43;相比，C具备编译速度快、容易学习、显式描述程序细节、较少更新标准(后两者也可同时视为缺点)等优点。在语言层面上，C&#43;&#43;包含绝大部分C语言的功能(例外之一，C&#43;&#43;没有C99的变长数组VLA)，且提供OOP和GP的特性。但其实用C也可实现OOP思想，亦可利用宏去实现某程度的GP，只不过C&#43;&#43;的语法能较简洁、自动地实现OOP/GP。C&#43;&#43;的RAII(resource acquisition is initialization，资源获取就是初始化)特性比较独特，C/C#/Java没有相应功能。回顾历史，Stroustrup开发的早期C&#43;&#43;编译器Cpre/Cfront是把C&#43;&#43;源代码翻译为C，再用C编译器编译的。由此可知，C&#43;&#43;编写的程序，都能用等效的C程序代替，但C&#43;&#43;在语言层面上提供了OOP/GP语法、更严格的类型检查系统、大量额外的语言特性(如异常、RTTI等)，并且C&#43;&#43;标准库也较丰富。有时候C&#43;&#43;的语法可使程序更简洁，如运算符重载、隐式转换。但另一方面，C语言的API通常比C&#43;&#43;简洁，能较容易供其他语言程序调用。因此，一些C&#43;&#43;库会提供C的API封装，同时也可供C程序调用。相反，有时候也会把C的API封装成C&#43;&#43;形式，以支持RAII和其他C&#43;&#43;库整合等。
为何C&#43;&#43;性能可优于其他语言? 相对运行于虚拟机语言(如C#/Java)，C/C&#43;&#43;直接以静态形式把源程序编译为目标平台的机器码。一般而言，C/C&#43;&#43;程序在编译及链接时可进行的优化最丰富，启动时的速度最快，运行时的额外内存开销最少。而C/C&#43;&#43;相对动态语言(如Python/Lua)也减少了运行时的动态类型检测。此外，C/C&#43;&#43;的运行行为是确定的，且不会有额外行为(例如C#/Java必然会初始化变量)，也不会有如垃圾收集(GC)而造成的不确定性延迟，而且C/C&#43;&#43;的数据结构在内存中的布局也是确定的。有时C&#43;&#43;的一些功能会使程序性能优于C，当中以内联和模版最为突出，这两项功能使C&#43;&#43;标准库的sort()通常比C标准库的qsort()快多倍(C可用宏或人手编码去解决此问题)。另一方面，C/C&#43;&#43;能直接映射机器码，之间没有另一层中间语言，因此可以做底层优化，例如使用内部(intrinsic)函数和嵌入汇编语言。然而，许多C&#43;&#43;的性能优点并非免费午餐，代价包括较长的编译链接时间和较易出错，因而增加开发时间和成本，这点稍后补充。
我进行了一个简单全局渲染性能测试(512x512像素，每像素10000个采样)，C&#43;&#43; 1小时36分、Java 3小时18分、Python约18天、Ruby约351天。评测方式和其他语言的结果详见博文。
C&#43;&#43;常见问题 C&#43;&#43;源代码跨平台吗? C&#43;&#43;有不错的跨平台能力，但由于直接映射硬件，因性能优化的关系，跨平台能力不及Java及多数脚本语言。然而，实践跨平台的C&#43;&#43;软件还是可行的，但须注意以下问题：
 C&#43;&#43;标准没有规定原始数据类型(如int)的大小，需要特定大小的类型时，可自订类型(如int32_t)，同时对任何类型使用sizeof()而不假设其大小； 字节序(byte order)按CPU有所不同，特别要注意二进制输入输出、reinterpret_cast法； 原始数据和结构类型的地址对齐有差异； 编译器提供的一些编译器或平台专用扩充指令； 避免作应用二进制接口(application binary interface, ABI)的假设，例如调用函数时参数的取值顺序在C/C&#43;&#43;中没定义，在C&#43;&#43;中也不可随便假设RTTI/虚表等实现方式。  总括而言，跨平台C&#43;&#43;软件可在头文件中用宏检测编译器和平台，再用宏、typedef、自定平台相关实现等方法去实践跨平台，C&#43;&#43;标准不会提供这类帮助。
C&#43;&#43;程序容易崩溃? 和许多语言相比，C/C&#43;&#43;提供不安全的功能以最优化性能，有可能造成崩溃。但要注意，很多运行时错误，如向空指针/引用解引用、数组越界、堆栈溢出等，其他语言也会报错或抛出异常，这些都是程序问题，而不是语言本身的问题。有些意见认为，出现这类运行时错误，应该尽量写入日志并立即崩溃，不该让程序继续运行，以免造成更大的影响(例如程序继续把内存中错误的数据覆写文件)。若要容错，可按业务把程序分割为多进程，像Chrome或使用fork()的形式。然而，C&#43;&#43;有许多机制可以减少错误，例如以string代替C字符串；以vector或array(TR1)代替原始数组(有些实现可在调试模式检测越界)；使用智能指针也能减少一些原始指针的问题。另外，我最常遇到的Bug，就是没有初始化成员变量，有时会导致崩溃，而且调试版和发行版的行为可能不同。
C&#43;&#43;要手动做内存管理? C&#43;&#43;同时提供在堆栈上的自动局部变量，以及从自由存储(free store)分配的对象。对于后者，程序员需手动释放，或使用不同的容器和智能指针。 C&#43;&#43;程序员经常进一步优化内存，自定义内存分配策略以提升效能，例如使用对象池、自定义的单向/双向堆栈区等。虽然C&#43;&#43;0x还没加入GC功能，但也可以自行编写或使用现成库。此外，C/C&#43;&#43;也可以直接使用操作系统提供的内存相关功能，例如内存映射文件、共享内存等。
使用C&#43;&#43;常要重造轮子? 我曾参与的C&#43;&#43;项目，都会重造不少标准库已提供的功能，此情况在其他语言中较少出现。我试图分析个中原因。首先，C&#43;&#43;标准库相对很多语言来说是贫乏的，各开发者便会重复地制造自订库。从另一个角度看，C&#43;&#43;标准库是用C&#43;&#43;编写的(很多其他语言不用自身而是用C/C&#43;&#43;去编写库)，在能力和性能上，自订库和标准库并无本质差别；另外，标准库为通用而设，对不同平台及多种使用需求作取舍，性能上有所影响，例如EA公司就曾发表自制的EASTL规格，描述游戏开发方面对STL的性能及功能需求的特点；此外，多个C&#43;&#43;库一起使用，经常会因规范不同而引起冲突，又或功能重叠，所以项目可能须自行开发，或引入其他库的概念或实现(如Boost/TR1/Loki)，改写以符合项目规范。
C&#43;&#43;编译速度很慢? 错，是非常慢。我认为C&#43;&#43;可能是实用程序语言中编译速度最慢的。此问题涉及C&#43;&#43;沿用C的编译链接方式，又加入了复杂的类/泛型声明和内联机制，使编译时间倍增。在C&#43;&#43;对编译方法改革之前(如module提案)，可使用以下技巧改善：第一，使用pimpl手法，因性能损耗应用于调用次数不多的类；第二，仅包含必要头文件，并尽量使用及提供前置声明版本的头文件(如iosfwd)；第三采用基于接口的设计，但须注意虚函数调用成本；第四，采用unity build，即把多个cpp文件结合在一个编译单元进行编译；第五，采用分布式生成系统如IncrediBuild。
C&#43;&#43;缺乏什么功能? 虽然C&#43;&#43;已经非常复杂，但仍缺少很多常见功能。 C&#43;&#43;0x作出了不少改善，例如语言方面加入Lambda函数、闭包、类型推导声明等，而库方面则加入正则表达式、采用哈希表的unordered_set/unordered_map、引用计数智能指针shared_ptr/weak_ptr等。但最值得留意的是C&#43;&#43;0x引入多线程的语法和库功能，这是C&#43;&#43;演进的一大步。然而，模组、GC、反射机制等功能虽有提案，却未加进C&#43;&#43;0x。
C&#43;&#43;使用建议 为应用挑选特性集 我同意Stroustrup关于使用C&#43;&#43;各种技术的回应：“你可以做，不意味着你必须这么做。(Just because you can do it, doesn&amp;rsquo;t mean that you have to.)” C&#43;&#43;充满丰富的特性，但同时带来不同问题，例如过分复杂、编译及运行性能的损耗。一般可考虑是否使用多重继承、异常、RTTI，并调节使用模版及模版元编程的程度。使用过分复杂的设计和功能，可能会令部分团队成员更难理解和维护。
为团队建立编程规范 C&#43;&#43;的编码自由度很高，容易编写风格迥异的代码，C&#43;&#43;本身也没有定义一些标准规范。而且，C&#43;&#43;的源文件物理构成，较许多语言复杂。因此，除了决定特性集，每个团队应建立一套编程规范，包括源文件格式(可使用文件模版)、花括号风格。
尽量使用C&#43;&#43;风格而非C风格 由于C&#43;&#43;有对C兼容的包袱，一些功能可以使用C风格实现，但最好使用C&#43;&#43;提供的新功能。最基本的是尽量以具名常量、内联函数和泛型取代宏，只把宏用在条件式编译及特殊情况。旧式的C要求局部变量声明在作用域开端，C&#43;&#43;则无此限制，应把变量声明尽量置于邻近其使用的地方，for()的循环变量声明可置于for的括号内。 C&#43;&#43;中能加强类型安全的功能应尽量使用，例如避免“万能”指针void *，而使用个别或泛型类型；用bool而非int表示布尔值；选用4种C&#43;&#43; cast关键字代替简单的强制转换。
结合其他语言 如前文所述，C&#43;&#43;并非适合所有应用情境，有时可以混合其他语言使用，包括用C&#43;&#43;扩展其他语言，或在C&#43;&#43;程序中嵌入脚本语言引擎。对于后者，除了使用各种脚本语言的专门API，还可使用Boost或SWIG作整合。
C&#43;&#43;学习建议 C&#43;&#43;缺点之一，是相对许多语言复杂，而且难学难精。许多人说学习C语言只需一本K&amp;amp;R《C程序设计语言》即可，但C&#43;&#43;书籍却是多不胜数。我是从C进入C&#43;&#43;，皆是靠阅读自学。在此分享一点学习心得。个人认为，学习C&#43;&#43;可分为4个层次：
 第一层次，C&#43;&#43;基础：挑选一本入门书籍，如《C&#43;&#43; Primer》、《C&#43;&#43;大学教程》、或Stroustrup撰写的经典《C&#43;&#43;程序设计语言》或他一年半前的新作《C&#43;&#43;程序设计原理与实践》，而一般C&#43;&#43;课程也止于此，另外《C&#43;&#43; 标准程序库》及《The C&#43;&#43; Standard Library Extensions》可供参考； 第二层次，正确高效地使用C&#43;&#43;：此层次开始必须自修，阅读过《(More)Effective C&#43;&#43;》、《(More)Exceptional C&#43;&#43;》、《Effective STL》及《C&#43;&#43;编程规范》等，才适宜踏入专业C&#43;&#43;开发之路； 第三层次，深入了解C&#43;&#43;：关于全局问题可读《深入探索C&#43;&#43;对象模型》、《Imperfect C&#43;&#43;》、《C&#43;&#43;沉思录》、《STL源码剖析》，要挑战智商，可看关于模版及模版元编程的书籍如《C&#43;&#43; Templates》、《C&#43;&#43;设计新思维》、《C&#43;&#43;模版元编程》； 第四层次，研究C&#43;&#43;：阅读《C&#43;&#43;语言的设计和演化》、《编程的本质》(含STL设计背后的数学根基)、C&#43;&#43;标准文件《ISO/IEC 14882:2003》、C&#43;&#43;标准委员会的提案书和报告书、关于C&#43;&#43;的学术文献。  由于我主要是应用C&#43;&#43;，大约只停留于第二、三个层次。然而，C&#43;&#43;只是软件开发的一环而已，单凭语言并不能应付业务和工程上的问题。建议读者不要强求几年内“彻底学会C&#43;&#43;的知识”，到达第二层左右便从工作实战中汲取经验，有兴趣才慢慢继续学习更高层次的知识。虽然学习C&#43;&#43;有难度，但也是相当有趣且有满足感的。
数十年来，C&#43;&#43;虽有起伏，但她依靠其使用者而不断得到顽强的生命力，相信在我退休之前都不会与她分离，也希望更进一步了解她，与她走进未来。
本文原于《程序员》2010年8月刊揭载。
</content>
    </entry>
    
     <entry>
        <title>被高估人士的七个习惯</title>
        <url>https://cppfans.org/1556.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>习惯</tag><tag>管理</tag><tag>高估</tag>
        </tags>
        <content type="html">  写在前面：
最近一段工作下来，产生了挺多问题，听到的最多的话就是&amp;rdquo;千万不要高估别人&amp;rdquo;，而微博上正好看到了这篇文章，转过来给大家看看。
========================================================================================
我记得曾经和一个老同事之间有过这么一段对话，是关于另一个即将离职的员工。我说：“他的离开我们都不好受，尤其想到他在过去这几年为我们做的那些事。”但是这个同事的回答让我十分困惑。他说：“如果你仔细想一想的话，就会发现他其实什么也没有干。”这不是开玩笑吗！我立刻反驳并解释道：
在上一个版本里，他一直在……我认为他是那个组的成员之一，所以他在……或者说……好吧，不说上个版本的事。我知道在之前的版本里，他在帮助干……额……一些优化运行速度之类的事，我认为。等等，那好像是Bill干的。那他在做……也许是在那更之前的版本，当时他在……天啊！你是对的。他真的是什么都没干！
这到底是怎么回事？我的意思是，为什么我会得出与事实相去甚远的结论？我是白痴吗？如果只有我一个人这么想那么也许是这样，但是第二天我问别人对他的看法时，他们也是这么说的“他啊，我们肯定会想念他的。”这么看起来，不光是我一个人认为他是团队中重要的一员，而事实上他什么都没做。
自从那次之后，我开始关注团队中和合作项目中的人。我有机会作为一个团队成员、一个团队leader，甚至是一个老板又或者是一名一线员工，一个顾问，一个和多方合作的团队成员，以及一切你能够想到的角色来做这件事情。我观察之后发现不是因为人们愚蠢导致了评价过高的现象，反而是因为那个人本身就在做一些能够导致被高估的事。当你观察那些被高估的人时，就会发现他们有一些共同的习惯。
如果你也想要被高估的话，那么请继续往下看。被高估意味着你表现平平，但人们却认为你做了很大贡献；又或者是你毫无才能但是因为种种原因这点被忽略了，表现的就好像Peter Gibbons在电影《_Office Space_》中说的那样“刚刚不会被开除。”一般来说是你的真实价值和远远低于别人认为你的价值，你表现的非常有用但实际上却相当的废材。下面就告诉你如何办到这点。
1.”废话多多” 我把这个词用引号括起来，是因为它在我玩的一个叫“corporate BS Bingo card”的游戏里很常见，但在其他地方，我从来没见到过这个词。我实际上并不知道那个游戏里这个词是什么意思，而且据我所知，好像也没有什么特别的意思，所以我在这里来重新定义一下这个词。如果你想要看起来很高效但实际上什么都没做，一个好的办法是不停的打电话、发邮件、写备忘等。
大部分人都误解了高效所应该有的表现，这样你就可以利用这一点。如果你每天发送一两封邮件，总结当前项目的各种细枝末节，那么人们将会认为你是少数几个密切关注项目进程的人。如果你在发邮件之前，在项目组中来回走动，打电话，找人讨论确定当前他们在干的事情所处的状态，那么效果就会更好了。
我知道你现在在想什么，你认为也许这真的就是高效的表现呢？是的，有这个可能，当然也只是名义上的高效。但是你是否留意到你压根就没有得到一个明确的行动计划，而且这根本就跟项目实际上涉及到的内容毫无关系。一种表现的很有用但实际上无用的方法，是急切的投身到一件跟目标毫无关系的事情当中去。
2.专横且刻薄 成为一个“废话多”的人是一个好的开始，接着你可以通过命令周围人干事情，并挑出他们的毛病，来造成你很有效率的假象。如果你的日报（或者是时报）大家都会收到，那么就在日报里向别的团队成员发命令吧。“我们刚刚得到一个关于报告的小安排，所以Jim，如果你能够和Barbara合作检查一下我们生成的报告就好了。”关注项目的进程是一回事，但是能够推进项目进程就更好了。现在，如果你实际上没有真正的权力去发号施令，你也许会被他们叫出去谈谈，但是我敢打赌，你会惊奇的发现，这种情况很少发生。因为大多数人都避免发生冲突和争吵，你正好可以利用这一点。
但是如果你真的被叫出了（或者没有被叫出去），你一定要记住，保持刻薄。“我的老天，Jim和Barbara，这个报告到底怎么了！难道我必须要亲自来做吗？！”不要担心你要亲自去做，那不是计划的一部分。你只是要表明你很失望，然后利用一下别人羞愧的心理，去让他们完成这件事。这些默默无语的人执意叫你出去，是因为他们已经被防御性心理牵着鼻子走了，他们想要证明他们实际上在处理报告上非常的在行。
3.无耻的自我吹嘘 如果大量的废话和各种命令加上不断的批评，还不足以让人们相信你是多么的重要，那也没关系。我的这条建议有点像是“在你办到之前，一直装下去”，但不同之处在于你不必真的去办到。从你发出第一封邮件开始，你就开始四处走走，找人们聊聊你整理这些邮件是多么的困难，比方“我宁愿呆在家里陪家人，也不愿意夜里10点还在整理这些邮件，但是你知道的，如果我不这么做，我们都将遭殃。”不要担心，所谓的夜里10点只是一个形容罢了，你不必真的干到10点（后面会详细解释）。
类似的，如果你有受到过任何的批评，只需要罗列出你对于你们的竞争对手所做的一些事，并指出所有的人都认为这些事情干的漂亮。列出你在过去一个月里发出的每一封邮件，并且指出你发邮件的时间。在看了五到六封邮件之后，批评你的人就不得不放弃了， 并且承认你的工作确实非常的优秀，而他刚才只是冲昏了头。
4.改变讨论的细节 如果你不想煞费苦心的去寻找你工作的优秀的地方来很人谈论，那么你完全可以换个话题。如果有人在谈话中提到你上个月根本没有提交代码，你只需要指出，在你使用的版本控制系统里，提交代码并不是首要的事情，而是优化代码。到底是提交还是优化代码，区别看起来并不重要，但是这么说，作用却是非常的微妙。优化代码听上去就明显更加高端，它应该属于程序设计哲学的范畴，就像“软件工程艺术”一样。如果你照我所说的做了，你就会明白所谓的优化代码是指……哦，对了！其实你根本不知道我在说什么！
这个技巧不光可以用来对付批评者，同样的它也可以用来阻止那些个你不喜欢的政策的发布，或者是阻止你的同行所做的成就被认证。举例来说，比如Susan也许在版本计划之前就已经完成了一个非常大的功能，但是她的代码里用到了一些别人不建议使用的类，这意味着她的代码将来也许会有问题。所以，你就可以做些实验，就好像你真的能够把代码在读数据库和写文件时的运行时间减少个几纳秒似的。
5.保持自己看起来优秀（或者其他人看起来差劲） 如果你吹牛过头了，必须要写一些代码才能遮掩过去，你也能够轻松的摆脱这种情况。最常用和有效的办法是，想办法让项目延期或者是取消，然后把责任推卸到别人身上去。一个好办法是去构造一个巨大的沟通和理解上的差距，然后让它看起来是别人导致的而不是你。
我的意思是这样的。比如说你和Bill一起合作，Bill每天晚上6点回家。在6点零1分的时候，你给Bill发送一封邮件说你已经做好一切开始工作的准备，但缺少一个他写的父类。好了，这下15个小时白白浪费掉了，就因为Bill，因为他必须要第二天早上9点起床，才能回复你的邮件。如果你够幸运，他也许还需要一段时间才会看邮件，那你又多出来一两个小时了。
如果Bill意识到你这个技巧，然后多呆了几分钟，并且在晚上10点从家里发送这些邮件给你。那又怎么样呢？对你而言仅仅只是不在6点做这件事情，而改到了10点。现在，你只是少了几个小时罢了，不过你仍然有11个小时的空闲时间，并且你现在可以告诉别人你几乎整天都在工作，只是要忍受一个像Bill这样的白痴，必须等12个小时才会给你所需的关键信息，不然你真的是全天候工作了。
6.提前准备好借口 这一点用个例子来说明再好不过了。很多年前，我领导的一个项目里有一个海外的顾问就是提前准备借口的专家。这个人的工作头衔是类似“软件工程师”一类，但是我从来没有在他身上看到任何和软件或者是工程师相关的东西。一天早上我来到公司，然后给他发短信，想看他昨天晚上的任务进展的怎么样了。他回复问我是否看了他昨天晚上发的邮件。我还没看，所以我立马去看了一下，邮件里写道“钟是错的，所以我没办法进展下去了，请见谅。”
经过一番了解，我终于明白了他指的是他电脑桌面上的时钟是错的。他告诉我，他不确定时间的错误是否会影响到任务中的一个需要长时间的上传功能，我问他这两者怎么可能有关系呢？他居然不熟悉linux的设备驱动，他居然不知道怎么去修改时间。我真的没有在搞笑。一个软件工程师不知道如何去修改他电脑的时间，而且还认为时间的错误会对上传功能造成影响，事实上上传跟电脑时间半毛钱关系都没有。这就是关于他的故事，而且他还在不断制造这样的事。
总的来说，他是一名”Windows和多个发行Linux系统方面的专家”，但是设备驱动方面他没有接触过，所以他怎么可能在没有我的指导下，完成这个不可能完成的任务？而且退一万步说，如果真是他一个人干的，那我整晚都在干什么呢？睡觉？真是气死我了。
7.取得无法被反驳的成绩 为了让你能够悠哉自在，而且不被指责懒惰，你需要提前准备好理由，同时，你还需要拿到一些可以证明你做出了贡献的证据，当然这个不是我们技巧上的失误。一个关于这点的好的例子，比如你必须要确保你提交过几行代码，这样一旦项目成功了，你的名字就会出现在庆功会的邀请名单里。而一旦你参加了那场庆功会，就没有人能够否认你做出了贡献。
但是即使这样也不是绝对的可靠，因为，任何人只要看一眼你增加的那三行空格，就会指出你对项目的成功没有任何贡献。所以，我给出的建议是，做一些主观上的事情。比如给出一大堆你自己的建议，之后再指出你给出过关于“领导力和指导”方面的建议。在后来的发布会上（或者是总结会），当你被问到是否是项目leader的时候，人们会想起你之前提到过，给出了领导方面的建议，所以你可以表现的勉强且不耐烦的回答“你可以这么认为。”这正是你想要的。如果你确实按照我上面第三点谈到的自我吹嘘那样做了，那么当你被问及你的主张时，所需要的仅仅是没有人站出来指出你在撒谎。
你真的要这么做吗？ 我来告诉你应该怎么做。如果你正在考虑要不要按照这些来做的时候，请放弃吧。如果你当前正在做上面提到的这些，请停止吧。我本来不想说这些，因为你可能无法接受，但是我还是要为做出这些行为的人进行辩护。我非常严肃的给出上面这个建议。那些正在这样干，并把这当作生活当中的必经之路的人，你们不会想到，其实你们的这些行为表明了更多的事情。为什么你不停的跳槽？为什么你和你同事之间有这么多的不愉快？
我曾经读过一份关于慷慨的本质的研究报告，里面说到表现的慷慨有助于长远的利益。显然的，慷慨的人在他们困难的时期更容易得到帮助。报告里还指出，表现慷慨最好的方式就是变得真的慷慨，因为假装慷慨，通常都会被发现，最后被边缘化。而想要做错事情仅仅只需要你吝啬就够了。这个道理对于工作中的努力和才干是一样的。如果你不喜欢你的工作，或者是发现它让你不知所措，那么你就可以考虑做一些其它的事情，或者是找到一个环境，能够符合你的节奏，而不是被工作所操控，或者是耍些小把戏。这样，你和周围的所有人都会感到愉快。
原文链接： Erik Dietrich 翻译： 伯乐在线 - 菜鸟浮出水
译文链接： http://blog.jobbole.com/54364/
[ 转载必须在正文中标注并保留原文链接、译文链接和译者等信息。]
</content>
    </entry>
    
     <entry>
        <title>[转]被诅咒的程序员的七宗罪</title>
        <url>https://cppfans.org/1546.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>七宗罪</tag><tag>程序员</tag>
        </tags>
        <content type="html">  七宗罪（Seven deadly sins），13世纪道明会神父圣多玛斯·阿奎纳列举出各种恶行的表现。这些恶行最初是由希腊神学修道士庞义伐草撰出8种损害个人灵性的恶行，分别是贪食、色欲、贪婪、暴怒、懒惰、伤悲、自负及傲慢。
程序员生来不平等。有的伟大。有的渴望伟大。有的就是废物。
下面是一些程序员经常会走入的歧途。听起来很恐怖，但享用吧。上帝就在你身边，警惕这些危险的信号，跟随主救赎的指引。
1. 色慾（Lust） 凡犯色欲者：在硫磺和火焰中熏闷
作为程序员，这种罪恶的表现是不断的受绚丽的新事物的诱惑。下一代编程语言，最新的框架，最新的平台。
我们程序员天生好奇。我们受惑于追求高效，坚信所有的东西都要经过优化。只有用了那种最新的语言，我们才能工作。
虽然不断的追求改进是非常值得赞赏，但采用新事物也是有代价的。有避免不了的学习曲线。有适应问题。有未知的依赖问题。有未知的未知问题。
清除这些杂念。专心解决你手头上的问题。充分利用你知道的，停止贪恋那些光鲜新事物。
2. 贪食（Gluttony） 凡犯贪食者：强迫进食老鼠，蟾蜍和蛇
这是过度之罪。过度的企图多做，过度的扩展深度和广度。
不必要的功能特征溜进了产品里。大量无用的代码被生产出来。宝贵的编程时间被消耗，被浪费。
这些行为增加了不必要的复杂度，带来的高昂的维护代价。通常导致的结果是，预期不能完工。bug层出不穷。
警惕那些不该有的功能、警惕那些对不必要的复杂架构的伪辩护、警惕过早优化的迹象。让产品简洁。
3. 贪婪（Greed） 凡犯贪婪者：在油中煎熬
过度专业化和功能化会导致形成个人的领地。固步自封。我的代码。我的模块。我相干的区域。没有分享。没有合作。
一种不健康的对这些人的依赖会逐渐形成。所谓的“编程教父”，“编程巨星”和“编程领袖”就代表了这些趋势。
相反，应该建立一个崇尚代码集体所有和充分合作(比如结对编程或相互代码审查)的文化。
4. 怠惰（Sloth） 凡犯懒惰者：丢入蛇坑
根据Perl语言的创造者Larry Wall的话，懒惰是程序员的三个伟大美德之一。
但懒惰不能和冷漠混为一谈。长时间不理出现的问题。允许代码腐烂异味。不重构拷贝/粘贴过来的重复代码。
对软件开发中这些需要修改的东西要有一种紧迫感。事无巨细。这是保持软件健康的必要态度。
5. 暴怒（Wrath） 凡犯暴怒者：活体肢解
在有些地方，有些程序员是每个人都尊敬，也是每个人都害怕。你也许遇到过这样的火星极客。他们恃才放旷，为所欲为，其他人在他身边都惦着脚走。避免和他冲突。
他们喜怒无常，他们的怒气经常撒错方向。他们贬低他人，破坏团队和谐。
警惕这种不受约束的对峙气氛的滋生。拒绝忍受这样的撒野。立即辞掉他们。
6. 妒忌（Envy） 凡犯妒忌者：投入冰水之中
不满足于现有的工具和系统，有些程序员眼睛总是盯着别人的。
我曾经遇到过这样的经历，一个wiki系统正在使用中，另外一个却同时被引进，因为它的标记语法感觉更好一些。两个问题跟踪系统，多种聊天系统，不兼容的博客平台，等等。
如果你不喜欢某个工具，相信有比它更好的，那好，去找到它，使用它。但是，请完全放弃你现有的。吃着碗里又想占这锅里，只会得不偿失，给自己制造麻烦。
7. 傲慢（Pride） 凡犯傲慢者：轮裂
有些程序员喜欢孤芳自赏。对自己的能力过度自信。从不寻求帮助。
更 糟糕的，他认为所有的事情都应该由自己来完成。虽然他有能力完成任何的任务，但他却没能完成，因为他承担的太多了，无法集中精力。他分不清什么是核心什么 是次要的。在可以使用云服务时他建造自己的服务器，在能使用成熟的部署系统时他重新发明自己的，他开发出跟现有框架功能相同的框架，等等。
诚然，做研究是有趣的。这些研究经常被辩称为“基础”或“革新”，但却因没有更快捷的创造商业价值而使产品丧失市场先机。
小心“非我发明(Not Invented Here)”综合征。准确的定义你的核心目标，你的首要工作。其它的都是次要的，可以借用别人的。这没有什么好羞愧的。
[英文原文：7 Sins of Doomed Teams ]
</content>
    </entry>
    
     <entry>
        <title>字库识别网站——求字体网</title>
        <url>https://cppfans.org/1537.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>字体</tag><tag>设计</tag><tag>识别</tag>
        </tags>
        <content type="html"> 看到别人网站上的一些字体比较好看，却苦于不知道是什么字体，搜索来到了求字体网站，网站的功能很简单，上传图片分析字体，并且提供输入字体名预览的功能。
上传了字体图片之后，发现识别出来了，并且非常准确，就是博客logo的字体，是方正正准黑简体，识别结果还是非常满意的。
大家如果有什么觉得美观，却不知道是哪种的字体，可以上传图片试试！
网站地址：求字体网
</content>
    </entry>
    
     <entry>
        <title>linux下link错误undefined reference&#39;dlclose&#39;</title>
        <url>https://cppfans.org/1519.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>dlclose</tag><tag>Linux</tag><tag>pthread</tag><tag>undefined reference</tag>
        </tags>
        <content type="html"> 最近因为换了工作，服务器是在linux环境下，又开始捣鼓linux了，与同事两天的奋战中，发现差不多可以写一本《某哥的linux私房菜》了，开个玩笑。
对于linux我持中立态度，而且我认为linux这么多年发展比较慢的原因是因为桌面化做的不好或者不够好，所以我比较偏爱ubuntu。
由于以前项目是makefile的，我个人不是很喜欢makefile，因为他看起来比较费劲，而且编译完成后出现问题调试是个大难题，不是每个人都精通gdb，而且vi上手比较难。所以将工程转为codeblocks的cbp，本来想使用cmake的，但是觉得要写的比较多，于是作罢，毕竟代码不是跨平台的，windows下没法用。
编译完link的时候，报了一句undefined reference&amp;rsquo;dlclose@xxx函数&amp;lsquo;，不知道什么问题了，找主程过来看了下，说是dl库没有包进去，查了下dl库是用来做动态库加载的(dynamic load)，项目用到了libmysqld.so，加了之后还是有问题，将-ldl链接选项改到最后才可以。
&amp;nbsp;
总结了下这些比较常见的undefined reference问题：
1.dl库
undefined reference to &amp;lsquo;dlerror&amp;rsquo;
undefined reference to &amp;lsquo;dlopen&amp;rsquo;
undefined reference to &amp;lsquo;dlerror&amp;rsquo;
增加-ldl链接选项 (-l是链接选项的前缀)
2.pthread库
undefined reference to &amp;lsquo;pthread_create&amp;rsquo;
undefined reference to &amp;lsquo;pthread_xxxx&amp;lsquo;
增加-lpthread链接选项
3.rt库
undefined reference to `clock_gettime&amp;rsquo;
增加-lrt链接选项
&amp;nbsp;
如果是使用codeblocks，可以再link option里加，不过因为依赖顺序的问题，如果link option里加了还是报错，直接在link file里添加pthread dl rt等即可
如果是你自己的库出现这undefined reference什么函数，先去查下库的源代码，看看具体问题。
</content>
    </entry>
    
     <entry>
        <title>[转]告诉你How To一眼认出英语单词的意思</title>
        <url>https://cppfans.org/1515.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>单词</tag><tag>快速</tag><tag>英语</tag><tag>记忆</tag>
        </tags>
        <content type="html"> via:http://blog.30c.org/2800.html
请大家想一想，英语是谁发明的？英国人呗！英国人认不认识汉语？不认识！那么英国人在学英语单词的时候需不需要记住单词的汉语意思？不需要，英国人的英语课本里根本就没有汉字，何谈记住单词的汉语意思？那么既然英国人学英语不需要记住(甚至根本就见不到)单词的汉语意思，那么中国人学英语为什么要去记住单词的汉语意思呢？这种做法大家不觉得奇怪吗？
然而由于中国人学英语时都在背单词的汉语意思，因此大家反而觉不出“背汉字”有什么奇怪的了。其实仔细想一想，这个行为真的很奇怪，奇怪的根源不在于行为本身，而在于中国人普遍不会直接识别英语单词的意思，因而只好靠汉语符号来机械地帮助记忆英语单词的意思，这样去学英语不仅多此一举，而且必然会陷入苦海无边的符号记忆灾难中。
其实英语单词和汉字一样，存在着很多的“偏旁部首”，知道了偏旁部首你就可以根据它们直接来猜测单词的意思，虽不说百分之百猜准，但起码可以猜测个大概，至少在别人告诉过你单词的意思后你可以恍然大悟地领会它，这样就可以大大增强你对英语单词“见字识意”的能力，做到真正认识一个单词，而把它的汉语意思仅做为一般参考。
举几个例子来说吧：
比如单词representative，请别急着告诉我你认识这个单词，其实你不见得“认识”这个单词，你仅是凭着你的记忆力记住了这串英语字母和两个汉字符号“代表”之间的对应关系，这样去学英语你会多费劲？下面我来告诉你这个单词为什么是“代表”的意思。re在英语里是一个偏旁部首，它是“回来”的意思；pre也是一个偏旁部首，是“向前”的意思；sent也是一个偏旁部首，是“发出去、派出去”的意思；a仅是偏旁部首之间的一个“连接件”，没了它两个辅音字母t就要连在一起了，发音会分不开，会费劲，因此用一个元音字母a隔开一下；tive也是一个偏旁部首，是“人”的意思。那么这几个偏旁部首连在一起是什么意思呢？re-pre-sent-a-tive，就是“回来-向前-派出去-的人”，即“回来征求大家的意见后又被派出去替大家讲话的人”，这不就是“代表”的意思吗！这么去认识一个单词才是真正“认识”了这个单词，把它认识到了骨子里。
再举一个例子吧：psychology。
psy=sci，是一个偏旁部首，是“知道”的意思；cho是一个偏旁部首，是“心”的意思；lo是一个偏旁部首，是“说”的意思；gy是一个偏旁部首，是“学”的意思，logy合起来是“学说”的意思。因此psy-cho-logy连起来就是“知道心的学说”，因此就是“心理学”的意思。
依此类推，不多举例了，我要表达的观点已经清楚了，那就是，不要去死记硬背单词的汉语意思，而要用识别“偏旁部首”的方法去真正认识一个单词，真正认识了单词后，你会发现单词表里的汉语翻译原来其实很勉强，有时甚至根本翻译不出来，因为汉语和英语是两种不同的文字体系，两者在文字上本来就不是一一对应的，只背英语单词的汉字意思是不能真正认识这个单词的，会造成很多的后续学习困难，会造成你一辈子看英语单词如雾里看花，永远有退不掉的陌生感。
那么接下来的问题是，英语里有多少个“偏旁部首”，怎样知道和学会它们？
回答这个问题时我才发现中国人对英语偏旁部首陌生的两个主要原因，一是这些重要内容不在学校的英语教材当中，大家在课堂上学不到(这是目前学校英语教材急需弥补的缺陷)；二是少数书店里销售的有关这方面内容的书过分复杂化，动辙几百上千页，内容苦涩庞大，影响了这些常识的普及，使得本来是常识的东西不常识。其实英语里偏旁部首的学名叫“字根”，常用的也就二百多个，它们就像26个字母一样普通而重要，就像汉语里的偏旁部首那样普通而重要，它们是学英语第一课里就应该学习的重要内容，学英语者应及早地掌握这些重要的常识，及早地摆脱死记硬背的蛮干状态，及早地进入科学、高效的识字状态。
【英语字根】
1,ag=do,act 做，动
2,agri=field 田地，农田(agri也做agro,agr)
3,ann=year年
4,audi=hear听
5,bell=war战争
6,brev=short短
7,ced,ceed,cess=go行走
8,cept=take拿取
9,cid,cis=cut,kill切，杀
10,circ=ring环，圈
11,claim,clam=cry,shout喊叫
12,clar=clear清楚，明白
13,clud=close,shut关闭
14,cogn=known知道
15,cord=heart心
16,corpor=body体
17,cred=believe,trust相信，信任
18,cruc=cross 十字
19,cur=care关心
20,cur,curs,cour,cours=run跑
21,dent=tooth牙齿
22,di=day 日
23,dict=say说
24,dit=give给
25,don=give给
26,du=tow二
27,duc,duct=lead引导
28,ed=eat吃
29,equ=equal等，均，平
30,ev=age年龄，寿命，时代，时期
31,fact=do,make做，作
32,fer=bring,carry带拿
33,flor=flower花
34,flu=flow流
35,fus=pour灌，流，倾泄
36,grad=step,go,grade步，走，级
37,gram=write,draw写，画，文字，图形
38,graph=write,records写，画，记录器，图形
39,gress=go,walk 行走
40,habit=dwell居住
41,hibit=hold拿，持
42,hospit=guest客人
43,idio=peculiar,own,private,proper特殊的，个人的，专有的
44,insul=island岛
45,it=go行走
46,ject=throw投掷
47,juven=young年轻，年少
48,lectchoose,gather选，收
49,lev=raise举，升
50,liber=free自由
51,lingu=language语言
52,liter=letter文字，字母
53,loc=place地方
54,log=speak言，说
55,loqu=speak言，说
56,lun=moon月亮
57,man=dwell,stay居住，停留
58,manu=hand手
59,mar=sea海
60,medi=middle中间
61,memor=memory记忆
62,merg=dip,sink 沉，没
63,migr=remove,move迁移
64,milit=soldier兵
65,mini=small,little小
66,mir=wonder惊奇
67,miss=send 投，送，发(miss也作mit)
68,mob=move动
69,mort=death死
70,mot=move移动，动
71,nomin=name名
72,nov=new新
73,numer=number 数
74,onym=name 名
75,oper=work工作
76,ori=rise升起
77,paci=peace和平，平静
78,pel=push,drive推，逐，驱
79,pend,pens=hang悬挂/weigh称量/pay支出，付钱，花费
80,pet=seek追求
81,phon=sound声音
82,pict=paint画，描绘
83,plen=full满，全
84,plic=fold折，重叠
85,pon=put放置
86,popul=people人民
87,port=carry拿，带，运
88,pos=put放置
89,preci=price价值
90,punct=point,prick点，刺
91,pur=pure清，纯，净
92,rect=right,straight正，直
93,rupt=break破
94,sal=salt盐
95,scend,scens=climb爬，攀
96,sci=know知
97,sec,sequ=follow跟随
98,sect=cut切割
99,sent,sens=feel感觉
100,sid=sit坐
101,sist=stand站立
102,son=sound声音
103,spect=look看
104,spir=breathe呼吸
105,tail=cut切割
106,tain,ten,tin=hold握，持，守
107,tect=cover掩盖
108,tele=far远
109,tempor=time时
110,tend(tens,tent)=stretch伸
111,terr=land,earth土地，陆地
112,text=weave纺织
113,tract=draw拉，抽，引
114,un=one一
115,urb=city城市
116,vac,vacu=empty空
117,vad,vas=walk,go行走
118,vari=change变化
119,ven=come来
120,vert,vers=turn转
121,vi,via=way道路
122,vis,vid=see看
123,vit=life生命
124,viv=live活
【第二部分，多认词根，多识单词】
125,aer(o)空气，空中，航空
126,alt高
127,am爱
128,ambul行走
129,anim生命，活，心神，意见
130,anthrop(o)人，人类
131,aqu水
132,arch统治者，首脑archy 统治
133,avi鸟
134,bat打
135,biblio书
136,birg战斗，打
137,cad,cas降落，降临
138,cert 确定，确信
139,chron时
140,cid降落，降临
141,clin倾
142,cosm(o)世界，宇宙
143,cracy统治crat支持
144,cub躺，卧
145,cult耕，培养
146,cycl(o)圈，环，轮
147,dem(o)人民
148,dexter右
149,doc教
150,dom屋，家
151,dorm睡眠
152,drom跑
153,ego我
154,err漫游，走，行
155,fabl,fabul 言
156,feder联盟
157,ferv沸，热
158,fict,fig塑造，虚构
159,fid信任
160,fil线
161,flat 吹
162,flect,flex弯曲
163,flict打击
164,frag,fract破，折
165,frig冷
166,fug逃，散
167,fund,found底，基础
168,gam婚姻
169,gram谷物，谷粒
170,grav重
171,greg群，集合
172,gyn,gynce(o)妇女
173,hal呼吸
174,helic(o)螺旋
175,hes,her粘着
176,ign火
177,integr整，全
178,junct连接，连结
179,later边
180,leg读
181,leg,legis法
182,luc光
183,lumin光
184,magn(i)大
185,matr(i)，metro母
186,mega大
187,mens测量
188,ment心，神，智，思，意
189,min伸出，突出
190,misc混合，混杂
191,mis(o)恨，厌恶
192,mon告诫，提醒
193,mon单独，一个
194,mur墙
195,mut变换
196,nat诞生
197,nav船
198,nect,nex结，系
199,negr,nigr黑
200,nihil无
201,noc,nox伤害
202,noct(i)夜
203,norm规范，正规，正常
204,nutri营养
205,orn装饰
206,par生，产
207,parl说，谈
208,past喂，食
209,path(o)，pathy疾病，疗法
210,patr(i)父，祖
211,ped脚，足
212,ped儿童，小孩
213,petr(o)石
214,phag吃
215,phil(o)爱
216,phob(ia)怕
217,plex重叠，重
218,polis城市
219,prim第一，最初
220,radic根
221,ras,rad擦，刮
222,rid,ris笑
223,rod,ros咬，啮
224,rot轮，转
225,rud原始，粗野
226,rur,rus农村
227,sat,satis,satur足，满，饱
228,sen老
229,simil,simul相似，相同
230,sol单独
231,sol太阳
232,soph智慧
233,sper希望
234,spers,spars散，撒
235,splend发光，照耀
236,stell星
237,tact,tag触
238,the(o)神
239,ton音
240,tort扭
241,tour迂回，转
242,trud,trus推，冲
243,tut,tuit监护，看管
244,umbr阴影
245,ut,us用
246,vas走，漫游
247,val强
248,van空，无
249,ver(i)真实
250,voc,vok声音，叫喊
251,vol,volunt意志，意愿
252，volu,volv滚，转
这些叫词根词缀。拉丁语系所有的语言以及衍生语言都是由前缀&#43;词根&#43;曲折变化、复合、派生&#43;后缀组成的。在国外学语言学，音位学，语法的都要学习词语构成。国内官方机构的英语教学说实话很不成熟。教学方式很害人。根本不科学，不专业，不系统。很多写教材的人自己就不专业，背了两篇课文记了基本字典就觉出来教学了。语法全部掰碎了来讲，根本不系统。而且语言这个东西是习惯性的，是一步一步积累的，国内全部讲究速成，速记，速考，速忘。搞不懂的就死背。完全没有引入系统的语言学，语法，音位学，语音学。学徒怎么可能体会到语言构成形成的奥妙。国内的外语都是拿来应考的，不是拿来使用的。大陆在外语研究的水平上远远不及港台，日韩。到现在我们连一本专门的解释外部语言历史，发展，结构的译本都没有，可是在国外到处都是，装备到高中图书馆。倒不是因为大陆人少，出国的人少，是因为机制和动机就有毛病。
</content>
    </entry>
    
     <entry>
        <title>goagent3.0.8解决翻墙404问题</title>
        <url>https://cppfans.org/1514.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>404</tag><tag>goagent</tag><tag>新版本</tag><tag>翻墙</tag>
        </tags>
        <content type="html"> 貌似在双十一前几天，不知道GFW搞了什么东西，导致goagent无法翻墙，一直提示404错误。微博上很多人都在说，去看了下goagent项目，发现有新版本了，项目地址：https://code.google.com/p/goagent/
本次更新主要是增加了google_cn和google_hk的模式，并可以混合使用，详见proxy.ini文件或项目更新内容，使用方法很简单，官方给出来的如下：
 如何部署和使用goagent，以Windows为例  申请Google Appengine并创建appid。 下载goagent最新版 https://code.google.com/p/goagent/ 修改local\proxy.ini中的[gae]下的appid=你的appid(多appid请用|隔开) 双击server\uploader.bat(Mac/Linux上传方法请见FAQ)，上传成功后即可使用了(地址127.0.0.1:8087) chrome请安装SwitchySharp插件，然后导入这个设置https://goagent.googlecode.com/files/SwitchyOptions.bak，或备份下载地址 firefox请安装FoxyProxy，Firefox需要导入证书，方法请见FAQ   上面提到的FAQ详见项目页面
&amp;nbsp;
修改proxy.ini中自己的appid后，打开local.exe，用chrome插件翻墙，所有都正常了，不过感觉速度变慢了。
还在为翻墙404问题烦恼吗，试试新版本吧。
</content>
    </entry>
    
     <entry>
        <title>十一桂林行</title>
        <url>https://cppfans.org/1509.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>十一</tag><tag>旅行</tag><tag>桂林</tag><tag>自然风景</tag>
        </tags>
        <content type="html"> 不知不觉间，10.1已经过完了，之前打算的是去看下侄女（亲侄女哦，现在不到百天）。顺道看看桂林的风景，换个心情，调整下自己。
因前面也没事情，于是请了两天年假，9.29日下午的火车，不料却晚点到晚上了，整整三个小时，不过上车后还算顺利，第二早睡醒后在株洲又因为线路问题，又停了三个小时，直接浪费了我半天的时间，现在就想问问，这事儿到底有人管没有？
到了之后，看到了可爱的侄女，一副昏昏欲睡的样子，实在是cute，因不懂得怎么抱，也没敢上手抱。
第二天下午去看了下芦笛岩，是桂林溶洞的代表景观，里面的钟乳石千奇百怪，加上灯光的衬托，显得更加别致了，里面看到了83西游记的一些取景地点，例如龙宫大厅，龙王宝座，水月洞天等景观。导游的讲解也很到位，各种形状的石头组成了一副又一副的风景，例如大闹龙宫，成片的蘑菇，仙人，孙悟空，狮望朝霞等等。
晚上去游了两江四湖，两江是指漓江和桃花江，四湖是杉湖、榕湖、桂湖、木龙湖，四个湖是通过工程手段与河流水位有差别，途经四座大桥，体现了国内外桥梁技术和人文风景，比较有印象的是有一座纯水晶打造的小桥，可以容纳30个成年人的重量。杉湖中还有著名的日月双塔，其中日塔共9层41米高，消耗350吨纯铜打造，月塔是7层35米高的8角宝塔，用琉璃装修，看到这些我真想说，全部打包带走。
2号一天早早的起来去了阳朔一日游，顺着漓江去阳朔，共80多公里，一路风景如画，比较特别就是九马画山和￥20块背后的风景，然后就是5个景点，月亮山、大榕树、聚龙潭、奇石宫、鉴山寺。其中月亮山和长城分别代表了国内自然风景和人文风景，大榕树是类似一个公园，里面有一个千年榕树，因榕树树根交缠在一起，故象征着爱情，又说是阿牛哥和刘三姐的定情地点。聚龙潭是类似芦笛岩，是坐船到洞口，然后进去看钟乳石奇景。奇石宫是聚龙潭完了之后一个展出因地质变化产生的各种形状的石头，大部分是未结晶的水晶和玉，拍到一个关二爷，一整块石头雕成的。鉴山寺就不多说了，商业气氛太浓了，不甚喜欢，里面的三尊佛像金碧辉煌的，最神奇的是左右有四大天王，摩氏四兄弟到底是道家的还是佛教的？
总体来说，桂林的自然风景是非常不错，我长期在上海，已经很少看到这样的风景了，多看看，体验下自然，改变下心境，还是很有好处的。最想说的是因为漓江穿过桂林，导致桂林沿江散步的感觉很棒，很适合居住，看到那些老人在打牌，其乐融融。差劲的就是路太窄了，而且过马路各种乱穿，可能跟长期的习惯有关吧，就不多说了。总之呢，桂林是个不错的地方，值得去看看，最好不好在黄金时间去，其他时间去，可以慢慢观赏。
最后，愿小侄女身体健康，越长越漂亮。
btw.照片我稍后会放在QQ空间，大家有兴趣可以去看下。
</content>
    </entry>
    
     <entry>
        <title>因主机流量用光导致无法访问的致歉</title>
        <url>https://cppfans.org/1506.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>致歉</tag>
        </tags>
        <content type="html"> 昨天和今天本站博客和论坛均无法访问，昨天晚上查看了下因为流量用光了，导致所有网页均无法打开，刚刚与空间商沟通后升级了主机套餐，现在已经没有问题了，对出现的问题表示歉意，希望大家可以继续来本站坐坐。
</content>
    </entry>
    
     <entry>
        <title>答某位朋友邮件中关于编程风格的问题</title>
        <url>https://cppfans.org/1497.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>命名规则</tag><tag>编程规范</tag>
        </tags>
        <content type="html"> 今天有位朋友邮件问我了一些关于编程风格的问题，先引用下邮件原文：
 eliteYang，您好，一直喜欢看你的博客，一直觉得你是一个对程序对生活都要求质量高的人，因为我太热爱程序，但是同时也对美的定义有了更加严格的要求。所以最近有些迷茫，想听听你的怎么处理这些问题的。
比如1.你平时代码写注释的时候，如果用英文写的话，是习惯全小写原则还是习惯首字母大写的原则？因为我看了观察了几本C&#43;&#43;国外的英文原版，发现他们写注释往往都喜欢通篇小些，一旦写自己的文件头或者自己的作者名的时候就喜欢用首字母大写，我想听听你的想法
2.还有平时在Linux和Windows两者系统之间切换的时候，你命名或者文件夹有没有什么区别，可以举点例子吗？比如同样的project和Project或者同样的MyTest和mytest(my_test)，你的习惯是什么样的？我对这种命名该不该大写会一直很在意，我也不知道是不是程序员做的久对任何事物都会有一种近乎完美的控制，一会切到windows一会切到linux,能简单的谈下你对大小写的理解和控制吗？是主推大小写还是主推小写的多，包括平常在手机上打字，类似要大写的时候也会这样吗？是坚持标准的首字母大写还是小写。
3.我就想问下像我这种毛病的人还有救吗？经常会为这些事情所纠结，而且往往会影响平时的工作效率，比如创建文件夹的时候我就会想是首字母大写好看呢还是全小写来保持统一呢（Movie，movie，mytest，MyTest），当写程序注释的时候我会想是写// this function proves that&amp;hellip;好呢还是// This function proves that..
4.eliteYang，我不知道我这种对大小写在意的习惯是一种好习惯还是一种坏习惯，我做不到一般人所谓的那种随意，想到什么写什么，我就是比较想统一，比较想一致，但是冲突存在windows和Linux之间，希望eliteYang能够牺牲点时间说下你的想法，洗耳恭听。谢谢！
感谢如此认真的回答我的问题，非常感谢，呵呵，我的意思还有就是抛去编程以外的范畴，像MyMovie,MyPhoto如此之类的，你更倾向于这种形式，还是mymovie的Linux形式。生活当中，当你触及一些英语的时候，你还会认真去考虑过首字母大写的问题吗？会不会这种东西往往会影响自己的思路或者打断自己的思路。因为我不敢确定养成这种首字母都大写的习惯会不会影响自己以后的工作效率或者生活效率（PS：常常要多按一个键），请豆子哥开导开导，因为Linux和Windows之间的来回穿梭，工作和生活上的文件工程名，目录名都会让我困扰，包括手机用户名和电脑用户名，我也会去纠结大小写的问题，似乎想要一招鲜吃遍天，感觉自己想要极端化，就是要么全小写要么全大写，一定要找出那个最适合的方法，但效果往往不尽如人意。有时候我会觉得全小写比较好（因为速度快，可以加快工作效率和生活效率（写小便签的时候）），但有时候也会觉得全小写很丑，有个首字母大写来过渡似乎更舒服，所以一直处在这两者之间犹豫。问过身边的同事和朋友，都觉得我神经病，会去考虑这些，但我真的为这件事情给困扰了，再次谢谢你
 其实这个问题我看到的时候，第一反应是这位署名为 LionFlex的朋友中度强迫症，而且很纠结。这个问题从头到尾的意思就是问编程中一些关于大小写的问题。
先说下我的习惯吧：
我以前的习惯是windows风格，因为我原来大部分时间在windows上写代码，而且再加上当年mfc的残留症，喜欢用驼峰命名法，也就是m_OneTwo这样的风格，不过如今接触linux时间越多之后，逐渐变成了小写字母&#43;下划线的方式，例如：one_two，通过我的博文大家应该也会感受到我编程风格的变化，总结为下面几点吧！
1.代码风格为小写字母 &#43; 下换线的方式，例如：one_two
2.括号风格为最外层括号不加空格，里面的符号加空格，例如：((a &#43; b) / (c &#43; d))
3.英文注释一般是首字母大写，与英语语法一致
4.文件夹命名也是小写字母 &#43; 下划线方式
下来再回答你的问题：
1.如果用英文写注释，一般的风格是跟英文语法一致，首字母大写，关于你说的那些英文书籍中，很多首字母小写的，这可能是这些人自己的习惯，从boost库来看，一般都是首字母大写，还有一些关键的单词全词大写。作者名字大写是因为英文名字一般都是首字母大写的，当然了，如果你的代码和文档大部分都是国人看，可以注释成中文的，这样就没有任何纠结了
2.linux和windows系统切换时，文件和文件夹命名，我的意见是一切以高效查找为目的，boost是全部是小写字母命名文件名和文件夹名称的
3.你这种其实就是个习惯而已，不存在什么救不救的问题，可能是你的编程中见到不同的风格太多了，并且你各个时间段内也觉得不同的方式比较好看，所以就形成了这种纠结的习惯，不过这种习惯挺影响效率的，前提是你的风格不停变化
4.注意大小写不算好习惯也不算坏习惯，只能说你比较注重细节和整体的美观，如果你在win和linux之间切换，建议你用小写字母总结下你的
这些问题的结论：
1.编程风格的统一主要是为了方便多人书写阅读代码，也就是说多人合作时才会牵扯到这个问题，如果你的代码是你一个人写一个人看，就不存在什么风格了，写成什么样子都可以的。所以如果你的团队习惯某一种风格，试着去适应这个风格
2.对于细节不要过度重视，不然你会写的很累，当你在和团队合作时，大家编程水平和风格良莠不齐的时候你就会很难受，这个时候你就需要接受别人的风格
3.更多的时候考虑效率，而不是特定的风格，当你效率很高，准确率很高，那么别人对你的风格就不是那么在意了
4.不要在意别人对你的看法，要分清楚别人是在给你带来正面的东西还是在打击你，对于刻意打击你的人，送给他们Fuc* them，大家更看重的是你的能力，而不是编程风格，所以基本可以无视
最后，如果你还在纠结关于编程风格的问题，建议你参考boost的代码规范，可以去boost网站上搜下，具体地址我忘记了。
</content>
    </entry>
    
     <entry>
        <title>谈谈当今的游戏行业(1)——是否端游已死，页游将死？</title>
        <url>https://cppfans.org/1471.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>手游</tag><tag>游戏</tag><tag>端游</tag><tag>页游</tag>
        </tags>
        <content type="html"> 本系列文章可能有好几篇，现在暂时不能确定具体数量。这种发表观点类型的文章本来应该应该用微信来发布的，不过微信我还在申请公众平台审核，而且那公众平台我才刚开始看了下，还没深入了解，所以就先写在博客上了。
&amp;nbsp;
本文中心：是否端游已死，页游将死？
&amp;nbsp;
过完年回来，听到最多的就是端游市场已经不行了，没有钱分，高资金投入，都是靠着钱支撑着，一旦停止推广砸钱，人数收入马上急剧下降，根本没法养活公司。
再加上年前的几款手游项目爆发，还有蓝港转型做手游王者之剑，直接成为爆款，月入2000W，蓝港宣布全面转入手游。等等的消息的确让各大厂商都看到了手游的市场以及用户的消费能力，因而诸多公司抱着尝试的态度，分出团队来做手游，甚至直接放弃端游页游，全面转向手游。
的确，端游是高投入，砸的钱决定你的营收，一旦停止砸钱，收入掉的很快，而页游基本都是走渠道商，流水虽然几千万，8:2分成的比例，算下来也没赚多少钱(前几天跟朋友吃饭，说某些平台已经到了9:1分成了)。而这个时候手游作为一个新的游戏平台和方向，分成比例还是5:5，研发厂商还是比较有赚头的。
结合去年的几个爆款项目，MT、王者之剑等，用户随随便便就几十万，流水几千万，风光无限，这也是开发人员的一个大光环，毕竟是过千万的成功项目。MT的成功在于有大批的魔兽世界的玩家以及我叫MT动漫的普及程度，还有卡牌战斗比较新颖；王者之剑在于类似于传统端游，操作和画面都更为舒服，动作类游戏，快速副本等。所以MT成功不在于游戏，而是在于用户对魔兽的爱，王者之剑更体现出来玩家对传统端游的喜爱。
端游是否已死，页游是否将死？我们来看看最近两个比较有代表性的PC上的爆款，《秦美人》和《笑傲江湖》的数据。
《秦美人》我自己没有玩过，不过看到gamelook上一些文章的介绍，再加上一些策划同事的提及，还是关注了下。《秦美人》是程度墨龙科技制作的一款页游，去年(2012年)8月15日完成封测，9月25日开始营收。首月，月营收破400万元，随后，月营收就开始呈现几何级数增长。次月1400万元，第三个月2800万元……到今年春节期间，达到最高月营收4000万元，而目前，最高月营收已突破5300万元。同时，游戏已跨出国门，登陆越南、韩国、马来西亚等市场；5月底，《秦美人》在越南市场也将开始运营收费。
再来看看《笑傲》，《笑傲》是完美花费4年时间研发的大型3D MMO武侠类网游，据说成本在8000W左右，公测第一天，开服30组，据北京的策划朋友反映说当天下午5点之前已经过了30W在线了，而晚上更是加开了6组服务器，第二天已经超过45组了，大约在线在40W以下。某产品朋友说大致算下来，《笑傲》一天的营收大约在300W-400W，一个月差不多1亿左右，研发成本就回来了。
且不说上面两款游戏的宣传力度，就这些数据和收入，也值得我们思考，端游页游真的将死了吗？看这些数据并不像，这些数据也打了那些“将死论专家”的脸。
在说说，巨人双子星计划，征途和仙侠世界，征途为巨人赚了无数钱呐，仙侠世界更是号称史玉柱收山大作，虽然现在动静不是很大，但是却说明并没有放弃端游，而是正常比例的投资。还有腾讯即将推出的天涯明月刀，枪神纪等等项目，也透露着端游并没有那么不堪。而页游现在依然是大量的项目在线上运营。
所以，上海这边大多数公司都是持中立态度，保证端游页游项目的运营或者研发中，尝试手游项目，毕竟，手游项目想成为爆款并没有那么容易，不确定因素太多了。
而我作为一个端游的程序，也认为端游和页游还是中流砥柱。我们项目虽然现在没几个人了，但是收入看起来还是挺不错的，养活公司还是靠端游页游，爆发需要手游。并且手游的爆发时间可能比较短，综合下来，手游还不是特别靠谱，只是可以作为另一块市场来做。
先说到这里吧，欢迎有不同意见的朋友留言来辩！
</content>
    </entry>
    
     <entry>
        <title>我也来说说扁平化设计</title>
        <url>https://cppfans.org/1488.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>iOS7</tag><tag>UI</tag><tag>Win8</tag><tag>扁平化</tag><tag>设计</tag>
        </tags>
        <content type="html"> 最近由于iOS7 beta版本的推出，导致了扁平化设计又被推上了一个热潮，所以我也凑个热闹，随便说一说。
到底什么是扁平化设计呢？
 扁平化完全属于二次元，这个概念最核心的地方就是放弃一切装饰效果，诸如阴影，透视，纹理，渐变等等能做出3D效果的元素一概不用。所有的元素的边界都干净利落，没有任何羽化，渐变，或者阴影。尤其在手机上，更少的按钮和选项使得界面干净整齐，使用起来格外简洁。可以更加简单直接的将信息和事物的工作方式展示出来，减少认知障碍的产生。
 像以前我们看到的苹果的一些设计，包括iOS6.x之前的，Mac OS等上面的特效，阴影，镜面效果等，都觉得非常炫，以前iOS的设计叫气泡设计，都带着一个高光的上方气泡，看着的确是很有质感，而且很多UI设计都在模仿它。不过天天吃肉也会腻的，自从iOS从2007年推出之后，iOS老的的风格用的太久了，从而使用户产生了一种厌恶感。
扁平化的优点在于它可以更加简单直接的将信息和事物的工作方式展示出来，减少认知障碍的产生。随着网站和应用程序在许多平台涵盖了越来越多不同的屏幕尺寸，创建多个屏幕尺寸和分辨率的skeuomorphic设计既繁琐又费时。设计正朝着更加扁平化的设计，你可以一次保证在所有的屏幕尺寸上它会很好看。扁平化设计更简约，条理清晰，最重要的一点是，更好的适应性。
微软当初设计Win8的时候，MetroUI(后改名为Win8 UI)刚进入大家视野的时候，不知道多少人批评MS的UI风格，“大色块的设计简直糟糕透了，让我感觉像个孩子在涂鸦，而我是专业人士”，而MS大胆的用户体验现在却得到了大部分用户以及设计师的认可。
再看看当年google还是多色纹理logo的时候，也是显得很突兀，不过现在也改成平面的了，看起来更像一家高科技互联网公司了。现在的chrome和google plus等也是用了扁平化设计。
firefox22版本的Logo也从原来的立体狐狸改为了更平面化，也就意味着火狐也在逐渐调整自己的UI，让用户慢慢接受。
苹果现在的iOS7也采用了扁平化的设计，图标更加平面，色彩更加简单，纹理、倒影也去掉了，当然了，这种设计肯定是参誉过半，用户都有一个适应过程，就像win8一样的。
从我个人角度来说，我是非常喜欢这种简约化的设计，因为UI越复杂证明操作难度或者对性能影响越大，但是据说iOS7的UI虽然看起来简单，但是却蕴含了很多实时计算的东西，这个等以后我了解过了再说吧。
而如今google在android的UI设计上也慢慢做出了要求，待以后慢慢看过再说。
扁平化设计在手机设计上现在见着的还不是很多，不过在网站UI上确实用到很多，确实美观大方了不少。
同样扁平化设计也是一个双刃剑，文字、图标、底图的位置、色彩等搭配不好，还是显得比较难看的，今天看到同事买了台lumia920，实话说，里面的UI风格不能细看，文字和图标什么位置都有，乱七八糟的。
&amp;nbsp;
引用一段设计原则来结束本文吧。
 无论采用怎样的风格，优秀的界面设计都需要遵从一些共通的设计原则： 一致性 通过具有一致性的设计模式及视觉风格，为用户建立起完整一致的心智模型，使产品更加易用，提升整体体验。 对比 &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 通过对配色、尺寸和布局的调整，使可点击的界面元素在视觉上与其他元素形成鲜明的对比。 &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;strong&amp;gt;布局&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 可以尝试使用960gs一类的网格布局为界面设定视觉规范，使用户的视线可以跟随内容本身所界定出的路径自然的移动，增强界面的视觉平衡。 &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;strong&amp;gt;层级化&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 最重要的东西要比相对次要的东西更容易被看到。关于这个话题我可以写一整篇文章出来，简单的说，就是在界面设计中着重突出那些与核心功能与常见用例相关的交互元素，而将其他操作元素置于次要位置，这可以使界面得到最有针对性的优化和简化。 &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;strong&amp;gt;目标用户&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 不同类型的用户所青睐的界面风格也有所不同。建筑、设计、时尚等领域的用户可以更好的拥抱扁平化风格，而其他更加“普通”的用户则更容易接受相对传统的拟物化界面。 &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;strong&amp;gt;反馈&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 当点击行为发生时，要立刻向用户提供清晰明确的视觉反馈。动画过渡效果就是一种比较常见的反馈方式，例如在用户执行操作后，使用旋转图标提示用户系统正在进行响应。 &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;strong&amp;gt;降低“摩擦力”&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 无论采用怎样的视觉风格，都要使界面尽量简化，减少用户完成目标所需执行的操作，打造更加流畅的交互体验。任何一点障碍或额外的步骤都会提高操作成本，增加功能的复杂度，进而降低转化率。 &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;strong&amp;gt;鼓励探索&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 了解目标用户有可能对产品进行哪些方面的探索。一旦他们习惯了产品的界面与基础功能，并开始向“高级用户”的阶段进发时，要为他们的探索和学习行为进行必要的指引与“奖励”回馈。 &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; &amp;lt;strong&amp;gt;原型&amp;lt;/strong&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;p align=&amp;#34;left&amp;#34;&amp;gt; 无论风格如何，界面形式都取决于实际的功能。好的设计方案离不开产品前期的规划工作，特别是通过草图或线框原型进行的探索。识别出最核心的用例需求，使用原型不断尝试和验证，为接下来的界面设计工作打下坚实的基础。 &amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt; </content>
    </entry>
    
     <entry>
        <title>[转载]10 个你必须掌握的超酷 VI 命令技巧</title>
        <url>https://cppfans.org/1485.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>vim</tag><tag>命令</tag><tag>技巧</tag>
        </tags>
        <content type="html"> via:http://wiki.itivy.com/?p=285
摘要：大部分Linux开发者对vi命相当熟悉，可是遗憾的是，大部分开发者都只能掌握一些最常用的Linux vi命令，下面介绍的10个vi命令虽然很多不为人知，但是在实际应用中又能让你大大提高效率。
在使用vi 编辑器时—无论是初次使用的用户，还是有经验的用户—大多数人往往只掌握核心命令集，这些命令可以执行最常用的功能：导航或保存文件；插入、更新、删除或搜索数据；退出但不保存修改。
但是，vi 编辑器极其强大，特性和功能非常丰富。即使在多年使用vi 之后，您仍然可能会发现有不知道的新命令。本文讨论的命令就属于不太为人所知的命令，但是它们可以简化您目前采用的操作方法，让您的工作方式更高效，或者 让您能够完成原来不知道可以用vi 完成的操作。
打开和关闭行号
vi 编辑器的许多选项可以控制编辑会话的外观和感觉。使用 :set 命令修改vi 中的会话设置。按 Escape 键进入命令模式之后，可以使用 :set all 命令显示选项和设置的列表。可以设置的选项之一是 number，它的作用是打开和关闭行号
 #
# Internet host table
 #  ::1 localhost
127.0.0.1 localhost loghost
192.168.0.6 centos5
192.168.0.10 appserv
192.168.0.11 webserv
192.168.0.12 test
192.168.0.5 solaris10 # Added by DHCP
~
~
 ~  :set number
 这个vi命令 在当前编辑的文件中的每个记录上显示行号。让vi 进入命令模式之后，可以输入 :set number 并按回车来打开行号
  #
# Internet host table
 #  ::1 localhost
127.0.0.1 localhost loghost
192.168.0.6 centos5
192.168.0.10 appserv
192.168.0.11 webserv
192.168.0.12 test
192.168.0.5 solaris10 # Added by DHCP
 可以使用 :set nonumber 命令关闭行号。还可以使用这个命令和 :set number 命令的简写，即 :set nu 和 :set nonu。如果需要快速计算要用vi 函数处理的行数，显示行号会非常有帮助。当行数很多，可能跨多个屏幕时，行号尤其有用。另外，有时候您知道要处理的行范围，但是需要查明要在vi 命令中使用的初始和结束行号。如果希望每次进入vi 会话时都显示行号，那么在主目录中的.exrc 文件中添加 set number 行。
自动缩进
在用某些编程语言编写代码时，缩进是样式的重要部分，可以确保代码的可读性更好。如果需要，可以在vi 编辑器中根据编程语言的样式设置自动缩进。使用 autoindent 打开或关闭自动缩进.
 #!/bin/ksh
#
#
for file in /etc/*
do
if [[ -f ${file} ]] ; then
echo “${file} is a file”
&amp;nbsp;
~
~
~
~
 ~  :set autoindent
 在此之后，如果在一行的开头输入空格或制表符，那么后续的新行将会缩进到相同的位置。在命令模式下，输入 :set autoindent，然后按回车打开自动缩进。通过设置 shiftwidth 确定缩进级别。例如，:set shiftwidth=4 把每级缩进设置为四个空格。
 #!/bin/ksh
#
#
for file in /etc/*
do
if [[ -f ${file} ]] ; then
echo “${file} is a file”
elif [[ -d ${file} ]] ; then
echo “${file} is a directory”
fi
done
~
 ~  :set shiftwidth=4
 在命令模式下，可以使用&amp;gt;&amp;gt; 命令让现有的一行增加一级缩进，使用&amp;lt;&amp;lt; 命令减少一级缩进。在这些命令前面加上一个整数，即可让多行增加或减少一级缩进。例如，把游标放在清单 4 中第 6 行的开头，进入命令模式之后，输入 5&amp;gt;&amp;gt; 就会让下面五行增加一级缩进。
 #!/bin/ksh
#
#
for file in /etc/*
do
if [[ -f ${file} ]] ; then
echo “${file} is a file”
elif [[ -d ${file} ]] ; then
echo “${file} is a directory”
fi
done
~
~
 可以使用 :set noautoindent 命令关闭自动缩进。还可以使用这个命令和 autoindent 命令的简写，即 :set ai 和 :set noai。还可以使用 :set ai sw=4 在一个命令中打开缩进并设置缩进级别。如果希望每次启动vi 会话时都启用自动缩进并把缩进级别设置为四个空格，那么在主目录中的.exrc 文件中添加 set ai sw=4 行。
在搜索时不区分大小写
如您所知，在 UNIX®中执行搜索时，模式匹配是区分大小写的。但是，如果希望vi 不区分大小写，那么可以使用 :set ignorecase 命令。使用 :set noignorecase 恢复区分大小写。还可以使用简写（:set ic 和 :set noic）。如果希望每次进入vi 会话时都启用不区分大小写的搜索，那么在主目录中的.exrc 文件中添加 set ignorecase 行。
复合搜索
在vi 中，可以使用/命令搜索字符串，这需要以字面字符串或正则表达式的形式指定要匹配的模式。例如，要想在文件中搜索单词 echo，只需进入命令模式，输入/echo，然后按回车。这个命令会找到清单 6 所示文件的第 3 行的第一个单词。
  #!/bin/ksh
#
echo “Starting”
file=${1}
echo ${file}
if [[ ${file} = 1 ]] ; then
((file=${file}&#43;1))
echo “Adding one gives ” ${file}
fi
echo “Ending”
exit
 可以使用简单的正则表达式指定寻找包含某一单词而且后面有另一个单词的行。例如，要想寻找包含字符串 echo、后面有零个或更多字符、之后是字符串 file 的第一行，应该使用/echo.*file。在清单 6 所示的文件中，这个命令会找到第 6 行的第一个单词。
但是，只有这两个字符串出现在同一行上，这个命令才认为是匹配的。如果希望搜索出现在另一个模式或字符串后面的某个模式或字符串，不管这两个模式或 字符串是否在同一行上，那么可以指定由分号(;)分隔的两个搜索命令，从而执行复合搜索。例如，要想搜索出现在字符串{file}&#43;1 后面的字符串 echo，应该使用/{file}&#43;1/;/echo/。在清单 6 所示的文件中，这个命令会找到第 10 行的第一个单词。复合搜索对于寻找代码中出现在另一个命令后面的某个命令尤其有用—例如，在设置某个变量之后调用函数的地方。
重放搜索模式
当在文件中搜索要替换的模式时，可以让vi 把要匹配的任何模式保存在缓冲区中；然后，在执行替换时，可以用缓冲区引用号重放它们。方法是把模式放在 (和 )之间，这会指示vi 把模式放在编号的缓冲区（1 到 9）中。在执行替换时，可以用缓冲区引用号 \1 到 \9 引用这些缓冲区。
例如，假设要在清单 7 所示的文件中搜索以单词 Martin 开头的行并对每个匹配添加前缀 Mr 和后缀 Wicks，那么进入命令模式，输入vi 命令 :%s/^(Martin)/Mr \1 Wicks/g，然后按回车。
 Martin is an IT consultant. Martin likes
snowboarding and mountain biking. Martin has
worked on UNIX systems for over 15 years. Martin also
worked for many years before that on mainframes.
Martin lives in London.
~
~
~
 ~  :%s/^(Martin)/Mr \1 Wicks/g
  下面把这个命令分解开解释一下：  :%s —指示vi 执行替换。
/—模式分隔符。
^(Martin)—寻找以字符串 Martin 开头的行并把这个字符串保存在缓冲区 1 中。
/—模式分隔符。
Mr \1 Wicks —把找到的字符串替换为字符串 Mr，加上缓冲区 1 中的内容，再加上字符串 Wicks。
/—模式分隔符。
g —全局修改（即修改所有匹配的地方）
在搜索和替换字符串中都可以使用缓冲区引用。
 Mr Martin Wicks is an IT consultant. Martin likes
snowboarding and mountain biking. Martin has
worked on UNIX systems for over 15 years. Martin also
worked for many years before that on mainframes.
Mr Martin Wicks lives in London.
~
~
~
 ~  :%s/^(Martin)/Mr \1 Wicks/g
 书签
可以让vi 在文件中的特定位置放上书签。方法是按 Escape 键，再按 M 键，然后输入另一个表示书签引用的字母表字符。因此，最多可以有 26 个书签，分别名为 a 到z。要返回到上一书签，按 Escape 键，再按反撇号（`），然后输入书签引用字符。
例如，按 Escape 之后按 M 和 A 键，就会把当前游标位置保存在书签 a 中。在编辑会话中，以后希望返回到这个游标位置时，只需按 Escape，然后输入 `A。可以使用双反撇号（“）命令在当前书签和前一个书签之间切换。
查找、更新、查找下一个、重复
在vi 编辑器中，最有用的搜索/替换特性之一是查找与某个模式匹配的字符串，更新它，然后继续搜索下一个匹配的字符串，然后选择是否以相同方式更新它。这与 Microsoft® Word 中的查找下一个/替换功能很相似。您可能已经知道可以在vi 中搜索字符串模式，方法是进入命令模式，输入/search_pattern（其中的 search_pattern 是字符串或正则表达式），然后按回车。这样做就会找到与指定的模式匹配的第一个字符串。在此之后，可以在找到的文本上执行任何操作。例如，按 Escape，再按 C 和 W 键，再输入更多文本，就会把找到的字符串替换为另一个单词。
要想快速地找到与模式匹配的下一个地方，应该按 Escape，然后按 N 键。在找到下一个匹配时，可以使用点号键（.）在这个位置重复最近的文本操作，比如前一个示例中使用的修改单词（cw）操作。然后，可以使用这些键继续寻 找其他匹配（n）并选择重复文本操作（.），操作方式与使用 Word 中的查找下一个/替换功能很相似。
切换大小写
在vi 中，可以切换游标下的字母字符的大小写，方法是按 Escape，然后按波浪号键（~）。这会在小写和大写之间来回切换。按着这个键，移动游标经过行中的每个字符，就会切换遇到的每个字母字符的大小写。可 以在波浪号前面输入一个数字，表示希望改变多少个字母字符的大小写。
筛选
您可能知道，在vi 中按 Escape，输入 :!command（其中的 command 是要执行的 UNIX 命令），然后按回车，就可以在 shell 中执行命令。例如，:!pwd 显示编辑会话当前的工作目录。
但是，还可以把文件的一部分作为标准输入发送给 UNIX 命令，并用产生的输出替换编辑缓冲区中的相同部分。例如，如果希望在vi 会话内对清单 9 所示的整个文件进行排序，可以按 Escape，输入 :1,$!sort 并按回车，这让vi 把从第一行到文件末尾（$）的所有内容传递给 sort 命令，用输出替换指定的部分。
另外，还可以在 shell 命令前面加上从当前游标位置开始希望操作的行数。方法是按 Escape，然后输入指定行数的数字，然后输入两个惊叹号（!!），最后输入 UNIX 命令。
可以使用管道分隔符（|）把 UNIX 命令连接在一起，从而在vi 会话中执行复杂强大的筛选。例如，假设要把当前vi 会话的编辑缓冲区中的文件内容替换为每行的第一个空格分隔的字段，按升序排序并转换为大写，那么在按 Escape 之后输入：
 :1,$!awk ‘{print $1}’ | sort | tr [:lower:] [:upper:]
 保存部分内容
可以保存当前编辑的文件的部分内容，方法是按 Escape，然后输入 :start,endw file，其中的 start 是当前文件中要保存的第一行，end 是要保存的最后一行，w表示希望写到另一个文件中（或者覆盖现有的文件），file 是指定的部分要保存到的文件。对于最后一行，可以使用$表示文件的末尾。可以在w后面使用两个大于号（&amp;gt;&amp;gt;）表示希望把内容附加到文件中而不 是覆盖文件。清单 12 中的示例把第 6 到第 9 行（含）附加到文件/tmp/newfile 中。
  #
# Internet host table
 #  ::1 localhost
127.0.0.1 localhost loghost
192.168.0.6 centos5
192.168.0.10 appserv
192.168.0.11 webserv
192.168.0.12 test
192.168.0.5 solaris10 # Added by DHCP
~
~
 ~  :6,9w &amp;gt;&amp;gt; /tmp/newfile
 结束语
vi 编辑器是一个极其强大的工具，本文提供了一些技巧和诀窍，希望能够帮助您更高效地编辑文件。请记住，vi 还有更多不太为人所知的特性。祝工作愉快！
&amp;nbsp;
btw:最近在公司玩libuv和linux，暂时用的是远程终端，所以用vim就多了些，发现还是很好用的，也没有以前那么排斥了，大家有功夫可以试试。
</content>
    </entry>
    
     <entry>
        <title>谈谈程序员行业的“文人相轻”以及沟通问题</title>
        <url>https://cppfans.org/1472.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>团队</tag><tag>文人相轻</tag><tag>沟通</tag><tag>程序员</tag>
        </tags>
        <content type="html"> 很早以前就想写这篇文章了，不过却因自己经验甚浅，不敢妄言，虽然现在写也可能引起一些争论，还是请大家平和的去看这篇文章。
自古以来便有文人相轻，这句话来自三国·魏·曹丕《典论·论文》,原文与译文如下：
 原 文  文人相轻，自古而然。傅毅之于班固，伯仲之间耳，而固小之，与弟超书曰：“武仲以能属文，为兰台令史，下笔不能自休。”夫人善于自见，而文非一体，鲜能备善，是以各以所长，相轻所短。里话曰：“家有弊帚，享之千金。”斯不自见之患也。  译文  文人互相轻视，自古以来就是如此。傅毅和班固两人文才相当，不分高下，然而班固轻视傅毅，他在写给弟弟班超的信中说：“傅武仲（傅毅）因为能写文章当了兰台令史的官职，（但是却）下笔千言，不知所指。” 但凡人总是善于看到自己的优点，然而文章不是只有一种体裁，很少有人各种体裁都擅长的，因此各人总是以自己所擅长的轻视别人所不擅长的，乡里俗话说：&#34;家中有一把破扫帚，也会看它价值千金。&#34;这是看不清自己的毛病啊。   而如今这句话如今不单单指的是写文章的人了，今天想说说程序员行业中的“文人相轻”。
周鸿祎曾经说过“最不好的作法是，每换一拨人换一套技术，文人相轻，总认为自己的技术最好，这也是为何有些搜索公司做不大”，且不谈论他说的后半句，前半句中提到的“文人相轻，总认为自己的技术是最好的”很值得思考。
程序员修改别人代码_(除过比较NB的开源代码)_最常见的做法就是先将别人的代码风格改为自己的，然后才开始研究，其实别人代码的风格可能是另一种常见的风格，只因与自己风格不一致，于是乎改之。可能您并不是这样，至少我有这样的毛病，算是强迫症吧。
另一种常见的是刚进入项目的程序员会抱怨底层的一些东西难用，为什么不用xxx库，xxx技术等等。其实很明显可以看出该猿对这个项目和这套底层不熟悉，生硬的使用，导致其心中有怨气。所以大多数人刚进某一个项目都不会直接写底层的。
文人为何会相轻？难道跟自古以来说的文人酸腐有关系？我认为归根结底是国人的心态在作祟。国人不论是做什么的，都有“好为人师”的心理。
郭德纲在《以德服人》中说过“中国人都有好为人师的心理，比如你开了一家餐馆，叫五环餐馆，但门口的标志上画六个环，有好事人来了就会说你们怎么回事啊，叫五环餐馆，怎么画了六个环呐，跑堂的会说先生您真有眼力，当初是工人弄错了，您坐着喝点水吧。结果这主儿喝水无聊翻菜单，点了一千块钱的菜吃了”。(可能与原话有出入，意思大致如此)
可以得见的是病态的心理导致了文人相轻，程序员也不见外，虽然大多数表面上与世无争，努力写自己的NB代码，但是心中总是对一些人代码和技术不服气，进而产生了一些矛盾，这当然不是公司高层喜闻乐见的事情了，于是刺头们都被分开做项目了，这也是国内的团队管理和团队建设。
说完文人相轻，再来说说其并发症——沟通的问题。
团队合作必然会有沟通，因为合作必然会带来交流，否则这不叫团队了。而在沟通的过程中，会产生各样的问题，比如提问不当啊，问题不清楚啊，答非所问等问题。不过最常见的问题是提问不当，我有一个程序交流的QQ群，里面经常会有人提出开发上的问题，不过大多都不知道在问什么，提问不清楚是如今沟通上的一大问题。
举个例子吧，在oschina上有人问了这样一个问题：“nginx有网站在用吗？”(关于nginx可以去oschina上查，不想引用百度百度百科了。)，结果引来了一大堆人的跟帖和指责，好一点的是告诉他哪些哪些网站在用，不好的就是侮辱了，骂小白的，骂没见识的都有，有一位朋友的说法挺有意思，引用在下面。
 哈哈..这句话很容易引发矛盾.如果是小白求问&amp;hellip;别人会认为你孤陋寡闻如果是表示不屑&amp;hellip;别人会认为你土鳖正确的 问法应该是： 现在有哪些网站在用这个web服务&amp;mdash;-摘自 《如果避免引发网络掐架以及避免网络喷子之淘气3000问》
 所以，好的提问方式是沟通的前提，问清楚了，别人才能回答清楚。
当然了，还有些是因为有个人情绪在其中，我公司另外一个项目组，是服务器-客户端-策划，三足鼎立，三方谁见谁都要吵吵两句，无它，只是看着不爽，于是乎，这个项目快做完的时候，他们相继离开，可能也是因为项目存在问题的压力吧。现在项目转到我们这边，可害苦了我们啊。
我也不是管理层，对团队建设没任何经验，我认为沟通的目的是为了解决问题，把问题解决了，剩下什么都好说。
对于这两个问题，我只能浅尝辄止的说一说，也没经验，也说不了多少，说多了怕被喷，所以就到这里吧。
</content>
    </entry>
    
     <entry>
        <title>恢复网站色彩并试用Windows live</title>
        <url>https://cppfans.org/1478.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>windows live</tag>
        </tags>
        <content type="html"> 博客已经改为黑白色一周了，地震救援工作也已经进行了一周了，各地也积极的开始了捐款、捐物资等活动，觉得可以去掉这个黑白滤镜了，心意到了就好了。
同时，决定试试Windows Live离线写文章的功能，早就听说过windows live写文章很犀利，一直没机会试用，借这篇文章试试效果吧。
Windows Live采用wp中的XML-RPC协议发布文章，并且WL的编辑功能毕竟是office出身，绝对没话说的。
好了现在大家看看效果吧。应该还可以的。
</content>
    </entry>
    
     <entry>
        <title>祈福雅安，为同胞默哀!</title>
        <url>https://cppfans.org/1475.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>地震</tag><tag>祈福</tag><tag>网站黑白</tag><tag>雅安</tag>
        </tags>
        <content type="html"> 关于4.20四川雅安7.0级地震的消息想必大家都知道了，就不多说了，新闻是铺天盖地的，其中有一些感动的新闻，也有一些对救灾中的负面新闻，也希望大家的关注点在救灾上面。
很多网站都推出了寻人服务和捐款页面，大家如果能力所及，希望可以关注一下。
只能在心里默哀了，祝福雅安早日重建。
特意将网站改为黑白色，希望大家可以理解。
支持三种主流浏览器，代码如下：
&amp;lt;!-- 祈福雅安 --&amp;gt; &amp;lt;style&amp;gt; html{ filter: grayscale( 100%); -webkit-filter: grayscale( 100%); -moz-filter: grayscale( 100%); -ms-filter: grayscale( 100%); -o-filter: grayscale( 100%); filter: url( &#34;data:image/svg&#43;xml;utf8,&amp;lt;svg xmlns=\&#39;http://www.w3.org/2000/svg\&#39;&amp;gt;&amp;lt;filter id=\&#39;grayscale\&#39;&amp;gt;&amp;lt;feColorMatrix type=\&#39;matrix\&#39; values=\&#39;0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\&#39;/&amp;gt;&amp;lt;/filter&amp;gt;&amp;lt;/svg&amp;gt;#grayscale&#34;); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale( 1); } &amp;lt;/style&amp;gt; 将其添加在之前就可以了。
如果您也是一位站长，希望可以用此方式带动更多的人为雅安祈福。
此黑白效果将持续一周，希望大家见谅。
</content>
    </entry>
    
     <entry>
        <title>网站设计之CSS精灵图</title>
        <url>https://cppfans.org/1468.html</url>
        <categories>
          <category>Wordpress</category><category>技术文章</category>
        </categories>
        <tags>
          <tag>CSS</tag><tag>iSpriter</tag><tag>Sprite</tag><tag>web</tag><tag>精灵图</tag>
        </tags>
        <content type="html"> 写完这个标题后，我就后悔了，因为这个标题会让别人误以为我很懂网站设计似的，其实对于web开发我是个外行。没改标题的原因是可以让大家有“虽不懂但觉厉”的感觉。
我研究web技术仅限于折腾我这个博客，当随便翻到某个网站的时候，看到有好的地方，就抄袭过来，我这往大了说应该属于网络犯罪。
今天无事看到某人博客上的新浪微博关注的一块边栏，想着把这个做到自己的博客，以前也做过，是通过新浪开放平台获取的代码。但是放在右边栏又显得很拥挤，以前看到过别人放在博客名称旁边。于是开始做这个小功能。
现在大家看到我博客标题旁边有一个括起来的提示，看着挺明显的，边框是一张图片。获得这个图片是从网上找的图片，不过却是一个sprite图，也就是精灵图。
使用sprite图主要是为了防止多次请求图片导致网站加载慢，所以将很多图片拼起来放在一张图片上，然后显示的时候通过坐标来显示不同的图片。这样的方式可以很明显减少http get请求。
在很多大网站扒图的时候会发现并不是一张张单独的图片，而是sprite图，这也说明了该项技术被广泛应用。mozilla firefox官方推荐在网站设计开始时，就采用该项技术，否则后期如果更改意味着你将要重写大部分CSS。
精灵图最麻烦的就是确定图片的位置了，一般都是直接用PS来看图片位置，不过我是不怎么熟悉了，还是喜欢直接用工具。下面推荐一些工具。
1.CSS Sprite格式化工具 bg2css_v3.2.1.air，这个需要安装adobe air (因需要安装air，所以没有测试)
2.CssSpriteDIV.exe 某位程序员自己使用C#写的，可以选择图片放入背景后，自动生成sprite图和html代码，缺点是背景大小有限，子图片宽度不能超过300px，可能是因为预览区太小所以没敢放的太大
3.一些网站提供的在线工具
4.TX Web前端Alloy团队基于Node.js开发的iSpriter —— 智能合并CSS精灵图，可能是因为没用过NodeJS，部署看起来挺麻烦的。地址：http://www.alloyteam.com/2012/09/update-ispriter-smart-merging-css-sprite/
其他的就暂时没看到了，大家如果有什么好工具可以交流下。同时，PS如何确定精灵图的位置，还望懂得朋友告诉一声，先谢过了。
btw.本博客标题右侧的提示并没有用到精灵图，因为我只需要那张方框图，其他图不需要，用原来那张精灵图倒使得图片太大了。
</content>
    </entry>
    
     <entry>
        <title>[转载]我眼中的技术高手 - lifesinger</title>
        <url>https://cppfans.org/1467.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>技术</tag><tag>编程</tag><tag>评论</tag><tag>语言</tag>
        </tags>
        <content type="html"> 今天发了一条微博：  会原生 JavaScript 不代表什么，懂 jQuery、YUI 等才真正好。怎么这么多人有原生主义情结呢？走出那点小天地，海阔天高。
 很多人已经猜出，这是为了晚上的文章而发，提前收集大家的想法。这个话题，很早就想谈，肯定会引起口水仗，但有些事不辩不明，不理不清，与其和谐社会，不如辛亥革命。 奇怪的现象  平时工作，时不时能听到一些困惑、感慨：  jQuery 虽好，但只会 jQuery，不会原生 JS 是不被大公司认可的。
最近半年对原生 JS 有些生疏，得补一补。
得好好看看 ECMAScript 规范，把 JS 语言学透彻。
 和原生情结对应的，是国内程序员特别喜欢研读源码，比如：  jQuery 源码分析系列
YUI 源码分析
Backbone 及 Underscore 源码解析
 国内程序员对源码的热衷，可以拿 SeaJS 的数据来看：  fork 数高达 500 多，但 watch 数只有 1000 多，这其实是不正常的。相比而言，RequireJS 的数据正常很多：  简言之，国内与国外相比，有比较明显的两个特点：  对原生 JS 的学习心更强。   对类库、框架的源码更感兴趣。   这两点看起来很好，可是：  研究原生 JS 的优秀文章，大都出自国外程序员。   类库、框架，国人好像一直在研究，鲜有产出。   这肯定跟我们是社会主义国家有关，但我越来越怀疑这一点。 语言高手们  真正的语言高手不多，我不是，正在看这篇文章的你，很可能也不是，而且这一辈子可能都和我一样成为不了语言高手。 JavaScript（纯语言，不含 DOM 等）高手，在国内屈指可数。周爱民、白露飞、老赵、winter、月影、hax 等等等等，还有一些非常低调的隐士，这些人读 ECMAScript 规范像磕瓜子一样轻松，甚至能花几个晚上就像 BE 大神一样造出一门新语言来。你我等闲之辈，除了佩服之外，只能去谈恋爱。 工作中，我们需要语言高手吗？肯定的说，需要！可是，我们需要大量语言高手吗？除了特殊岗位，我相信很多公司都不需要！ 题外话：目前为人知的 JS 语言高手里，除了周爱民，我最看好白露飞。这是一个有能力也有潜力造就 SuperScript 的人，最佩服的是他有实际行动，虽然方向未必正确。 我们的价值在哪  除了重新投胎，我们大部分人这辈子都不大可能有兴趣、有能力、有机缘去成为 BE 大神了。这是个残酷的现实，之所以残酷，只因视野太狭窄。 跳出来，天大地大。妹子多着呢，而且更漂亮。 Douglas Crockford 的 JS 能力很可能不及 winter，但 Douglas 规范并布道了 JSON 格式，天下留名，惠泽全球。 Jeremy Ashkenas 的 JS 能力可能还不如老赵，但 Jeremy 用很裸的代码写就了 Backbone，至少影响了一万人，给各个公司创造的价值总额很可能过千万美刀。 更不用说 Isaac Z. Schlueter，这小伙的 JS 功力很可能还不如我，但 Isaac 打造了 npm 生态圈，而我至今只有精力玩玩 Ant 和 Grunt。 有幸还看过 Google Docs 的前端源码，那代码和 Java 一样中规中矩。但在 RTE 领域，Google Docs 是王者，里面的专利都一堆一堆的…… 特别想提及的还有开发 Evernote Clearly 的前端工程师，这小伙子的代码，我眼睁睁看着其从很生涩的 JS 代码，逐步演化成上万行牛逼代码还保持了相当好的可维护性。这份代码就像 Clearly 产品一样奕奕生光。 以及把 jQuery 用得出神入化的 Amazon！前不久那个秒杀国内互联网公司的悬浮菜单，可不是研究原生 JS 能想出来的。 还有 Facebook 的工程师们，Twitter 的工程师们…… 这些故事大家并不陌生。 不是总结的总结  不贬低语言高手们，也不反对去研究编译原理、ECMAScript 规范等。作为技术人员，我们需要这种精神。但是，这仅仅是很小很小很小很小很小的一个领域。并且在这个领域里，永远有比你更聪明的人。 具体对 JavaScript 语言来说，会用就好。搞清楚数据类型、作用域、闭包、原型链等基本概念，足矣。再深入进去，对绝大部分人来说，除了能满足下心理上的优越感，对实际工作不会有任何实质性帮助。 语言的本质和互联网一样，只是工具，是剪刀、石头、布。让张小泉去研究怎么做剪刀就好，我们用好剪头，去剪出各种窗花，更有意思。还有一个有趣的事实是，张小泉会造剪头，但剪不好窗花。 跳出很小很小很小很小很小的语言领域之外，天大地大。永远不要妄自菲薄，每个人身上都背负着独特的使命。去努力寻找自己的，不要老盯着别人的，否则就会成为观众。 好像跑题了。前面那个奇怪的现象，还有很多想吐槽的点。比如 源码只是很小很小的一部分。直接读源码往往无法领会类库框架的精髓。不读源码，用心去用，用时间去体味，偶尔针对性看看源码，往往更能掌握一个类库框架的真谛。  对社区的贡献可以有很多很多。你的使用经验、用心的 bug 提交、入乡随俗的 pull request、一个认真的评论等等，这些都比去研究什么狗屁源码更有价值。  一个 Java 高手如果说他会原生 Java，那一定会遭来很多人的围观。我还会谭浩强教我的 C 呢，那几个 if else 还有结构体、指针等谁不会。语言之外的领域知识，才真正造就了高手。对于前端来说，会原生 JS 只能打 20 分，另外 40 分需要你深入使用 CSS、DOM、HTML5 等领域知识，还有 20 分需要你对业务需求、架构设计等有真正的运用，这已经 80 分了，不要太贪心。剩下 20 分，只有两个字：勤奋。 via.github   </content>
    </entry>
    
     <entry>
        <title>使用jsoncpp解析JSON数据</title>
        <url>https://cppfans.org/1445.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>JSON</tag><tag>jsoncpp</tag><tag>解析JSON</tag>
        </tags>
        <content type="html">  上节《JSON数据格式》中我们讲到了JSON的数据格式和一些应用的地方,接着上面的说下去，jsoncpp和boost.property_tree都可以解析JSON文件，我们先将jsoncpp如何解析。
1.jsoncpp是什么？ jsoncpp是一个使用C&#43;&#43;语言来解析json文件的开源库，其项目地址为：http://sourceforge.net/projects/jsoncpp/，属于免费项目，任何人都可以下载使用
2. 编译jsoncpp jsoncpp文件中提供了vs71的工程文件以及makerelease.py文件，用来编译，里面分为jsontest、lib_json、test_lib_json三个工程，按照自己需要的编译。
_注意:如果使用VS默认的编译选项MTd或者MT，在使用jsonlibmtd.lib的时候可能会出现LNK2038错误(我使用的VS2012 vc110环境)，所以请修改MTD为MDd，MT为MD。
3.使用jsoncpp读JSON文件 如何将lib库添加进VS工程中在此就不赘述了。先看第一个读文件的例
// JSON文件 {&#34;address&#34;:[ {&#34;name&#34;:&#34;eliteYang&#34;, &#34;email&#34;:&#34;elite_yang@163.com&#34;}, {&#34;name&#34;:&#34;AAA&#34;, &#34;email&#34;:&#34;aaa@163.com&#34;}, {&#34;name&#34;:&#34;BBB&#34;, &#34;email&#34;:&#34;bbb@163.com&#34;} ]} /** * file : jsoncpp_test.cpp * author : eliteYang * email : elite_yang@163.com * blog : http://www.cppfasn.org * desc : json cpp test */ #include &amp;lt;fstream&amp;gt; #include &amp;lt;string&amp;gt; #include &#34;jsoncpp/json.h&#34; int _tmain(int argc, _TCHAR* argv[]) { std::ifstream ifs; ifs.open(&#34;test.json&#34;); Json::Reader reader; Json::Value root; if (!reader.parse(ifs, root, false)) { return -1; } Json::Value add_value = root[&#34;address&#34;]; for (int i = 0; i &amp;lt; add_value.size(); &#43;&#43;i) { Json::Value temp_value = add_value[i]; std::string strName = temp_value[&#34;name&#34;].asString(); std::string strMail = temp_value[&#34;email&#34;].asString(); std::cout &amp;lt;&amp;lt; &#34;name: &#34; &amp;lt;&amp;lt; strName &amp;lt;&amp;lt; &#34; email: &#34; &amp;lt;&amp;lt; strMail &amp;lt;&amp;lt; std::endl; // use value array[index] //Json::Value temp_value = add_value[i]; //std::string strName = add_value[i][&#34;name&#34;].asString(); //std::string strMail = add_value[i][&#34;email&#34;].asString(); //std::cout &amp;lt;&amp;lt; &#34;name: &#34; &amp;lt;&amp;lt; strName &amp;lt;&amp;lt; &#34; email: &#34; &amp;lt;&amp;lt; strMail &amp;lt;&amp;lt; std::endl; } system(&#34;Pause&#34;); return 0; } 结果：
name: eliteYang email: elite_yang@163.com name: AAA email: aaa@163.com name: BBB email: bbb@163.com 请按任意键继续. . . 跟我们文件中的数据完全一致。
4.使用JSON写入一块数据
我们继续使用上述文件，在中间加上一块数据。我们插入一个新的{&amp;ldquo;name&amp;rdquo;: &amp;ldquo;append&amp;rdquo;, &amp;ldquo;email&amp;rdquo;: &amp;ldquo;append@163.com&amp;rdquo;}
/** * file : jsoncpp_test.cpp * author : eliteYang * email : elite_yang@163.com * blog : http://www.cppfasn.org * desc : json cpp test */ #include &amp;lt;fstream&amp;gt; #include &amp;lt;string&amp;gt; #include &#34;jsoncpp/json.h&#34; int _tmain(int argc, _TCHAR* argv[]) { std::ifstream ifs; ifs.open(&#34;test.json&#34;); Json::Reader reader; Json::Value root; if (!reader.parse(ifs, root, false)) { return -1; } Json::Value&amp; add_value = root[&#34;address&#34;]; Json::Value append_value; append_value[&#34;name&#34;] = &#34;append&#34;; append_value[&#34;email&#34;] = &#34;append@163.com&#34;; add_value.append(append_value); for (int i = 0; i &amp;lt; add_value.size(); &#43;&#43;i) { Json::Value temp_value = add_value[i]; std::string strName = temp_value[&#34;name&#34;].asString(); std::string strMail = temp_value[&#34;email&#34;].asString(); std::cout &amp;lt;&amp;lt; &#34;name: &#34; &amp;lt;&amp;lt; strName &amp;lt;&amp;lt; &#34; email: &#34; &amp;lt;&amp;lt; strMail &amp;lt;&amp;lt; std::endl; } Json::FastWriter writer; std::string json_append_file = writer.write(root); std::ofstream ofs; ofs.open(&#34;test_append.json&#34;); ofs &amp;lt;&amp;lt; json_append_file; system(&#34;Pause&#34;); return 0; } 结果：
name: eliteYang email: elite_yang@163.com name: AAA email: aaa@163.com name: BBB email: bbb@163.com name: append email: append@163.com 请按任意键继续. . . // test_append.json {&#34;address&#34;:[{&#34;email&#34;:&#34;elite_yang@163.com&#34;,&#34;name&#34;:&#34;eliteYang&#34;},{&#34;email&#34;:&#34;aaa@163.com&#34;,&#34;name&#34;:&#34;AAA&#34;},{&#34;email&#34;:&#34;bbb@163.com&#34;,&#34;name&#34;:&#34;BBB&#34;},{&#34;email&#34;:&#34;append@163.com&#34;,&#34;name&#34;:&#34;append&#34;}]} 当然了，jsoncpp对数组的解析也支持STL中迭代器的风格，不过我个人觉得还是数组好理解一些。迭代器的解析风格就不写了，大家可以自己摸索下，主要是使用Json::Value::Members。
JSON官方还是非常推荐用jsoncpp来解析JSON文件的，大家也看到了，确实比较方便。
btw.因为这两天笔记本散热不好，所以接了套螺丝刀将笔记本大卸八块，扫了扫灰，然后又装上了，结果神奇的就好了，果然是贱啊，欠拆。所以json系列的文章就晚了几天，非常抱歉，好了，不早了，该睡觉了，各位晚安。
</content>
    </entry>
    
     <entry>
        <title>JSON数据格式</title>
        <url>https://cppfans.org/1442.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>boost</tag><tag>JSON</tag><tag>property_tree</tag><tag>xml</tag><tag>文件格式</tag>
        </tags>
        <content type="html">  看到boost::property_tree类库的时候，发现它可以解析XML、JSON、INI，INFO格式的文件，XML和INI已经使用过，并且用别的库读取过了，而JSON这个看着面熟的格式，完全没有用过，只是知道在web应用里经常用到。所以今天我们就来看看JSON到底是个什么东西，它的数据格式和用途。
1.什么是JSON JSON是一种轻量级的数据交换格式，全称是：JavaScript Object Notation，它有完全独立的数据格式，所以它是独立于任何编程语言的，它不太易于阅读，但是易于机器解析和生成。
2.JSON数据格式 JSON有两种格式
  名称/值 成对的集合，类似于关联数组或者map结构。  实例： {&#34;name&#34;: &#34;eliteYang&#34;}  这个结构显然没有name=eliteYang来的直接和明显，而且浪费了很多引号，但是如果多个结构就会体现出这种结构的优势了，例如： {&#34;name&#34;: &#34;eliteYang&#34;, &#34;name&#34;: &#34;AAA&#34;, &#34;name&#34;=&#34;BBB&#34;}  前面我说过，这种结构不太容易阅读，这里它明显看起来很纠结，所以有些人说这个容易阅读让我很费解，大概是写代码写多了，接近机器了吧。    值的有序列表，大部分语言中，这种结构被称之为数组。  实例： {&#34;address&#34;:[ {&#34;name&#34;:&#34;eliteYang&#34;, &#34;email&#34;:&#34;elite_yang@163.com&#34;}, {&#34;name&#34;:&#34;AAA&#34;, &#34;email&#34;:&#34;aaa@163.com&#34;}, {&#34;name&#34;:&#34;BBB&#34;, &#34;email&#34;:&#34;bbb@163.com&#34;} ]}   3.JSON的用途 JSON主要用于数据传输和转化，常用在web服务中，例如本站用的多说评论插件，它就是使用JSON将评论数据同步到多说的服务器上的，同时，显示评论也是从多说的服务器上通过JSON请求过来的。JS非常容易操作JSON，因为JSON的数据格式是JS原生的数据格式。当然了，其他方面也可以使用，比如网络传输，将JSON转化成字符串，压缩加密后用于消息事件，或者存储数据库时，将一些数据整个存成JSON格式，然后做成一个字符串存入数据库，还有许多用途，这里就不一一介绍了。
PS:
JSON与XML格式的比较：
优点：JSON占用较少字符，主要用在JS上，对存储JS复合对象来说很方便
缺点：JSON不易于阅读，可扩展性不强，而XML天生就有很强的扩展性，并且完全符合人类的阅读习惯。
而从编写角度来说，都差不多，因为现在都有专门的工具来编写两种格式的文件，解码难度也是近似的，都需要知道节点名，然后读取出数据。
C&#43;&#43;操作JSON文件主要使用的库有boost.property_tree和JSONcpp等类库。
C&#43;&#43;操作XML文件主要使用的库有rapidxml、tinyxml、boost.property_tree等类库。
下两篇我们会分别用C&#43;&#43;操作JSON文件，来演示和说明boost.property_tree和JSONcpp的用法。
</content>
    </entry>
    
     <entry>
        <title>wordpress百度分享工具条最新版本1.0发布</title>
        <url>https://cppfans.org/1449.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>wordpress</tag><tag>工具条</tag><tag>新版本</tag><tag>百度分享</tag>
        </tags>
        <content type="html"> 好长一段时间都没理会百度分享工具条了，最近看到倡萌将这个工具条进行了一些优化和精简(《WordPress添加仿异次元百度分享工具条》)，决定采用倡萌的版本，再加上一些自己的改动再次发一个版本，以后基本就不会再动了，感谢这么多人的使用和支持。
具体效果请查看本博客任何一篇文章顶部的工具条。
使用方法：
1.下载baidu_share_toolbar_Ver_1_0.zip文件，更多下载地址见文末。
2.解压到当前文件夹，会解压出一个share文件夹，里面包含share.css share.php share.png share_roll.js 使用教程.txt共5个文件。
3.将share文件夹整个上传到您的wordpress当前使用的主题下。
4.在主题的 header.php 的 前面 或者 footer.php 的  前面，添加下面的引用CSS和JS的代码：
&amp;lt;?php if ( is_single() ) { ?&amp;gt; &amp;lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;&amp;lt;?php bloginfo(&#39;template_url&#39;); ?&amp;gt;/share/share.css&#34; /&amp;gt; &amp;lt;script type=&#34;text/javascript&#34; src=&#34;&amp;lt;?php bloginfo(&#39;template_url&#39;); ?&amp;gt;/share/share_roll.js&#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;?php } ?&amp;gt; 5.在single.php文件中您认为合适的地方添加如下代码即可开启工具条：
&amp;lt;?php include(TEMPLATEPATH . &#39;/share/share.php&#39;); ?&amp;gt; btw.
A.如果浏览次数显示错误，请查看是否安装了wp-postviews插件；
B.如果您的文章宽度不是690px，请修改share.css中#share_toolbar 中width:690px;为您需要的宽度，因为我发现设置width: auto;后，滚动页面宽度会发生变化，所以改为固定数值。
如有任何使用上的问题，欢迎留言交流。
&amp;nbsp;
下载地址：
yunfile网盘百度网盘  为了保证文件的安全合法性，请下载后与本文给出的MD5和SHA1进行比较，如果不相同，请留言确认文件。
文件信息如下：
 文件名称：baidu_share_toolbar_Ver_1_0.zip
文件大小：12016 字节
修改时间：2013年1月27日 22:58:21
MD5 ：2DF12207B0BCEA19E563DF2E5DBD11AD
SHA1 ：1BA5B8CEA27F6638DB1A9206AB4FF5C1F618C0A6
CRC32 ：90687C4C
 </content>
    </entry>
    
     <entry>
        <title>初识英特尔线程构建模块之内存管理tbb_malloc</title>
        <url>https://cppfans.org/1437.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>Intel</tag><tag>Malloc</tag><tag>TBB</tag><tag>Threading Building Blocks</tag><tag>多核</tag><tag>并发</tag>
        </tags>
        <content type="html">  什么是TBB？ TBB(Thread Building Blocks)是英特尔发布的一个库，全称为 Threading Building Blocks，里面包含了 Algorithms、Containers、Memory Allocation、Synchronization、Timing、Task Scheduling这六个模块。暂时我只用到了Memory Allocation模块，其他的没有用到。
  摘自百度百科：   TBB,Thread Building Blocks,线程构建模块，是Intel公司开发的并行编程开发的工具。   OSCON 上，Intel 宣布，Threading Building Blocks，Intel 众多软件开发工具中的一个，open source 了。协议是 GPLv2。   TBB 获得过 17 届 Jolt Productivity Awards，是一套 C&#43;&#43; 模板库，和直接利用 OS API 写程序的 raw thread 比，在并行编程方面提供了适当的抽象，当然还包括更多其他内容，比如 task 概念，常用算法的成熟实现，自动负载均衡特 性还有不绑定 CPU 数量的灵活的可扩展性等等。STL 之父，Alexander Stepanov 对此评价不错，他说“Threading Building Blocks… could become a basis for the concurrency dimension of the C&#43;&#43; standard library”。其他 TBB 的早期用户，包括 Autodesk，Sun，Red Hat, Turbo Linux 等亦然。现在 O’Reilly 已经出版了一本 Intel Threading Building Blocks: Outfitting C&#43;&#43; for Multi-core Processor Parallelism。   使用tbb_malloc有什么好处？ tbb_malloc是完全符合STL Allocator标准，完全可以作为STL中各种容器的内存适配器。纯纯的C&#43;&#43; style，各位cpper用起来想来应该会很舒服。
如何使用tbb_malloc？ tbb_malloc提供了多种申请内存的类以便使用的不同的场合，具体请查看官方文档。我们主要来看下tbb::cache_aligned_allocator&amp;lt; T &amp;gt;。
#include &amp;lt;tbb/cache_aligned_allocator.h&amp;gt; namespace my_alloactor { struct alloc_maker { template &amp;lt;typename T&amp;gt; static tbb::cache_aligned_allocator&amp;lt;T&amp;gt;&amp; get_allocator() { static tbb::cache_aligned_allocator&amp;lt;T&amp;gt; ret; return ret; } }; } #define MY_ALLOC(T, n) ::my_alloactor::alloc_maker::get_allocator&amp;lt;T&amp;gt;().allocate(n) #define MY_FREE(T, p, n) ::my_alloactor::alloc_maker::get_allocator&amp;lt;T&amp;gt;().deallocate(p, n) #define MY_NEW(T) new ((void*)(::my_alloactor::alloc_maker::get_allocator&amp;lt;T&amp;gt;().allocate(1))) T #define MY_DELETE(T, p) if (p) {::my_alloactor::alloc_maker::get_allocator&amp;lt;T&amp;gt;().destroy(p); ::my_alloactor::alloc_maker::get_allocator&amp;lt;T&amp;gt;().deallocate(p, 1);} namespace my_alloactor { struct deleter { template &amp;lt;typename T&amp;gt; void operator()(T* p) { MY_DELETE(T, p); } }; } 以上封装的使用方法如下：
my_t* mt = MY_NEW(my_t)(/* construct funtion arg list */) 当然了，你还可以直接用来作为容器的默认内存适配器，例如：
typedef std::vector&amp;lt;int, tbb::cache_aligned_allocator&amp;lt;int&amp;gt; &amp;gt; tbb_malloc_vector; tbb_malloc_vector my_vec; 还可以将其改造成内存池，使用一个字节的char作为模板参数即可，如下：
tbb::cache_aligned_allocator&amp;lt;char&amp;gt; memory_pool; void* mem = memory_pool.allocate(100); // 即可申请100字节的内存 使用自定义数据结构：
tbb::cache_aligned_allocator&amp;lt;my_t&amp;gt; alloc; void* mem = alloc.allocate(1); my_t* mt = new(m)my_t(/*arg list*/) 申请多个自定义数据结构的内存：
tbb::cache_aligned_allocator&amp;lt;my_t&amp;gt; alloc; my_t* array = (my_t*)alloc.allocate(100); for (size_t i = 0; i &amp;lt; 100; &#43;&#43;i) { array[i] = new (array[i])my_t(/*arg list*/) } 不过需要注意的是如果循环过程中某个new失败了，需要释放之前new的内存以及数据。
&amp;nbsp;
tbb::cache_aligned_allocator的用法也就这么多了，其他的几个allocate类也没用过，tbb的有一本书叫《Intel Threading Building Blocks: Outfitting C&#43;&#43; for Multi-core Processor Parallelism》，有中文版本，不过里面的例子也是非常少。
游戏项目中国外使用tbb的多，mangos中使用了tbb，大家有兴趣可以翻翻mangos的代码。
很多游戏启动的时候会提示找不到tbb_malloc.dll或者tbb.dll，玩家需要自己去tbb官网下载编译好的dll放进去。
更多的关于tbb的介绍可以查看官网介绍：http://www.intel.com/cd/software/products/apac/zho/319508.htm
&amp;nbsp;
btw.感谢nous对tbb用法的指导。
</content>
    </entry>
    
     <entry>
        <title>为何python现在越来越多的人在用了？</title>
        <url>https://cppfans.org/1436.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>Linux</tag><tag>Lua</tag><tag>Luabind</tag><tag>python</tag><tag>编程语言</tag>
        </tags>
        <content type="html"> 曾几何时，python这门语言我并没有听过，那个时候只知道C，后来学了C&#43;&#43;，用了C&#43;&#43; Builder和VS，再后来学了C#的皮毛，继之是Lua，觉得差不多了。但是最近买了本python的书之后，觉得python处理问题更简便了。
C&#43;&#43;之父Bjarne Stroustrup曾经说过：C&#43;&#43;如果没有好的库，可以做的事情有限，但是如果有很多优秀的库，那么C&#43;&#43;无所不能。
而python正是做到了这一点，它有很多优秀的库，xmlrpc、mysql、codec等等（具体更多的库请下载python3自己查看），可以让大家更快速的开发自己需要的功能。
我只是简单的看了python的一些简单的内容，列表、文件、异常、推导数据等，还有xmlrpc和codec库的使用，觉得真心舒服。就拿codec来说，如果你不使用任何库，自己写转码，我觉得包含我在内的一大部分人都写不出来，因为很麻烦。
python的优点还不止这些，他还可以做web应用，移动应用，GUI等等，它有一个共享开放的社区，里面有全世界python爱好者共享的代码（C&#43;&#43;就是因为库太多，并且太分散了，所以挑起来很麻烦）。
当然了，有优点，随之而来的就是缺点了，人们总是吹毛求疵，python运行速度慢是个非常大的缺点，酷壳的站长陈皓跟人比赛分析500MB的mysql，最后存成CSV文件，陈皓用python写的，他那朋友用C&#43;&#43;写的，最后陈皓的运行时间太长了，导致他怀疑是不自己代码写的太烂了。其实并不是这样子的，python运行慢很大一部分原因是自己的问题，所以出现了一个叫Psyco的模块，专门用来加快python的运行速度，后来改名叫PyPy了。有人测试了C和python运行斐波那契数列的速度，没用Psyco之前，C是python的三倍速度，用了之后是差不多时间的。
看了python之后，觉得C&#43;&#43;和python的绝对一对儿好基友，C&#43;&#43;比较死板，而python正好补充了这点，并且有boost.python库，这对基友可以更deep的交流了。
现在网易的游戏在大量使用python，这是从买bigworld留下的习惯，不过感觉python有点过于灵活了，策划不好掌控，一个不慎，可能有很多棘手的问题。而Lua比较近C风格，灵活性也够，导致现在有大量的项目采用Lua作为脚本语言，不过说实话，C&#43;&#43;和Lua交互真心麻烦，当年LuaBind还算好，并且准备提交boost，但是后来不写了，可惜一个好项目了。
好了，本文就说这么多了，全是随性而写，没什么提纲，仅是一篇自己的想法，并无黑某门语言的一说，也请大家不要做无谓之争，谢谢。
</content>
    </entry>
    
     <entry>
        <title>浅析epoll - epoll例子以及分析</title>
        <url>https://cppfans.org/1419.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>epoll</tag><tag>Linux</tag><tag>例子</tag><tag>多路复用</tag><tag>异步I/O</tag><tag>教程</tag>
        </tags>
        <content type="html"> 上篇我们讲到epoll的函数和性能。这一篇用用这些个函数，给出一个最简单的epoll的例子。
// // a simple echo server using epoll in linux // // 2009-11-05 // by sparkling // #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;sys/epoll.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; #define MAX_EVENTS 500 struct myevent_s { int fd; void (*call_back)(int fd, int events, void *arg); int events; void *arg; int status; // 1: in epoll wait list, 0 not in char buff[128]; // recv data buffer int len; long last_active; // last active time }; // set event void EventSet(myevent_s *ev, int fd, void (*call_back)(int, int, void*), void *arg) { ev-&amp;gt;fd = fd; ev-&amp;gt;call_back = call_back; ev-&amp;gt;events = 0; ev-&amp;gt;arg = arg; ev-&amp;gt;status = 0; ev-&amp;gt;last_active = time(NULL); } // add/mod an event to epoll void EventAdd(int epollFd, int events, myevent_s *ev) { struct epoll_event epv = {0, {0}}; int op; epv.data.ptr = ev; epv.events = ev-&amp;gt;events = events; if(ev-&amp;gt;status == 1){ op = EPOLL_CTL_MOD; } else{ op = EPOLL_CTL_ADD; ev-&amp;gt;status = 1; } if(epoll_ctl(epollFd, op, ev-&amp;gt;fd, &amp;epv) &amp;lt; 0) printf(&#34;Event Add failed[fd=%d]/n&#34;, ev-&amp;gt;fd); else printf(&#34;Event Add OK[fd=%d]/n&#34;, ev-&amp;gt;fd); } // delete an event from epoll void EventDel(int epollFd, myevent_s *ev) { struct epoll_event epv = {0, {0}}; if(ev-&amp;gt;status != 1) return; epv.data.ptr = ev; ev-&amp;gt;status = 0; epoll_ctl(epollFd, EPOLL_CTL_DEL, ev-&amp;gt;fd, &amp;epv); } int g_epollFd; myevent_s g_Events[MAX_EVENTS&#43;1]; // g_Events[MAX_EVENTS] is used by listen fd void RecvData(int fd, int events, void *arg); void SendData(int fd, int events, void *arg); // accept new connections from clients void AcceptConn(int fd, int events, void *arg) { struct sockaddr_in sin; socklen_t len = sizeof(struct sockaddr_in); int nfd, i; // accept if((nfd = accept(fd, (struct sockaddr*)&amp;sin, &amp;len)) == -1) { if(errno != EAGAIN &amp;&amp; errno != EINTR) { printf(&#34;%s: bad accept&#34;, __func__); } return; } do { for(i = 0; i &amp;lt; MAX_EVENTS; i&#43;&#43;) { if(g_Events[i].status == 0) { break; } } if(i == MAX_EVENTS) { printf(&#34;%s:max connection limit[%d].&#34;, __func__, MAX_EVENTS); break; } // set nonblocking if(fcntl(nfd, F_SETFL, O_NONBLOCK) &amp;lt; 0) break; // add a read event for receive data EventSet(&amp;g_Events[i], nfd, RecvData, &amp;g_Events[i]); EventAdd(g_epollFd, EPOLLIN|EPOLLET, &amp;g_Events[i]); printf(&#34;new conn[%s:%d][time:%d]/n&#34;, inet_ntoa(sin.sin_addr), ntohs(sin.sin_port), g_Events[i].last_active); }while(0); } // receive data void RecvData(int fd, int events, void *arg) { struct myevent_s *ev = (struct myevent_s*)arg; int len; // receive data len = recv(fd, ev-&amp;gt;buff, sizeof(ev-&amp;gt;buff)-1, 0); EventDel(g_epollFd, ev); if(len &amp;gt; 0) { ev-&amp;gt;len = len; ev-&amp;gt;buff[len] = &#39;/0&#39;; printf(&#34;C[%d]:%s/n&#34;, fd, ev-&amp;gt;buff); // change to send event EventSet(ev, fd, SendData, ev); EventAdd(g_epollFd, EPOLLOUT|EPOLLET, ev); } else if(len == 0) { close(ev-&amp;gt;fd); printf(&#34;[fd=%d] closed gracefully./n&#34;, fd); } else { close(ev-&amp;gt;fd); printf(&#34;recv[fd=%d] error[%d]:%s/n&#34;, fd, errno, strerror(errno)); } } // send data void SendData(int fd, int events, void *arg) { struct myevent_s *ev = (struct myevent_s*)arg; int len; // send data len = send(fd, ev-&amp;gt;buff, ev-&amp;gt;len, 0); ev-&amp;gt;len = 0; EventDel(g_epollFd, ev); if(len &amp;gt; 0) { // change to receive event EventSet(ev, fd, RecvData, ev); EventAdd(g_epollFd, EPOLLIN|EPOLLET, ev); } else { close(ev-&amp;gt;fd); printf(&#34;recv[fd=%d] error[%d]/n&#34;, fd, errno); } } void InitListenSocket(int epollFd, short port) { int listenFd = socket(AF_INET, SOCK_STREAM, 0); fcntl(listenFd, F_SETFL, O_NONBLOCK); // set non-blocking printf(&#34;server listen fd=%d/n&#34;, listenFd); EventSet(&amp;g_Events[MAX_EVENTS], listenFd, AcceptConn, &amp;g_Events[MAX_EVENTS]); // add listen socket EventAdd(epollFd, EPOLLIN|EPOLLET, &amp;g_Events[MAX_EVENTS]); // bind &amp; listen sockaddr_in sin; bzero(&amp;sin, sizeof(sin)); sin.sin_family = AF_INET; sin.sin_addr.s_addr = INADDR_ANY; sin.sin_port = htons(port); bind(listenFd, (const sockaddr*)&amp;sin, sizeof(sin)); listen(listenFd, 5); } int main(int argc, char **argv) { short port = 12345; // default port if(argc == 2){ port = atoi(argv[1]); } // create epoll g_epollFd = epoll_create(MAX_EVENTS); if(g_epollFd &amp;lt;= 0) printf(&#34;create epoll failed.%d/n&#34;, g_epollFd); // create &amp; bind listen socket, and add to epoll, set non-blocking InitListenSocket(g_epollFd, port); // event loop struct epoll_event events[MAX_EVENTS]; printf(&#34;server running:port[%d]/n&#34;, port); int checkPos = 0; while(1){ // a simple timeout check here, every time 100, better to use a mini-heap, and add timer event long now = time(NULL); for(int i = 0; i &amp;lt; 100; i&#43;&#43;, checkPos&#43;&#43;) // doesn&#39;t check listen fd { if(checkPos == MAX_EVENTS) checkPos = 0; // recycle if(g_Events[checkPos].status != 1) continue; long duration = now - g_Events[checkPos].last_active; if(duration &amp;gt;= 60) // 60s timeout { close(g_Events[checkPos].fd); printf(&#34;[fd=%d] timeout[%d--%d]./n&#34;, g_Events[checkPos].fd, g_Events[checkPos].last_active, now); EventDel(g_epollFd, &amp;g_Events[checkPos]); } } // wait for events to happen int fds = epoll_wait(g_epollFd, events, MAX_EVENTS, 1000); if(fds &amp;lt; 0){ printf(&#34;epoll_wait error, exit/n&#34;); break; } for(int i = 0; i &amp;lt; fds; i&#43;&#43;){ myevent_s *ev = (struct myevent_s*)events[i].data.ptr; if((events[i].events&amp;EPOLLIN)&amp;&amp;(ev-&amp;gt;events&amp;EPOLLIN)) // read event { ev-&amp;gt;call_back(ev-&amp;gt;fd, events[i].events, ev-&amp;gt;arg); } if((events[i].events&amp;EPOLLOUT)&amp;&amp;(ev-&amp;gt;events&amp;EPOLLOUT)) // write event { ev-&amp;gt;call_back(ev-&amp;gt;fd, events[i].events, ev-&amp;gt;arg); } } } // free resource return 0; } 上面是一个echo server的例子，下来我们看下echo client的例子
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #define MAXDATASIZE 100 // max number of bytes we can get at once int main(int argc, char *argv[]) { int sockfd, numbytes; char buf[MAXDATASIZE]; struct hostent *he; struct sockaddr_in their_addr; // connector&#39;saddress information if (( argc == 1) || (argc==2) ) { fprintf(stderr,&#34;usage: client hostname\nEx:\n$./client01 ip port\n&#34;); exit(1); } if ((he=gethostbyname(argv[1])) == NULL) { // get the host info herror(&#34;gethostbyname&#34;); exit(1); } if ((sockfd = socket(PF_INET, SOCK_STREAM, 0)) == -1) { perror(&#34;socket&#34;); exit(1); } their_addr.sin_family = AF_INET; // host byte order their_addr.sin_port = htons(atoi(argv[2])); // short, network byte order their_addr.sin_addr = *((struct in_addr *)he-&amp;gt;h_addr); memset(their_addr.sin_zero, &#39;&#39;, sizeof their_addr.sin_zero); if (connect(sockfd, (struct sockaddr *)&amp;their_addr, sizeof their_addr) == -1) { perror(&#34;connect&#34;); exit(1); } while( 1 ) { if(send(sockfd, &#34;hello, this is client message!&#34;, strlen(&#34;hello, this is client message!&#34;), 0 ) == -1) { perror(&#34;send&#34;); } if ((numbytes=recv(sockfd, buf, MAXDATASIZE-1, 0)) == -1) { perror(&#34;recv&#34;); } else if( numbytes == 0 ) { printf(&#34;Remote server has shutdown!\n&#34;); break; } buf[numbytes] = &#39;&#39;; printf(&#34;Received: %s \n&#34;,buf); sleep(1); } close(sockfd); return 0; } 以上客户端和服务器例子均来自网络，自己没有单独写，因为觉得自己写了跟着个差不多还浪费时间，大家有兴趣可以去研究下libevent和libev，这都是很好用的C风格的epoll网络库，或者之际看ASIO吧。
</content>
    </entry>
    
     <entry>
        <title>2013，新的一年，祝大家诸事顺利！</title>
        <url>https://cppfans.org/1432.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>2013</tag><tag>元旦</tag>
        </tags>
        <content type="html"> 今天是2013年了，2012的末日预言我们一起挺过了，感谢大家一致以来对本博客的支持和关注，只有努力写出更多的文章来让大家学习交流。
新年伊始，在这里祝大家在2013年里万事顺利，开开心心，身体健康。
</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; POD(Plain Old Data)类型</title>
        <url>https://cppfans.org/1431.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>C&#43;&#43;标准</tag><tag>POD</tag><tag>数据类型</tag>
        </tags>
        <content type="html"> 群里发过来一份他们公司的笔试题，看了下，发现里面考了一个判断如下是否为POD类型，没搞明白什么是POD，多方查阅后，发现其实是指一个C风格代码的概念。
POD全称Plain Old Data是指C风格的struct结构体定义的数据结构，其中struct结构体中只能定义常规数据类型(不能含有自定义数据类型)。它仅作为被动的收藏的字段值,不使用封包或者other object-oriented特征。
对于POD类型T的对象，不管这个对象是否拥有类型T的有效值，如果将该对象的底层字节序列复制到一个字符数组（或者无符号字符数组）中，再将其复制回对象，那么该对象的值与原始值一样。
对于任意的POD类型T，如果两个T指针分别指向两个不同的对象obj1和obj2，如果用memcpy库函数把obj1的值复制到obj2，那么obj2将拥有与obj1相同的值。
简言之，针对POD对象，其二进制内容是可以随便复制的，在任何地方，只要其二进制内容在，就能还原出正确无误的POD对象。对于任何POD对象，都可以使用memset()函数或者其他类似的内存初始化函数。
以上是C&#43;&#43; 03标准中的定义。
正是因为03标准中对POD限制的太严格了，所以C&#43;&#43; 0x标准中队POD的定义放宽了一些。
如果一个类或结构是平凡的，具有标准布局的，且不包含任何非POD的非静态成员，那么它就被认定是POD。平凡的类或结构定义如下：
1.具有一个平凡的缺省构造器。（可以使用缺省构造器语法，如 SomeConstructor() = default;)
2.具有一个平凡的拷贝构造器。（可以使用缺省构造器语法)
3.具有一个平凡的拷贝赋值运算符。（可以使用缺省语法)
4.具有一个非虚且平凡的析构器。
一个具有标准布局的类或结构被定义如下：
1.所有非静态数据成员均为标准布局类型。
2.所有非静态成员的访问权限(public, private, protected) 均相同。
3.没有虚函数。
4.没有虚基类。
5.所有基类均为标准布局类型。
6.没有任何基类的类型与类中第一个非静态成员相同。
7.要么全部基类都没有非静态数据成员，要么最下层的子类没有非静态数据成员且最多只有一个基类有非静态数据成员。总之继承树中最多只能有一个类有非静态数据成员。所有非静态数据成员必须都是标准布局类型。
&amp;nbsp;
其实说到底，POD就是一个很常规的结构体/类。看个例子：
struct mydata { mydata() : i(0), f(0.0f), c(&#39;1&#39;) {} int i; float f; char c; }; 上面的结构体在C&#43;&#43; 03中不算做一个POD，因为它有构造函数，而在C&#43;&#43; 0x中，这个结构体可以算作是一个POD类型，因为其满足上面的条件(貌似没有非虚的析构函数)。
不过这个东西就是个概念，不明白靠这个东西想了解应聘者的什么知识，难道是对C&#43;&#43;标准的了解？
</content>
    </entry>
    
     <entry>
        <title>[转载]Pthreads mutex VS Pthreads spinlock</title>
        <url>https://cppfans.org/1426.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>mutex</tag><tag>pthread</tag><tag>spinlock</tag><tag>互斥锁</tag><tag>自旋锁</tag>
        </tags>
        <content type="html">  转载自：http://www.searchtb.com/2011/01/pthreads-mutex-vs-pthread-spinlock.html
锁机制(lock) 是多线程编程中最常用的同步机制,用来对多线程间共享的临界区(Critical Section) 进行保护。
Pthreads提供了多种锁机制,常见的有：
1) Mutex（互斥量）：pthread_mutex_***
2) Spin lock（自旋锁）：pthread_spin_***
3) Condition Variable（条件变量）：pthread_con_***
4) Read/Write lock（读写锁）：pthread_rwlock_***
在多线程编中,根据应用场合的不同,选择合适的锁来进行同步,对多线程程序的性能影响非常大. 本文主要对 pthread_mutex 和 pthread_spinlock 两种锁制机进行比较,并讨论其适用的场合.
1.Pthread mutex Mutex属于sleep-waiting类型的锁. 从 2.6.x 系列稳定版内核开始, Linux 的 mutex 都是 futex (Fast-Usermode-muTEX)锁.
futex（快速用户区互斥的简称）是一个在Linux上实现锁定和构建高级抽象锁如信号量和POSIX互斥的基本工具。它们第一次出现在内核开发的2.5.7版；其语义在2.5.40固定下来，然后在2.6.x系列稳定版内核中出现。
Futex 是由Hubertus Franke（IBM Thomas J. Watson 研究中心）, Matthew Kirkwood，Ingo Molnar（Red Hat）和 Rusty Russell（IBM Linux 技术中心）等人创建的。
Futex 是由用户空间的一个对齐的整型变量和附在其上的内核空间等待队列构成. 多进程或多线程绝大多数情况下对位于用户空间的futex 的整型变量进行操作(汇编语言调用CPU提供的原子操作指令来增加或减少),而其它情况下,则需要通过代价较大的系统调用来对位于内核空间的等待队列进行 操作(如唤醒等待的进程/线程,或 将当前进程/线程放入等待队列). 除了多个线程同时竞争锁的少数情况外,基于 futex 的 lock 操作是不需要进行代价昂贵的系统调用操作的.
.
这种机制的核心思想是通过将大多数情况下非同时竞争 lock 的操作放到在用户空间来执行,而不是代价昂贵的内核系统调用方式来执行,从而提高了效率.
Pthreads提供的Mutex锁操作相关的API主要有：
1、 pthread_mutex_lock (pthread_mutex_t *mutex);
2、 pthread_mutex_trylock (pthread_mutex_t *mutex);
3、 pthread_mutex_unlock (pthread_mutex_t *mutex);
因为源代码比较长,这里不做摘录,大家可以参考:
glibc-2.12.2/nptl/pthread_mutex_lock.c
2.Pthread spinlock spinlock，也称自旋锁,是属于busy-waiting类型的锁.在多处理器环境中, 自旋锁最多只能被一个可执行线程持有。如果一个可执行线程试图获得一个被争用(已经被持有的)自旋锁，那么该线程就会一直进行忙等待，自旋，也就是空转， 等待锁重新可用。如果锁未被争用，请求锁的执行线程便立刻得到它，继续执行。
一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋，特别的浪费CPU时间，所以自旋锁不应该被长时间的持有。实际上，这就是自旋锁的设计初衷，在短时间内进行轻量级加锁。
Kernel中的自旋锁不能够在能够导致睡眠的环境中使用。举个例子，一个线程A获得了自旋锁L；这个时候，发生了中断，在对应的中断处理函数B 中，也尝试获得自旋锁L，就会中断处理程序进行自旋。但是原先锁的持有者只有在中断处理程序结束后，采用机会释放自旋锁，从而导致死锁。
由于涉及到多个处理器环境下，spin lock的效率非常重要。因为在等待spin lock的过程，处理器只是不停的循环检查，并不执行其他指令。但即使这样， 一般来说，spinlock的开销还是比进程调度(context switch）少得多。这就是spin lock 被广泛应用在多处理器环境的原因
Pthreads提供的与Spin Lock锁操作相关的API主要有：
pthread_spin_lock (pthread_spinlock_t *lock);
pthread_spin_trylock (pthread_spinlock_t *lock);
pthread_spin_unlock (pthread_spinlock_t *lock);
下面,来看一下spinlock在pthread中的实现:
1) spin lock的数据结构
glibc-2.12.2\nptl\sysdeps\unix\sysv\linux\i386\bits\pthreadtypes.h
typedef volatile int pthread_spinlock_t; 2) pthread_spin_lock
glibc-2.12.2\nptl\sysdeps\i386\pthread_spin_lock.c
#ifndef LOCK_PREFIX # ifdef UP # define LOCK_PREFIX /* nothing */ # else # define LOCK_PREFIX &#34;lock;&#34; # endif #endif int pthread_spin_lock (lock) pthread_spinlock_t *lock; { asm (&#34;\n&#34; &#34;1:\t&#34; LOCK_PREFIX &#34;decl %0\n\t&#34; &#34;jne 2f\n\t&#34; &#34;.subsection 1\n\t&#34; &#34;.align 16\n&#34; &#34;2:\trep; nop\n\t&#34; &#34;cmpl $0, %0\n\t&#34; &#34;jg 1b\n\t&#34; &#34;jmp 2b\n\t&#34; &#34;.previous&#34; : &#34;=m&#34; (*lock) : &#34;m&#34; (*lock)); return 0; } a、 LOCK_PREFIX: 是为了在SMP下锁总线，保证接下来一条指令的原子性。
b、 %0: 这里是*lock的值，先将lock的值减一，如果ZF=0（lock值不为0），跳到下面的2标签处继续执行；否则执行结束（lock值为0）。
c、 jne: Jump near if not equal (ZF=0). Not supported in 64-bit mode.
下面继续看2标签处的代码：
d、 rep; nop: 为实际上为多个nop指令，实际上这条指令可以降低CPU的运行频率，减低电的消耗量，但最重要的是，提高了整体的效率。因为这段指令执行太快的话，会生成很多读取内存变量的指令，另外的一个CPU可能也要写这个内存变量，现在的CPU经常需要重新排序指令来提高效率，如果读指令太多的话，为了保证指令之间的依赖性，CPU会以牺牲流水线执行（pipeline）所带来的好处。从pentium 4以后，intel引进了一条pause指令，专门用于spin lock这种情况，据intel的文档说，加上pause可以提高25倍的效率！。
e、 cmpl $0, %0 :比较lock与0的大小，当发现Lock大于0的时候，跳回到1标签，尝试重新获得锁；否则，跳回到标签2继续进行循环。
f、 标签1处的代码，在尝试获得锁的时候，直接将lock值减1，如果获得锁操作失败的时候，实际上lock值已经被减了1。这样会不会有问题呢？实际上，这个问题不用担心，因为在释放锁的时候，lock的值还会被重新设置为1。
.subsection和.previous之间的这段代码用来检测spin lock何时被释放. 这段代码与其它的常用指令代码并不是放在同一个代码段中的,因为大部分情况下，lock都会成功返回，将这段lock失败后的操作代码与其它的代码分开，会提高高速缓存的效率（有限的高速缓存可以放置更多的数据）。
3) pthread_spin_unlock
glibc-2.12.2\nptl\sysdeps\i386\pthread_spin_unlock.S
.globl pthread_spin_unlock .type pthread_spin_unlock,@function .align 16 pthread_spin_unlock: movl 4(%esp), %eax movl $1, (%eax) xorl %eax, %eax ret .size pthread_spin_unlock,.-pthread_spin_unlock /* The implementation of pthread_spin_init is identical. */ .globl pthread_spin_init pthread_spin_init = pthread_spin_unlock 3.性能测试对比 测试环境
Memory: 16G
Cpu: 8 core
processor : 7 vendor_id : GenuineIntel cpu family : 6 model : 23 model name : Intel(R) Xeon(R) CPU E5410 @ 2.33GHz stepping : 6 cpu MHz : 2327.529 cache size : 6144 KB physical id : 1 siblings : 4 core id : 7 cpu cores : 4 fpu : yes fpu_exception : yes cpuid level : 10 wp : yes flags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm syscall nx lm pni monitor ds_cpl est tm2 cx16 xtpr lahf_lm bogomips : 4655.07 clflush size : 64 cache_alignment : 64 address sizes : 38 bits physical, 48 bits virtual power management: OS: Rhel 5U4 , Linux Kernel : 2.6.18-164.el5
测试方法:
在 case1~case3 中,通过逐渐增加临界区(Critical Section)的长度来比较在此情况下 pthread spinlock 与 pthread mutex 的性能.
Case4: 是在 case1 的基础上,给各个线程增加非临界区的工作,以减少冲突. 在此情况下 pthread spinlock 与 pthread mutex 的性能.
在每个 case 中,从线程数依次从 1个线程增加到 15个线程,
并重复执行 10 次以保证测试结果不受意外情况的影响.
3.1 Case 1:
#include &amp;lt;stdint.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/syscall.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;sched.h&amp;gt; #include &amp;lt;linux/unistd.h&amp;gt; #include &amp;lt;list&amp;gt; #include &#34;TimeHelper.h&#34; #define MAX_ARRAY_NUM 10000000 using namespace std; union AlignInt32 { uint32_t _member; char _align[64]; // for false sharing for multi-core }; struct StatItem { uint32_t _times; uint32_t _id; }; union AlignStat { StatItem _item; char _align[64]; // for false sharing for multi-core }; AlignInt32 g_Array[10000000]; volatile uint32_t g_Index=0; #ifdef USE_SPINLOCK pthread_spinlock_t spinlock; #else pthread_mutex_t mutex; #endif pid_t gettid() { return syscall( __NR_gettid ); } void *consumer(void *arg) { AlignStat* pItem=(AlignStat*)arg; while (1) { #ifdef USE_SPINLOCK pthread_spin_lock(&amp;spinlock); #else pthread_mutex_lock(&amp;mutex); #endif if (g_Index&amp;gt;=MAX_ARRAY_NUM) { #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif break; } &#43;&#43;(pItem-&amp;gt;_item._times); g_Array[g_Index]._member=g_Index; &#43;&#43;g_Index; #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif } return NULL; } int main(int argc, char *argv[]) { uint64_t t1,t2; uint64_t nTimeSum=0; uint32_t nThreadNum=0; #ifdef USE_SPINLOCK pthread_spin_init(&amp;spinlock, 0); fprintf(stderr,&#34;case for spinlock: &#34;); #else pthread_mutex_init(&amp;mutex, NULL); fprintf(stderr,&#34;case for mutex: &#34;); #endif int32_t nCpuNum = (int)sysconf( _SC_NPROCESSORS_ONLN )*2; fprintf(stderr,&#34;cpu_num=%d\n&#34;,nCpuNum/2); for(int32_t j=1; j&amp;lt; nCpuNum; j&#43;&#43;) { nTimeSum=0; nThreadNum=j; AlignStat *pStatArray= new AlignStat[nThreadNum]; memset(pStatArray,0x0,nThreadNum*sizeof(AlignStat)); for(uint32_t nLoop=10; nLoop&amp;gt; 0 ; nLoop--) { g_Index=0; pthread_t * pThreadArray=new pthread_t[nThreadNum]; // Measuring time before starting the threads... t1=TimeHelper::nowTime(); for(uint32_t i=0; i &amp;lt;nThreadNum; i&#43;&#43;) { pStatArray[i]._item._id=i; if ( pthread_create(&amp;pThreadArray[i], NULL, consumer, (void *)(&amp;pStatArray[i]) )) { perror( &#34;error: pthread_create&#34; ); nThreadNum = i; break; } } for(uint32_t i=0; i &amp;lt;nThreadNum; i&#43;&#43;) { pthread_join(pThreadArray[i], NULL); } // Measuring time after threads finished... t2=TimeHelper::nowTime(); nTimeSum&#43;=t2-t1; delete [] pThreadArray; } fprintf(stderr,&#34;RepeatTimes=%d, ThreadNum=%d, UsedTime=%.6lf s\n&#34;,10, nThreadNum,(double(nTimeSum))/1000000); for(uint32_t i=0; i &amp;lt;nThreadNum; i&#43;&#43;) { fprintf(stderr,&#34;thread_id=%u\t times=%u\n&#34;,pStatArray[i]._item._id,pStatArray[i]._item._times); } delete [] pStatArray; } #ifdef USE_SPINLOCK pthread_spin_destroy(&amp;spinlock); #else pthread_mutex_destroy(&amp;mutex); #endif return 0; } 

3.2 Case2
void *consumer(void *arg) { AlignStat* pItem=(AlignStat*)arg; while (1) { #ifdef USE_SPINLOCK pthread_spin_lock(&amp;spinlock); #else pthread_mutex_lock(&amp;mutex); #endif if (g_Index&amp;gt;=MAX_ARRAY_NUM) { #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif break; } &#43;&#43;(pItem-&amp;gt;_item._times); g_Array[g_Index]._member=g_Index; &#43;&#43;g_Index; // add critical section&#39;s length list&amp;lt;uint32_t&amp;gt; tmpList; for(uint32_t i=0; i&amp;lt; 6; i&#43;&#43;) { tmpList.push_back(i); } #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif } return NULL; } 

void *consumer(void *arg) { AlignStat* pItem=(AlignStat*)arg; while (1) { #ifdef USE_SPINLOCK pthread_spin_lock(&amp;spinlock); #else pthread_mutex_lock(&amp;mutex); #endif if (g_Index&amp;gt;=MAX_ARRAY_NUM) { #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif break; } &#43;&#43;(pItem-&amp;gt;_item._times); g_Array[g_Index]._member=g_Index; &#43;&#43;g_Index; #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif //do same work //AlignInt32 tmpArray[10000000]; //uint32_t tmpArray[10000000]; list&amp;lt;uint32_t&amp;gt; tmpList; for(uint32_t i=0; i&amp;lt; 20; i&#43;&#43;) { tmpList.push_back(i); //tmpArray[i]._member=i; //tmpArray[i]=i; } } return NULL; } xxxx


4.不同线程数下 spinlock分析 以下数据是用 intel vtune 采集得到
4.1 源代码
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/syscall.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;sys/time.h&amp;gt; #include &amp;lt;sched.h&amp;gt; #include &amp;lt;linux/unistd.h&amp;gt; #include &amp;lt;list&amp;gt; #include &#34;TimeHelper.h&#34; #define MAX_ARRAY_NUM 10000000 using namespace std; struct StatItem { uint32_t _times; uint32_t _id; }; union AlignStat { StatItem _item; char _align[64]; // for false sharing for multi-core }; volatile uint32_t g_Index=0; #ifdef USE_SPINLOCK pthread_spinlock_t spinlock; #else pthread_mutex_t mutex; #endif pid_t gettid() { return syscall( __NR_gettid ); } void *consumer(void *arg) { AlignStat* pItem=(AlignStat*)arg; while (1) { #ifdef USE_SPINLOCK pthread_spin_lock(&amp;spinlock); #else pthread_mutex_lock(&amp;mutex); #endif if (g_Index&amp;gt;=MAX_ARRAY_NUM) { #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif break; } &#43;&#43;(pItem-&amp;gt;_item._times); &#43;&#43;g_Index; #ifdef USE_SPINLOCK pthread_spin_unlock(&amp;spinlock); #else pthread_mutex_unlock(&amp;mutex); #endif } return NULL; } int main(int argc, char *argv[]) { if(argc &amp;lt; 2) { fprintf(stderr,&#34;%s thread_num\n&#34;,argv[0]); exit(-1); } uint64_t t1,t2; uint64_t nTimeSum=0; uint32_t nThreadNum=(uint32_t)atoi(argv[1]); #ifdef USE_SPINLOCK pthread_spin_init(&amp;spinlock, 0); fprintf(stderr,&#34;case for spinlock: \n&#34;); #else pthread_mutex_init(&amp;mutex, NULL); fprintf(stderr,&#34;case for mutex: \n&#34;); #endif nTimeSum=0; AlignStat *pStatArray= new AlignStat[nThreadNum]; memset(pStatArray,0x0,nThreadNum*sizeof(AlignStat)); for(uint32_t nLoop=10; nLoop&amp;gt; 0 ; nLoop--) { g_Index=0; pthread_t * pThreadArray=new pthread_t[nThreadNum]; // Measuring time before starting the threads... t1=TimeHelper::nowTime(); for(uint32_t i=0; i &amp;lt;nThreadNum; i&#43;&#43;) { pStatArray[i]._item._id=i; if ( pthread_create(&amp;pThreadArray[i], NULL, consumer, (void *)(&amp;pStatArray[i]) )) { perror( &#34;error: pthread_create&#34; ); nThreadNum = i; break; } } for(uint32_t i=0; i &amp;lt;nThreadNum; i&#43;&#43;) { pthread_join(pThreadArray[i], NULL); } // Measuring time after threads finished... t2=TimeHelper::nowTime(); nTimeSum&#43;=t2-t1; delete [] pThreadArray; } fprintf(stderr,&#34;RepeatTimes=%d, ThreadNum=%d, UsedTime=%.6lf s\n&#34;,10, nThreadNum,(double(nTimeSum))/1000000); for(uint32_t i=0; i &amp;lt;nThreadNum; i&#43;&#43;) { fprintf(stderr,&#34;thread_id=%u\t times=%u\n&#34;,pStatArray[i]._item._id,pStatArray[i]._item._times); } delete [] pStatArray; #ifdef USE_SPINLOCK pthread_spin_destroy(&amp;spinlock); #else pthread_mutex_destroy(&amp;mutex); #endif return 0; } 编译:
g&#43;&#43; -g -O2 -Wall -I./ -DUSE_SPINLOCK -lpthread t_spinlock_thread.cpp -o t_spin_thread g&#43;&#43; -g -O2 -Wall -I./ -lpthread t_spinlock_thread.cpp -o t_mutex_thread 4.2 Spinlock 在不同线程数下锁总线统计
4.2.1 t_spin_thread_1

4.2.2 t_spin_thread_2

4.2.3 t_spin_thread_3

4.2.4 t_spin_thread_4

4.2.5 t_spin_thread_5

4.2.6 t_spin_thread_6

4.2.7 t_spin_thread_7

4.2.8 t_spin_thread_8

5 测试结果分析 1) 现象1: 在性能对比测试 case1,case2,case3 中, spinlock 版本程序的运行时间基本上是随线程数的增加而递增的?
在对锁竞争激烈case1,case2,case3 情况下,因为除了临界区,线程不用执行其他任务, 任务实际是串行执行的.
spinlock 的循环偿试时是需要锁总线( lock bus)的,随着线程的增多,每个线程取得锁的概率就越小,循环偿试等待的概率就越大, 锁总线的操作也越频繁(见4.2Spinlock 在不同线程数下锁总线统计),从而导致临界区任务所需的执行时间就越长. 而且当线程大于cpu core 的个数后,可能会有线程切换.
2) 现象2: 在性能对比测试 case1,case2,case3 中, mutex 版本程序的运行时间先随线程数从 1增加到 3 而增加,然后随着线程数的进一步增加而减少,直到达到8个线程数后稳定下来.
这个现象的前半部 随着线程数从 1 个线程增加到 3个线程,执行时间增加还好理解,因为在case1,case2,case3 情况下,因为除了临界区,线程不用执行其他任务,此时任务实际是串行执行的,所以1个线程时执行时间最少,因为没有其他线程来竞争锁, futex 在用户态就可以取得锁. 当线程从1个逐步增加到3个时, 因为锁竞争越来越激列,所以其在用户态就取得锁的概率也越低,从而需要进入相比用户态下取得锁的代价大很多的内核系统调用,所以执行所需时间相应增加.
这个现象的后半部随着线程数从 4 个线程增加到 15个线程时,执行时间又开始逐步减少,并到 8 个线程时逐步稳定. 这个从比较难以理解.
我猜测是因为临界区短,线程取得锁后很快就会释放,所以在 3-4个线程时,线程因取不到锁而进行系统调用进入等待的这段代码
我是这样理解的,将Consumer 线程的可以划分成3部分:
pthread_mutex_lock为Task1,执行时间T1, 并可细分成两种:
在用户态直接获得锁的时间 T11
通过系统调用等待锁后被唤醒得到锁 T12
临界区为Task2, 执行时间 T2,
pthread_mutex_unlock为Task3, 执行时间T3.
在用户态直接释放锁的时间 T31
通过系统调用释放锁 T32
其中临界区的代码是被串行执行的,但 pthread_mutex_lock 和pthread_mutex_unlock 是各线程并发执行的,由于临界区很比较短,所以 T12和 T32远大于 T2. 因此,在并发度不够高时,Task1 和 Task3 重叠执行的部分就相对就小,所以 T12和 T32占总执行时长的比例就大,而随着线程数的增多, Task1 和 Task3 重叠执行的部分就相对递增,则其占总执行时长的比例就开始下降. 当线程数达到 cpu core 数后,就基本稳定下来了.
同时 T12和T32 与 T2相比越大,则下降越明显,这个可以解释从临界区长度从case1 到 case3 递增后,总执行时间的下降程序也相应变缓.
3) 现象3: 在性能对比测试 case1,case2,case3 中,线程数相对少的情况下(case1是5个线程, case3是 8个线程),spinlock版本的执行时间比 mutex 版本的执行时间要少,但之后,则相反.
这个现象我是这样理解的,在对锁竞争激烈case1,case2,case3 情况下,因为除了临界区,线程不用执行其他任务, 任务实际是串行执行的.此时,在线程数少的情况下, spinlock 比 mutex 的性能要好,随着线程数的增多, spinlock 的性能比 mutex 就变差. 原因是随着线程数的增加, spinlock 循环等待的代价逐渐比mutex 的睡眠等待而产生的上下文切换的系统调用的代价更大.
4) 现象 4: 在性能对比测试 case1,case2,case3 中, 从 case1 到 case3 ,临界区逐渐变长, spinlock 的性能比 mutex 的性能好的情况从 case1 的5个线程逐渐增加到 case3 的8个线程.

在采用 spinlock 机制的的情况下, 随着临界区的变长, spinlock 循环等待过程中 锁总线的次数随临界区代码的长度而相应的增加,所以case1~case3 的情况下,其执行时间基本是按相应比例增加的.
而正如现象 2 所解释的,而采用 mutex 机制的情况下其执行时间是选增后减的,所以会有交叉. 又因为随着临界区的变长, mutex 的执行时间在下降部分会变缓,所以与 spinlock 的交叉相与对靠后.
5) 现象 5: 在性能测试中,线程除了临界区的代码外,还有另外的代码要执行,在线程数 从 1 个到 11 个之间, spinlock 版本的执行时间比 mutex 版本的执行时间要好,特别是 6个线程时, spinlock 版本的执行时间只有mutex 版本的执行时间的 26% 左右.
此情况主要模拟锁竞争不激烈,同时临界区又比较短的情况; 这种情况下, 线程数从 1个增加到 6个左右时,spinlock 基本需要循环等待的概率很小,而每个线程又分摊了临界区的任务,所以6个线程左右时, spinlock 版本的执行时间最短.
6) 现象6: 在测试过程中,使用 spinlock 的 cpu 时间会比 mutex 高很多,因为 spinlock 是循环空等待.
6 附录 6.1 测试数据
6.2 参考:
http://en.wikipedia.org/wiki/Futex
http://www.alexonlinux.com/pthread-mutex-vs-pthread-spinlock
</content>
    </entry>
    
     <entry>
        <title>wordpress中加载JQuery库的几种方法</title>
        <url>https://cppfans.org/1425.html</url>
        <categories>
          <category>Wordpress</category><category>技术文章</category>
        </categories>
        <tags>
          <tag>JQuery</tag><tag>JQueryUI</tag><tag>sae</tag><tag>wordpress</tag>
        </tags>
        <content type="html"> Jquery是继prototype之后又一个优秀的Javascrīpt框架。它是轻量级的js库(压缩后只有21k) ，它兼容CSS3，还兼容各种浏览器 （IE 6.0&#43;, FF 1.5&#43;, Safari 2.0&#43;, Opera 9.0&#43;）。jQuery使用户能更方便地处理HTML documents、events、实现动画效果，并且方便地为网站提供AJAX交互。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种 应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。
正是因为JQuery体积小，并且开发效率快，特效多等特点，现在越来越多的web开发者开始使用JQuery来作为JS库，而我只在wordpress中使用JQuery，wordpress中已经包含了最新的JQuery.min.js文件，所以不需要从官网或者google CDN来获取了，下面是几种wordpress引入JQuery的方法，以供大家借鉴。
1.wordpress自带函数
&amp;lt;?php wp_enqueue_script(&#39;jquery&#39;); ?&amp;gt; 2.从自己的主题模板中加载(前提是你的模板页使用了JS，不过现在貌似都有使用的)
&amp;lt;script type=&#34;text/javascript&#34; src=&#34;&amp;lt;?php bloginfo(&#39;template_url&#39;); ?&amp;gt;/js/jquery.min.js&#34;&amp;gt;&amp;lt;/script&amp;gt; 3.从MS CDN加载
&amp;lt;script type=&#34;text/javascript&#34; src=&#34;http://ajax.microsoft.com/ajax/jquery/jquery-1.8.3.min.js&#34;&amp;gt;&amp;lt;/script&amp;gt; 4.从google CDN加载
&amp;lt;script type=&#34;text/javascript&#34; src=&#34;http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js&#34;&amp;gt;&amp;lt;/script&amp;gt; 5.从国内的开发平台上加载(防止googleapis的网站打开慢，导致前台加载慢的情况)，这里是从sae加载
&amp;lt;script type=&#34;text/javascript&#34; src=&#34;http://lib.sinaapp.com/js/jquery/1.8.3/jquery.min.js&#34;&amp;gt;&amp;lt;/script&amp;gt; 备注：关于sae上关于JQuery的介绍和路径可以查看新浪sae/文档中心/PHP/开发手册/公共资源和sae JQuery目录
(BAE，ACE，GAE应该也有JQuery，不过懒得去翻文档了)
前一段时间我的博客前台加载慢的原因就是因为ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js加载太慢了，原因大家都懂得，查了下是因为myQaptcha(文章评论滑动锁的插件)里面使用了JQuery，并且是直接攻google CDN加载的，很多次导致加载太慢了。现在直接修改为sae的JQuery路径，比以前好多了。
</content>
    </entry>
    
     <entry>
        <title>浅析epoll - epoll函数深入讲解</title>
        <url>https://cppfans.org/1418.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>epoll</tag><tag>I/O</tag><tag>Linux</tag><tag>网络开发</tag><tag>高性能</tag>
        </tags>
        <content type="html">  前一篇大致讲了一下epoll是个什么东西，优点等内容，这篇延续上一篇的内容，主要是分析epoll的函数，epoll高性能的深入分析。
epoll的三大函数 1.创建epoll fd函数
int epoll_create(int size); epoll_create()创建一个epoll的事例，通知内核需要监听size个fd。size指的并不是最大的后备存储设备，而是衡量内核内部结构大小的一个提示。当创建成功后，会占用一个fd，所以记得在使用完之后调用close()，否则fd可能会被耗尽。
Note:自从Linux2.6.8版本以后，size值其实是没什么用的，不过要大于0，因为内核可以动态的分配大小，所以不需要size这个提示了。
创建还有另外一个函数
int epoll_create1(int flag); 这个函数是在linux 2.6.27中加入的，当你在看陈硕的muduo时可以看到这个函数，其实它和epoll_create差不多，不同的是epoll_create1函数的参数是flag，当flag是0时，表示和epoll_create函数完全一样，不需要size的提示了。
当flag = EPOLL_CLOEXEC，创建的epfd会设置FD_CLOEXEC
当flag = EPOLL_NONBLOCK，创建的epfd会设置为非阻塞
一般用法都是使用EPOLL_CLOEXEC.
Note:关于FD_CLOEXEC，现在网上好多都说的有点问题，我翻阅了一些资料，请教了一些人，大约明白它的意思了。
它是fd的一个标识说明，用来设置文件close-on-exec状态的。当close-on-exec状态为0时，调用exec时，fd不会被关闭；状态非零时则会被关闭，这样做可以防止fd泄露给执行exec后的进程。关于exec的用法，大家可以去自己查阅下，或者直接man exec。
2.epoll事件的注册函数
int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event); select是在监听时告诉内核要监听的事件，而epoll_ctl是先注册需要监听的事件。
第一个参数epfd，为epoll_create返回的的epoll fd。
第二个参数op表示操作值。有三个操作类型，
EPOLL_CTL_ADD // 注册目标fd到epfd中，同时关联内部event到fd上 EPOLL_CTL_MOD // 修改已经注册到fd的监听事件 EPOLL_CTL_DEL // 从epfd中删除/移除已注册的fd，event可以被忽略，也可以为NULL 第三个参数fd表示需要监听的fd。
第四个参数event表示需要监听的事件。
typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; struct epoll_event { uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; event参数是一个枚举的集合，可以用&amp;rdquo; | &amp;ldquo;来增加事件类型，枚举如下：
EPOLLIN:表示关联的fd可以进行读操作了。
EPOLLOUT:表示关联的fd可以进行写操作了。
EPOLLRDHUP(since Linux 2.6.17):表示套接字关闭了连接，或者关闭了正写一半的连接。
EPOLLPRI:表示关联的fd有紧急优先事件可以进行读操作了。
EPOLLERR:表示关联的fd发生了错误，epoll_wait会一直等待这个事件，所以一般没必要设置这个属性。
EPOLLHUP:表示关联的fd挂起了，epoll_wait会一直等待这个事件，所以一般没必要设置这个属性。
EPOLLET:设置关联的fd为ET的工作方式，epoll的默认工作方式是LT。
EPOLLONESHOT (since Linux 2.6.2):设置关联的fd为one-shot的工作方式。表示只监听一次事件，如果要再次监听，需要把socket放入到epoll队列中。
3.epoll等待事件函数
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
int epoll_pwait(int epfd, struct epoll_event *events, int maxevents, int timeout, const sigset_t *sigmask);
上面两个函数的参数含义：
第一个参数:表示epoll_wait等待epfd上的事件
第二个参数:events指针携带有epoll_data_t数据
第三个参数:maxevents告诉内核events有多大，该值必须大于0
第四个参数:timeout表示超时时间(单位：毫秒)
epoll_pwait(since linux 2.6.19)允许一个应用程序安全的等待，直到fd设备准备就绪，或者捕获到一个信号量。其中sigmask表示要捕获的信号量。
函数如果等待成功，则返回fd的数字；0表示等待fd超时，其他错误号请查看errno
函数到这里就讲完了，下一篇会写一个例子给大家看下这些函数是如何使用的。
</content>
    </entry>
    
     <entry>
        <title>浅析epoll-为何多路复用I/O要使用epoll</title>
        <url>https://cppfans.org/1417.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>epoll</tag><tag>Linux</tag><tag>网络开发</tag>
        </tags>
        <content type="html">  现如今，网络通讯中用epoll(linux)和IOCP(windows)几乎是大家津津乐道的东西，不为别的，就因为高效，所以大家喜欢用。IOCP的基础东西已经讲过了，可翻阅《IOCP浅析》 《IOCP浅析[二]——IOCP出现的意义和函数接口》.
什么是epoll？ epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集 合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符 集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的电平触发 （Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。Linux2.6内核中对/dev/epoll设备的访问的封装（system epoll）。
这个使我们开发网络应用程序更加简单，并且更加高效。
为什么要使用epoll？ 同样，我们在linux系统下，影响效率的依然是I/O操作，linux提供给我们select/poll/epoll等多路复用I/O方式_(kqueue暂时没研究过)_，为什么我们对epoll情有独钟呢？原因如下：
1.文件描述符数量的对比。
epoll并没有fd(文件描述符)的上限，它只跟系统内存有关，我的2G的ubuntu下查看是20480个，轻松支持20W个fd。可使用如下命令查看：
cat /proc/sys/fs/file-max 再来看select/poll，有一个限定的fd的数量，linux/posix_types.h头文件中
#define __FD_SETSIZE 1024 2.效率对比。
当然了，你可以修改上述值，然后重新编译内核，然后再次写代码，这也是没问题的，不过我先说说select/poll的机制，估计你马上会作废上面修改枚举值的想法。
select/poll会因为监听fd的数量而导致效率低下，因为它是轮询所有fd，有数据就处理，没数据就跳过，所以fd的数量会降低效率；而epoll只处理就绪的fd，它有一个就绪设备的队列，每次只轮询该队列的数据，然后进行处理。(先简单讲一下，第二篇还会详细讲解)
3.内存处理方式对比。
不管是哪种I/O机制，都无法避免fd在操作过程中拷贝的问题，而epoll使用了mmap(是指文件/对象的内存映射，被映射到多个内存页上)，所以同一块内存就可以避免这个问题。
btw:TCP/IP协议栈使用内存池管理sk_buff结构，你还可以通过修改内存池pool的大小，毕竟linux支持各种微调内核。
epoll的工作方式 epoll分为两种工作方式LT和ET。
LT(level triggered) 是默认/缺省的工作方式，同时支持 block和no_block socket。这种工作方式下，内核会通知你一个fd是否就绪，然后才可以对这个就绪的fd进行I/O操作。就算你没有任何操作，系统还是会继续提示fd已经就绪，不过这种工作方式出错会比较小，传统的select/poll就是这种工作方式的代表。
ET(edge-triggered) 是高速工作方式，仅支持no_block socket，这种工作方式下，当fd从未就绪变为就绪时，内核会通知fd已经就绪，并且内核认为你知道该fd已经就绪，不会再次通知了，除非因为某些操作导致fd就绪状态发生变化。如果一直不对这个fd进行I/O操作，导致fd变为未就绪时，内核同样不会发送更多的通知，因为only once。所以这种方式下，出错率比较高，需要增加一些检测程序。
LT可以理解为水平触发，只要有数据可以读，不管怎样都会通知。而ET为边缘触发，只有状态发生变化时才会通知，可以理解为电平变化。
如何使用epoll？ 使用epoll很简单，只需要
#include &amp;lt;sys/epoll.h&amp;gt; 有三个关键函数：
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_events* event);
int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);
当然了，不要忘记关闭函数.
&amp;nbsp;
============分割线==============
这篇就讲到这里了，下面两篇主要是函数介绍，效率分析，例子。
</content>
    </entry>
    
     <entry>
        <title>Ubuntu12.04下安装eclipse C/C&#43;&#43;开发环境</title>
        <url>https://cppfans.org/1413.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C/C&#43;&#43;</tag><tag>CDT</tag><tag>eclipse</tag><tag>Linux</tag><tag>Ubuntu</tag>
        </tags>
        <content type="html">  前段时间在linux上一直使用的是codeblocks，但是感觉提示还是不智能，所以想试试eclipse，下载安装。
安装方法有两种，都很简单。
方法一 打开Ubuntu软件中心，查找到eclipse，然后安装即可
方法二 打开终端
sudo apt-get install eclipse sudo ap-get install eclipse-pde sudo ap-get install eclipse-jdt 因为我们需要开发C/C&#43;&#43;项目，所以需要额外安装一些插件，CDT。
安装方法：
启动eclipse，选择help -&amp;gt; Install new software&amp;hellip; -&amp;gt; work with框中输入：http://download.eclipse.org/releases/galileo,添加完之后会搜索到CDT的一些内容。
选择Collaboration -&amp;gt; Mylyn Bridge:C/C&#43;&#43; Development
选择programming languages -&amp;gt; Eclipse C/C&#43;&#43; Development
然后安装，同意条款后开始安装，大概有几分钟吧，然后会提示是否重启，重启后你会看到welcome页面有C/C&#43;&#43;的说明了，建立新项目也有C/C&#43;&#43;项目了。
btw.如果你嫌麻烦，那么请去www.eclipse.org下载eclipse IDE for C/C&#43;&#43; 版本安装。
</content>
    </entry>
    
     <entry>
        <title>[转载]永远不要将三种东西放进数据库里</title>
        <url>https://cppfans.org/1412.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>优化</tag><tag>数据库</tag><tag>避免错误</tag>
        </tags>
        <content type="html">   导读：作者Frank Wiles发 表了一篇博文,Frank Wiles曾在很多演讲里说过,改进你的系统的最好的方法是先避免做“蠢事”.并不是说你或你开发的东西“蠢”,只是有些决定很容易被人们忽略掉其暗含的 牵连,认识不到这样做对系统维护尤其是系统升级带来多大的麻烦.作为一个顾问,像这样的事情我到处都能见到,我还从来没有见过做出这样的决定的人有过好的 结果的.
 图片,文件,二进制数据 既然数据库支持BLOB类型的数据,把文件塞进BLOB字段里一定没有错了！？错,不是这样的！别的先不提,在很多数据库语言里,处理大字段都不是很容易.
把文件存放在数据库里有很多问题：
 对数据库的读/写的速度永远都赶不上文件系统处理的速度 数据库备份变的巨大,越来越耗时间 对文件的访问需要穿越你的应用层和数据库层  这后两个是真正的杀手.把图片缩略图存到数据库里？很好,那你就不能使用nginx或其它类型的轻量级服务器来处理它们了.
给自己行个方便吧,在数据库里只简单的存放一个磁盘上你的文件的相对路径,或者使用S3或CDN之类的服务.
短生命期数据 使用情况统计数据,测量数据,GPS定位数据,session数据,任何只是短时间内对你有用,或经常变化的数据.如果你发现自己正在使用定时任务 从某个表里删除有效期只有一小时,一天或数周的数据,那说明你没有找对正确的做事情的方法.使用redis, statsd/graphite, Riak,它们都是干这种事情更合适的工具.这建议也适用于对于收集那些短生命期的数据.
当然,用挖土机在后花园里种土豆也是可行的,但相比起从储物间里拿出一把铲子,你预约一台挖土机、等它赶到你的园子里挖坑,这显然更慢.你要选择合适的工具来处理手头上的事.
日志文件 把日志数据存放到数据库里,表面上看起来似乎不错,而且“将来也许我需要对这些数据进行复杂的查询”,这样的话很得人心.这样做并不是一个特别差的做法,但如果你把日志数据和你的产品数据存放到一个数据库里就非常不好了.
也许你的日志记录做的很保守,每次web请求只产生一条日志.对于整个网站的每个事件来说,这仍然会产生大量的数据库插入操作,争夺你用户需要的数据库资源.如果你的日志级别设置为verbose或debug,那等着看你的数据库着火吧.
你应该使用一些比如Splunk Loggly或纯文本文件来存放你的日志数据.这样去查看它们也许会不方便,但这样的时候不多,甚至有时候你需要写出一些代码来分析出你想要的答案,但总的来说是值得的.
可是稍等一下,你是那片不一样的雪花,你遇到的问题会如此的不同,所以,如果你把上面提到的三种东西中的某一种放到了数据库里也不会有问题.不,你错了,不,你不特殊.相信我.
&amp;nbsp;
译文出自：外刊IT评论
英文出自：revsys
</content>
    </entry>
    
     <entry>
        <title>Unix网络编程第三版中代码环境搭建</title>
        <url>https://cppfans.org/1411.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>Unix</tag><tag>开发环境</tag><tag>搭建</tag><tag>网络编程</tag>
        </tags>
        <content type="html">  最近在啃《Unix网络编程第三版 卷1》，其中出现了很多关于unp.h的地方，应该是书中自带的文件，搜索了一下，下载了源代码来自己编译。
源代码下载地址：unpv13e.tar.gz下载
&amp;nbsp;
编译步骤 tar zxvf unpv13e.tar.gz ./configure cd lib make cd ../libfree make cd ../libgai make cd .. // 回到主目录 // 修改unp.h gedit lib/unp.h // 修改 #include &#34;../config.h&#34; 为 #include &#34;config.h&#34; // 拷贝头文件 sudo cp config.h /usr/local/include sudo cp lib/unp.h /usr/local/include // 拷贝库文件 sudo cp libunp.a /usr/local/lib // 下来我们就可以编译书中的一些例子了，可以使用库文件链接 -lunp 这样整个unix网络编程这本书的开发环境就搭建好了，你可以在你的编辑器中调用unp.h文件了。
btw.如果你看的是第二版，并且有第二版的代码unpv12e.tar.gz，并且发现编译不过，则可以参考下这片文章的解决办法，http://blog.csdn.net/a649518776/article/details/6724121。不过不建议使用第二版的代码，需要浪费一些时间来解决问题。
</content>
    </entry>
    
     <entry>
        <title>对象序列化类库MsgPack介绍</title>
        <url>https://cppfans.org/1410.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>MsgPack</tag><tag>反序列化</tag><tag>多语言</tag><tag>序列化</tag><tag>类库</tag><tag>跨平台</tag><tag>高效</tag>
        </tags>
        <content type="html">  MessagePack(以下简称MsgPack)一个基于二进制高效的对象序列化类库，可用于跨语言通信。它可以像JSON那样，在许多种语言之间交换结构对象；但是它比JSON更快速也更轻巧。支持Python、Ruby、Java、C/C&#43;&#43;等众多语言。比Google Protocol Buffers还要快4倍。
代码：
 require &amp;lsquo;msgpack&amp;rsquo;
msg = [1,2,3].to_msgpack #=&amp;gt; &amp;ldquo;\x93\x01\x02\x03&amp;rdquo;
MessagePack.unpack(msg) #=&amp;gt; [1,2,3]
 以上摘自oschina介绍。
msgpack官方主页：http://msgpack.org/
github主页：https://github.com/msgpack/msgpack
因我只使用C&#43;&#43;版本，故只下载了CPP部分，大家请按需下载。
源码安装msgpack 打开终端下载msgpac 4 cpp最新版本0.5.7
wget http://msgpack.org/releases/cpp/msgpack-0.5.7.tar.gz 解压
tar zxvf msgpack-0.5.7.tar.gz 进入解压后的文件夹中进行安装
cd msgpack-0.5.7 ./configure make sudo make install 当然了，你也可以使用git和svn直接抓取源代码进行编译，不过需要安装版本控制工具。
自动安装msgpack apt-get install libmsgpack-dev (安装过程中会将头文件拷贝到 /usr/local/include/ 库文件拷贝到/usr/local/lib/)
安装好了，我们直接使用用它看看效果。
直接包含msgpack.hpp即可使用。
simple using #include &amp;lt;msgpack.hpp&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;iostream&amp;gt; int main() { std::vector&amp;lt;std::string&amp;gt; _vecString; _vecString.push_back(&#34;Hello&#34;); _vecString.push_back(&#34;world&#34;); // pack msgpack::sbuffer _sbuffer; msgpack::pack(_sbuffer, _vecString); std::cout &amp;lt;&amp;lt; _sbuffer.data() &amp;lt;&amp;lt; std::endl; // unpack msgpack::unpacked msg; msgpack::unpack(&amp;msg, _sbuffer.data(), _sbuffer.size()); msgpack::object obj = msg.get(); std::cout &amp;lt;&amp;lt; obj &amp;lt;&amp;lt; std::endl; // convert std::vector&amp;lt;std::string&amp;gt; _vecRString; obj.convert(&amp;_vecRString); // print for(size_t i = 0; i &amp;lt; _vecRString.size(); &#43;&#43;i) { std::cout &amp;lt;&amp;lt; _vecRString[i] &amp;lt;&amp;lt; std::endl; } return 0; } 结果就不贴了，大家自己运行下便知。
using stream #include &amp;lt;msgpack.hpp&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;iostream&amp;gt; int main() { // msgpack stream // use msgpack::packer to pack multiple objects. msgpack::sbuffer buffer_; msgpack::packer pack_(&amp;buffer_); pack_.pack(std::string(&#34;this is 1st string&#34;)); pack_.pack(std::string(&#34;this is 2nd string&#34;)); pack_.pack(std::string(&#34;this is 3th string&#34;)); // use msgpack::unpacker to unpack multiple objects. msgpack::unpacker unpack_; unpack_.reserve_buffer(buffer_.size()); memcpy(unpack_.buffer(), buffer_.data(), buffer_.size()); unpack_.buffer_consumed(buffer_.size()); msgpack::unpacked result_; while (unpack_.next(&amp;result_)) { std::cout &amp;lt;&amp;lt; result_.get() &amp;lt;&amp;lt; std::endl; } return 0; } 使用sbuffer stream序列化多个对象。
如何序列化自定义数据结构 msgpack支持序列化/反序列化自定义数据结构，只需要简单的使用MSGPACK_DEFINE宏即可。
##include &amp;lt;msgpack.hpp&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;string&amp;gt; class my_class { private: std::string my_string; std::vector vec_int; std::vector vec_string; public: MSGPACK_DEFINE(my_string, vec_int, vec_string); }; int main() { std::vector&amp;lt;my_class&amp;gt; my_class_vec; // add some data msgpack::sbuffer buffer; msgpack::pack(buffer, my_class_vec); msgpack::unpacked msg; msgpack::unpack(&amp;msg, buffer.data(), buffer.size()); msgpack::object obj = msg.get(); std::vector&amp;lt;my_class&amp;gt; my_class_vec_r; obj.convert(&amp;my_class_vec_r); return 0; } 这样我们就可以在网络通讯等地方可以使用msgpack来序列化我们的数据结构，完全可以做到安全高效，并且可以在接收方使用别的语言来处理结构做逻辑。完全是 多种语言-多种语言，现在支持的语言如下：
Ruby Perl Python C/C&#43;&#43; Java PHP JS OC C# Lua Scala D Haskell Erlang Ocaml Smallalk GO LabVIEW
完全够我们使用了，当然了，如果没有你要的语言，建议看源代码模仿一个。
关于性能测试结果可以查看：linux使用msgpack及测试 
</content>
    </entry>
    
     <entry>
        <title>分享自定义静态断言代码</title>
        <url>https://cppfans.org/1408.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>ensure</tag><tag>代码分享</tag><tag>自定义异常</tag><tag>静态断言</tag>
        </tags>
        <content type="html"> 本文代码来自于QQ群中nous大神，类似于static assert，不过断言异常内容可以自定义。
代码分为boost版本和标准版本，使用ENSURE_HAS_BOOST 宏来区分。
代码：
// // ensure.hpp // // Copyright (c) Nous Xiong. // // Macro ENSURE impl. // #ifndef ENSURE_HPP #define ENSURE_HPP #ifdef ENSURE_HAS_BOOST #include &amp;lt;boost/exception/all&amp;gt; #include &amp;lt;boost/thread/tss.hpp&amp;gt; #include &amp;lt;boost/preprocessor/seq/for_each.hpp&amp;gt; #include &amp;lt;boost/integer.hpp&amp;gt; #include &amp;lt;stdexcept&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;iostream&amp;gt; namespace un { /// 运行时刻信息 typedef boost::error_info&amp;lt;struct tag_runtime, std::string&amp;gt; errinfo_runtime_t; /// 专用于ensure的异常信息 typedef boost::error_info&amp;lt;struct tag_ensure, std::string&amp;gt; errinfo_ensure_t; /// 异常基类 class exception : public virtual std::exception , public virtual boost::exception { }; class ensure { public: ensure() : current_function_(0) , file_(0) , line_(-1) , msg_(0) { } ~ensure() { } public: ensure&amp; set_context(char const* expr, char const* current_function, char const* file, int line) { msg_ = 0; err_.str(&#34;&#34;); err_ &amp;lt;&amp;lt; &#34;Ensure failed, expression: &#39;&#34; &amp;lt;&amp;lt; expr &amp;lt;&amp;lt; &#34;&#39;, values: &#34;; current_function_ = current_function; file_ = file; line_ = line; // 这里你可以将std::cerr替换为你自己项目的日志系统 std::cerr &amp;lt;&amp;lt; &#34;Ensure failed point: [&#34; &amp;lt;&amp;lt; file_ &amp;lt;&amp;lt; &#34;]=[&#34; &amp;lt;&amp;lt; line_ &amp;lt;&amp;lt; &#34;]&#34; &amp;lt;&amp;lt; std::endl; return *this; } ensure&amp; set_current_val(boost::int8_t src, char const* name) { boost::int32_t tmp = (boost::int32_t)src; return set_val(tmp, name); } ensure&amp; set_current_val(bool src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(boost::int16_t src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(boost::uint16_t src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(boost::int32_t src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(boost::uint32_t src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(boost::int64_t src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(boost::uint64_t src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(std::string const&amp; src, char const* name) { err_ &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &#34; = &#34; &amp;lt;&amp;lt; src &amp;lt;&amp;lt; &#34;, size: &#34; &amp;lt;&amp;lt; src.size() &amp;lt;&amp;lt; &#34;; &#34;; return *this; } // 你可以加入任何你项目需要的数据类型 // 例如： //ensure&amp; set_current_val(my_data const&amp; src, char const* name) //{ // err_ &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &#34; = &#34; &amp;lt;&amp;lt; src.get_xxx() &amp;lt;&amp;lt; &#34;; &#34;; // return *this; //} /// 用户可添加的消息 ensure&amp; set_current_val(char const* msg, char const*) { msg_ = msg; return *this; } /// 抛出异常 template &amp;lt;typename ExceptT&amp;gt; ensure&amp; set_current_val(ExceptT const&amp; ex, char const*) { if (msg_) { ex &amp;lt;&amp;lt; errinfo_runtime_t(msg_); } ex &amp;lt;&amp;lt; errinfo_ensure_t(err_.str()); boost::exception_detail::throw_exception_(ex, current_function_, file_, line_); return *this; } static ensure&amp; get_ensure() { // 为了多线程下方便的使用ensure，这里使用了线程本地存储， // 如果是单线程程序，这里可以直接换为static ensure e; static boost::thread_specific_ptr&amp;lt;ensure&amp;gt; this_ens; ensure* ret = this_ens.get(); if (!ret) { this_ens.reset(new ensure); ret = this_ens.get(); } return *ret; } private: template &amp;lt;typename T&amp;gt; ensure&amp; set_val(T const t, char const* name) { err_ &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &#34; = &#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &#34;; &#34;; return *this; } private: std::stringstream err_; char const* current_function_; char const* file_; int line_; char const* msg_; }; } #define ENSURE_OP_IMPL(e, elem) e.set_current_val((elem), #elem); // 必须要定义这个宏，不然#elem无法正确的显示变量的字符串形式 #define ENSURE_OP(COLA_ENS, e, elem) ENSURE_OP_IMPL(e, elem) #define ENSURE(expr, args) \ if( (expr) ) ; \ else \ { \ un::ensure&amp; e = un::ensure::get_ensure(); \ e.set_context(#expr, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__); \ BOOST_PP_SEQ_FOR_EACH(ENSURE_OP, e, args); \ } #else #include &amp;lt;stdexcept&amp;gt; #include &amp;lt;sstream&amp;gt; #include &amp;lt;iostream&amp;gt; namespace un { class ensure { public: ensure() : ENSURE_A(*this) , ENSURE_B(*this) , file_(0) , line_(-1) , msg_(0) { } ~ensure() { } ensure&amp; ENSURE_A; ensure&amp; ENSURE_B; public: ensure&amp; set_context(char const* expr, char const* file, int line) { msg_ = 0; err_.str(&#34;&#34;); err_ &amp;lt;&amp;lt; &#34;Ensure failed, expression: &#39;&#34; &amp;lt;&amp;lt; expr &amp;lt;&amp;lt; &#34;&#39;, values: &#34;; file_ = file; line_ = line; // 这里你可以将std::cerr替换为你自己项目的日志系统 std::cerr &amp;lt;&amp;lt; &#34;Ensure failed point: [&#34; &amp;lt;&amp;lt; file_ &amp;lt;&amp;lt; &#34;]=[&#34; &amp;lt;&amp;lt; line_ &amp;lt;&amp;lt; &#34;]&#34; &amp;lt;&amp;lt; std::endl; return *this; } ensure&amp; set_current_val(char src, char const* name) { int tmp = (int)src; return set_val(tmp, name); } ensure&amp; set_current_val(bool src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(short src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(int src, char const* name) { return set_val(src, name); } ensure&amp; set_current_val(std::string const&amp; src, char const* name) { err_ &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &#34; = &#34; &amp;lt;&amp;lt; src &amp;lt;&amp;lt; &#34;, size: &#34; &amp;lt;&amp;lt; src.size() &amp;lt;&amp;lt; &#34;; &#34;; return *this; } // 你可以加入任何你项目需要的数据类型 // 例如： //ensure&amp; set_current_val(my_data const&amp; src, char const* name) //{ // err_ &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &#34; = &#34; &amp;lt;&amp;lt; src.get_xxx() &amp;lt;&amp;lt; &#34;; &#34;; // return *this; //} /// 用户可添加的消息 ensure&amp; set_current_val(char const* msg, char const*) { msg_ = msg; return *this; } /// 抛出异常 template &amp;lt;typename ExceptT&amp;gt; ensure&amp; set_current_val(ExceptT const&amp; ex, char const*) { if (msg_) { err_ &amp;lt;&amp;lt; &#34;user msg = &#34; &amp;lt;&amp;lt; msg_; } ex.set_error(err_.str()); // 需要用户实现这个方法 throw ex; return *this; } static ensure&amp; get_ensure() { // 仅仅单线程 static ensure ret; return ret; } private: template &amp;lt;typename T&amp;gt; ensure&amp; set_val(T const t, char const* name) { err_ &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &#34; = &#34; &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &#34;; &#34;; return *this; } private: std::stringstream err_; char const* file_; int line_; char const* msg_; }; } #define ENSURE_A(x) ENSURE_OP(x, B) #define ENSURE_B(x) ENSURE_OP(x, A) #define ENSURE_OP(x, next) \ ENSURE_A.set_current_val((x), #x).ENSURE_##next #define ENSURE(expr) \ if( (expr) ) ; \ else un::ensure::get_ensure().set_context(#expr,__FILE__,__LINE__).ENSURE_A #endif #endif /* COLA_ENSURE_HPP */ 测试代码：
// ensure.cpp : Defines the entry point for the console application. // #include &#34;ensure.hpp&#34; #ifdef ENSURE_HAS_BOOST class my_except : public virtual un::exception {}; int main(int argc, char *argv[]) { try { boost::int32_t i = 0; std::string str(&#34;test str&#34;); ENSURE(i == 0 &amp;&amp; str.empty(), (i)(str)(&#34;Test Ensure Msg&#34;)(my_except())); std::cout &amp;lt;&amp;lt; &#34;Shouldn&#39;t be here.&#34; &amp;lt;&amp;lt; std::endl; } catch (my_except&amp; ex) { std::cerr &amp;lt;&amp;lt; boost::diagnostic_information(ex) &amp;lt;&amp;lt; std::endl; } return 0; } #else class my_except : public virtual std::exception { public: void set_error(std::string const&amp; err) const { err_ = err; } virtual char const* what() const throw() { return err_.c_str(); } private: mutable std::string err_; }; int main(int argc, char *argv[]) { try { int i = 0; std::string str(&#34;test str&#34;); ENSURE(i == 0 &amp;&amp; str.empty())(i)(str)(&#34;Test Ensure Msg&#34;)(my_except()); std::cout &amp;lt;&amp;lt; &#34;Shouldn&#39;t be here.&#34; &amp;lt;&amp;lt; std::endl; } catch (my_except&amp; ex) { std::cerr &amp;lt;&amp;lt; ex.what() &amp;lt;&amp;lt; std::endl; } system(&#34;pause&#34;); return 0; } #endif ensure下载地址：
yunfile网盘百度网盘千军万马网盘Box网盘  </content>
    </entry>
    
     <entry>
        <title>赏析某程序员寒冬自助暖手程序</title>
        <url>https://cppfans.org/1405.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>屌丝</tag><tag>程序员</tag><tag>自助程序</tag><tag>趣味代码</tag>
        </tags>
        <content type="html"> 群中发了一个精辟的代码段，说是OSChina上某屌丝程序员抱怨没有妹子，没有电暖宝，没有热水，从而苦于寒冬手冷无法写代码，于是自己写了一段程序让CPU高速运转，风扇散热。
#include &amp;lt;process.h&amp;gt; #include &amp;lt;windows.h&amp;gt; double pi = 3.14; void handwarmer(void *p) { while (1) { //非线程同步。 pi *= pi; if (pi &amp;gt; 1024*1024*1024) pi = 3.14; } } int main() { SYSTEM_INFO siSysInfo; GetSystemInfo(&amp;siSysInfo); //n核 2n线程一样hold住 for (int i=0; i&amp;lt; (int)siSysInfo.dwNumberOfProcessors*2; &#43;&#43;i) _beginthread(handwarmer, 0, 0); system(&#34;pause&#34;); return 0; }; 这段代码的逻辑我就不用多讲了，相信大家都看的懂，，创建2*cpu核数个线程，来处理一个很多次的循环，结果我也就不贴那张图了，CPU使用率直线上升，果然可以暖手了。
coder的力量是无穷的，各位媛猿们共勉吧。
</content>
    </entry>
    
     <entry>
        <title>浅析国内某种端游服务器架构</title>
        <url>https://cppfans.org/1404.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>Server</tag><tag>服务器</tag><tag>架构</tag><tag>游戏设计</tag><tag>网游服务器</tag>
        </tags>
        <content type="html"> 做服务器开发两年了，也没学到太多的东西，更多的应该是处理问题的思路。而思路决定你如何处理问题，我觉得这个很关键，比你噼里啪啦的打了一通代码要好一些。
现在逐渐从游戏服务器的逻辑层转到了稍微深层次一点的内容了，比如服务器架构，服务器AOI，网络底层，一些库等等，所以也慢慢的与大家分享交流下心得，免得闭门造车。
国内的游戏大多架构都很适合国情，走马观花地看了一些服务器的架构，觉得设计都比较近似，今天我们先说一种服务器的架构，如下图：(点击查看大图，或者下载到本地查看)

一种常见的服务器架构  上图是一组服务器的分布图， 这种服务器架构比较适合多个单独服务器(国家/阵营)。它提供了跨服，中转，单服动态均衡等比较常见的功能。
1.CenterServer负责整个服务器总控，提供服务器之间跳转，RMB到游戏币等功能
2.LoginServer提供登陆服务
3.GateServer提供客户端和服务器之间的消息转发
4.GameServer提供游戏内逻辑处理，场景，怪物，NPC等一系列功能
5.CharServer类似于与GameServer，不过逻辑单一，只处理获得角色，选取角色，进入不同的游戏世界GameServer
6.DBServer提供数据存储服务
7.Platform提供充值、账号、web、服务器监控、充值等服务
8.PF_DBServer提供Platform的数据存储服务
这种服务器架构好处就是跳转方便，多个GateServer均衡了消息转发的压力，并且CenterServer可以整体控制。缺点是每个GameServer是单独的，GameServer之间不能做到均衡，如果是多个国家/势力/阵营，那正好一个服务器一个国家/势力/阵营，但是如果是PVE休闲类的游戏，其实没有玩家的阵营之分的话，如果玩家数量较多，就会导致某个服务器压力过大，解决办法可以使用BW的服务器之间动态均衡负载的办法。
</content>
    </entry>
    
     <entry>
        <title>Ubuntu下如何安装boost？</title>
        <url>https://cppfans.org/1402.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>boost</tag><tag>Linux</tag><tag>Ubuntu</tag><tag>编译</tag>
        </tags>
        <content type="html"> 最近有开始折腾Linux了，没办法，太多的东西都是在Linux下很高效并且不提供VS的工程文件，所以还是学学Linux吧，免得以后被人说做服务器竟然不懂Linux。
 这篇文章的前提是系统是Ubuntu12.04LTS，系统完全更新过，并且一系列编译工具都已经安装过了，如果你还不清楚如何安装开发工具，那请你搜索一下相关文章，搞明白后再来看这个，谢谢。
 首先我们需要的最新版本的boost库的源码包，可以通过www.boost.org来下载，现在的最新版本是1.52.0，有兴趣的朋友可以看下这个版本的changelog。
解压(解压这个问题很多人都会用命令解压，不过我觉得既然右键可以直接解压，为何要用命令呢，你要是觉得命令行比较高端或者专业，那请你自己去查找)后放在 文件系统/usr/share目录下，文件夹名为boost_1_52_0，里面有什么大家就自己去看吧。
1.使用bootstrap.bat来编译生成b2和bjam可执行文件。因为默认的boostrap.bat中的工具是msvc，而ubuntu不可能使用msvc的，所以我们修改boostrap.bat文件如下：
::修改前 call .\build.bat %* &amp;gt; ..\..\..\..\bootstrap.log ::修改后 call .\build.bat %* gcc &amp;gt; ..\..\..\..\bootstrap.log ::修改前 set toolset=msvc ::修改后 set toolset=gcc 这样我们就设置它是使用gcc编译。
2.点击bootstrap.sh会在终端编译生成b2和bjam可执行文件.
3.开始编译boost库。从终端进入boost库的目录 cd /usr/share/boost_1_52_0/ ，然后输入sudo ./bjam tolset=gcc &amp;ndash;layout=tagged &amp;ndash;build-type=complete stage
注意：此处使用的是完全编译，因为省得以后还得编译麻烦，如果你不需要某些库，直接写&amp;ndash;without-XXX(库名)。此处为了保证权限没有问题，所以使用了sudo命令，如果你的当前用户是roo权限t，则不需要加sudo
这样生成的.a库文件就会在boost_1_52_0文件夹下的stage/lib目录下了。编译时间比较长，大家耐心等待。
4.关联头文件目录和库文件目录分别到/usr/include和/usr/lib。
#关联头文件 sudo ln /s /usr/share/boost_1_52_0/boost /usr/include/boost #关联lib文件,需切换到boost_1_52_0/stage目录下，执行如下命令 #注意:linux下的lib文件是以lib开头 .a后缀结束的文件 sudo ind $PWD/lib/*.* -type f -exec ln -s {} /usr/lib/ \; 这样整个编译过程就结束了，剩下就是你自己如何使用了。
&amp;nbsp;
如果你不想全部安装，或者只是想要.a的库文件，那我推荐如下的安装代码。
./b2 toolset=gcc cxxflags=-fPIC --layout=versioned link=static variant=debug,release threading=multi runtime-link=shared --without-python --without-mpi --without-wave --without-graph --without-math --without-serialization stage 这个编译生成的是.so文件，而且没有那些暂时不需要的库文件，比较精简，我个人是没有试过&amp;ndash;build-type=mininal的方式。
</content>
    </entry>
    
     <entry>
        <title>观西乔《神秘的程序员41期-条件反射》有感</title>
        <url>https://cppfans.org/1399.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>制度</tag><tag>漫画</tag><tag>神秘的程序员</tag><tag>程序员</tag><tag>责任</tag>
        </tags>
        <content type="html">  前一段时间看到新工具对西乔的专访，突然想起来她就是那个《神秘的程序员》系列漫画的作者，她还有一个站点是全球设计精享站designlol.net，里面分享的设计素材都很不错，不过我是没天分看设计了。
看到条件反射这篇漫画时，第一反应是这不就是我们现在的状态吗么，难道有人把我们的事迹作为素材发给西乔了？
的确程序员的杀手锏是&amp;rdquo;能重现吗？不能重现这边没法查&amp;rdquo;；推脱的理由无外乎两种&amp;rdquo;1.这段代码看着很眼生，肯定不是我写的，就算是我的账号提交的，那也不是我写的；2.我不可能把每个问题都测到，我还有一堆的事儿要忙呢&amp;rdquo;。
这幅漫画都体现出来了，我经常这样对付我们的策划，看来程序员都一样。
不过再回想起来，这些其实都不能称作笑点，这关乎到很多事情，一些误解可能在里面。
1.杀手锏。这其实是一个解决问题的方法，因为程序员思维相对比较定势，当别人向我们(这里的我们是指猿媛们，以下不再重复说明)提交一个问题时，我们可能第一反应就是自己写的对应的那段代码，再一回想还是没错啊，不可能啊，故需要重现方便调试问题。
2.推脱的问题。这点我承认我们做的很不好，有错就要认，挨打要立正，该问责就问责，这没有什么说的，杀人偿命天经地义，虽然不至于这么夸张，但是如果是温州动车事件呢，特别是像我等无证码农，搞不好要进去的；而程序开发人员测试问题不全面这是通病，因为不可能全面，我国的大多数软件开发公司的流程都是混乱的，糟糕的设计文档、含糊的表述、项目进度管理松散、开发时间由需求紧急程度而定(并非需求难度)，统统的问题都让开发人员要卯足了劲去往前赶，并没有多余的时间来详细测试，大多说都是跑一次没问题就OK了，再说了，我们还有两道坎呢，一个是测试，一个是产品，所以如果出问题测试的责任相对较大一些(并没有黑测试朋友的意思啊)。
3.漫画中间那段兼容性和环境的问题。这个也很好理解，总要找个理由推脱责任，所以各种借口都会被拿出来说的。我觉得只要用户是在你指定的平台上运行，那么有任何兼容性的问题都应该是开发人员的失误，因为我在你指定的环境下运行出了问题，这下跑不掉了吧。所以兼容性问题是一个很重要的问题，多想想多看看多为用户着想的设计大体上都是没问题的。
总结： 这篇文章也就是随手一写，并没有指责程序员的任何意思，只是觉得责任要担当，问题要尽快处理，多余的争吵是没有任何意义的。《神秘的程序员》系列漫画很有意思，很贴近我们的日常开发工作。曾将还扒拉过西乔网站的几个图片来用呢，嚯嚯……
</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; 0x之auto - 从初始化中推断数据类型</title>
        <url>https://cppfans.org/1398.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>0x标准</tag><tag>auto</tag><tag>C&#43;&#43;</tag><tag>自动类型推演</tag>
        </tags>
        <content type="html">  引言 曾几何时，C&#43;&#43; 0x出现在我们眼前，我们还在苦逼的用老的规则写代码，因为我们是码畜，我们的顶头上司要求我们必须用土的掉渣的VS2005来写代码，并且用各种存在很棘手问题的库，还有我们的用户都用的XP，新的库包含一些其他的内容，用户根本都没法用，所以我们依然苦逼着。不过曙光就在眼前了，虽然没看到曙光中的女神，但是先感谢下那帮为C&#43;&#43;贡献终生的老头子们。
auto关键字的区分 当年我们学编程的时候记得还有一个auto关键字，是C&#43;&#43; 98标准的，是用来表明具有自动存储期的局部变量，不过这个自动存储期我是木有明白，这个关键字被打入冷宫了。现在那帮old men又重新启用了它，就像武则天和甄嬛一样(我又狗血了，为什么加一个又呢？)。
现在的auto关键字是用来做自动类型推演的，有点类似于类型萃取，不过比类型萃取更简单更好用。
auto详细 我们在用模板或者容器的时候经常都会写一大堆内容来将函数返回值赋值给某个相应的对象，然后用这个对象做一些操作，其实我们根本关心这个对象是什么类型，我们只是因为不那样写编译器不给通过而已，我们都是被逼的。而现在auto就可以帮我们解决这个烦恼，前面说过了，它的特点是自动类型推演，所以都交给它了。
例如，我们有如下的代码：
#include &amp;lt;map&amp;gt; #include &amp;lt;iostream&amp;gt; int _tmain(int argc, _TCHAR* argv[]) { typedef std::map&amp;lt;int, int&amp;gt; intMap; typedef intMap::iterator intMapIter; intMap myIntMap; for (intMapIter iter = myIntMap.begin(); iter != myIntMap.end(); &#43;&#43;iter) { std::cout &amp;lt;&amp;lt; &#34;First: &#34; &amp;lt;&amp;lt; iter-&amp;gt;first &amp;lt;&amp;lt; &#34; Second: &#34; &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; std::endl; } system(&#34;pause&#34;); return 0; } 我们写了这么一坨代码，才实现了一个打印的功能，现在我们可以很简单的写了，连typdef都不用，（我认为typedef大多数时候的作用是为了迭代器，而不容器）。
简单的写法如下：
#include &amp;lt;map&amp;gt; #include &amp;lt;iostream&amp;gt; int _tmain(int argc, _TCHAR* argv[]) { std::map&amp;lt;int, int&amp;gt; myIntMap; for (auto iter = myIntMap.begin(); iter != myIntMap.end(); &#43;&#43;iter) { std::cout &amp;lt;&amp;lt; &#34;First: &#34; &amp;lt;&amp;lt; iter-&amp;gt;first &amp;lt;&amp;lt; &#34; Second: &#34; &amp;lt;&amp;lt; iter-&amp;gt;second &amp;lt;&amp;lt; std::endl; } system(&#34;pause&#34;); return 0; } 明显我们的代码量减少了，我们不是按照行数给钱的，所以不用担心代码减少了。
当然了它不仅仅使用在容器上，再看看下面的例子：
#include &amp;lt;string&amp;gt; #include &amp;lt;iostream&amp;gt; std::string&amp; GetString(std::string&amp;&amp; myString) { return myString; } int _tmain(int argc, _TCHAR* argv[]) { auto tempString = GetString(std::string(&#34;Hello World&#34;)); std::cout &amp;lt;&amp;lt; tempString &amp;lt;&amp;lt; std::endl; system(&#34;pause&#34;); return 0; } auto关键字的好处是解决了长期以来令我们头疼并且给我们带来麻烦的返回值数据类型问题。比如在一些复杂的模板函数里，你可以不用纠结这里到底用什么返回值的数据类型，大大的降低了复杂的数据类型的判断难度和代码量。
所以有高端并且简单的东西为何不用呢，与己方便与人方便嘛。
</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43; 0x之右值引用</title>
        <url>https://cppfans.org/1397.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>0x标准</tag><tag>C&#43;&#43;</tag><tag>右值引用</tag><tag>左值引用</tag>
        </tags>
        <content type="html"> C&#43;&#43; 0x标准出来有一段时间了，一直没时间看，导致最近看一些代码完全不明白是什么意思了，只好硬着头皮来看了。
这次先说一个简单的，右值引用。
关于引用，大家都很清楚了，只会做一标识，而不会拷贝对象，例如：int a = 0; int&amp;amp; b = a; 这个就是传统的引用，如今也称为左值引用，一般我们将引用用在函数返回值和参数传递上。现在0x标准出来了一个右值引用。为了区别左值引用，就变成右值引用了，用&amp;rdquo;&amp;amp;&amp;amp;&amp;ldquo;来表示。
左值引用和右值引用最大的却别是：右值引用可以绑定到一个临时的对象(右值)上，而左值引用不行。
int a = 0; int&amp; nLvRef = a; // 左值引用 int&amp;&amp; nRvRef = int(); // 右值引用 上面的是例子是一个左值引用和右值引用的例子。再看下面的例子：
int&amp; nLvRef = int(); // 左值引用, VS报错:非常量引用的初始值必须是左值 error C2440: “初始化”: 无法从“int”转换为“int &amp;” int&amp;&amp; nRvRef = int(); // 右值引用 从而可见，我们把一个临时对象(右值)绑定大了一个右值引用上，而左值引用却不可以这样绑定。
右值引用可以绑定一个临时(匿名)的对象，而临时的对象没有必要保存下来，进行操作的时候我么你可以&amp;rdquo;移动(Move)&amp;ldquo;它，而不是拷贝一个副本下来，这样就可以减少拷贝副本所带来的开销。
例如我们有下面的例子：
void swap(int&amp; a , int&amp; b) { int temp = a; a = b; b = temp; } int _tmain(int argc, _TCHAR* argv[]) { int a = 1; int b = 2; swap(a, b); std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &#34; &#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl; system(&#34;pause&#34;); return 0; } 结果我们都很清楚，a和b的值交换了，但是这里大家注意到，用一个临时对象来做中间变量，我们做了很多次的对象拷贝。
下来我们使用右值引用中移动的思想来改写这个swap函数，如下：
void swap(int&amp; a , int&amp; b) { int temp = std::move(a); a = std::move(b); b = std::move(temp); } int _tmain(int argc, _TCHAR* argv[]) { int a = 1; int b = 2; swap(a, b); std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &#34; &#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl; system(&#34;pause&#34;); return 0; } 这里你可能没看到右值引用操作符，但是却用了一个std::move()，这个是VS标准库中自带的一个移动函数。
我们来用右值引用模拟一下这个标准函数_(稍微吐槽下，MS慢慢也接受了boost等公众认可的东西了，不搞特殊化了，以MS当年的性格，绝对要单独搞一个另外名字的函数)_。
template&amp;lt;typename T&amp;gt; T&amp;&amp; move(T&amp;&amp; a) { return a; } template&amp;lt;typename T&amp;gt; void swap(T&amp; a , T&amp; b) { int temp = move(a); // a被移动到temp，a被清空 a = move(b); // b被移动到a，b被清空 b = move(temp); // temp被移动到a，temp被清空 } int _tmain(int argc, _TCHAR* argv[]) { int a = 1; int b = 2; swap(a, b); std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &#34; &#34; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; std::endl; system(&#34;pause&#34;); return 0; } 注意:这里是移动，并没有做拷贝，只是将对象移动了一下而已，你可以认为是同一个你还了不同编号的座位。
C&#43;&#43;0x中的右值引用算是将引用这块的东西补全了，虽然左值引用也很好用，但是大家对他的效率以及临时对象的处理上不是很满意，而右值引用完美的解决了这个问题。
不过现在大家用的VS编辑器各不一致，想要用右值引用需要VS2010(包含)以上的版本，建议还是用VS2012吧，2010的支持不全面。GCC最先的4.7.3已经全面支持C&#43;&#43; 0x标准了。还是喜欢GCC的果断，而不像VS一样拖泥带水，今天支持一点，sp1再支持一点，纠结。
好了，这个东西这么好用，有必要的话建议大家升级下项目。
</content>
    </entry>
    
     <entry>
        <title>Lib和Dll的那点事</title>
        <url>https://cppfans.org/1394.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>Dll</tag><tag>Dynamic Lib</tag><tag>Lib</tag><tag>runtime</tag><tag>Static Lib</tag><tag>链接库</tag>
        </tags>
        <content type="html">  搞程序开发的朋友应该对Lib和Dll很熟悉，对于这两个东西，可谓是几家欢喜几家忧，喜欢的人觉得它可以封装代码，避免别人剽窃，不喜欢的人觉得它很麻烦，干嘛不直接用源文件。而特别是新手对于Lib和Dll的关系和使用完全搞不清楚。
Lib称为静态链接库(static link library)，是在编译的链接期间使用的，他里面其实就是源文件的函数实现。
Dll成为动态链接库(Dynamic link library)，是在程序运行时动态调用的，runtime时使用，它里面包含了源文件的函数实现、DllMain入口函数和.def文件。
先说说Lib库吧，相对来说大家对它比dll熟悉一些。
Lib库 Lib库有两种，一种就是常见的普通Lib(static Lib)，还有一种大家经常下载的开源代码编译后，会产生Lib和dll，其中Lib只是Dll的附带品，是DLL导出的函数列表文件而已，暂且称之为Dynamic Lib。
两者都是二进制文件，两者都是在链接是调用的，使用static lib的exe可直接运行，使用dynamic lib的exe需要对应的dll才能运行。下来我们来看如何产生并使用一个static lib文件。
这里假设我们的工具是VS2005(包含)以上的版本，其他的工具都是大同小异的，就不做介绍了。
1.建立win32控制台工程
2.在应用程序设置的步骤，选择&amp;rdquo;静态库 static Library&amp;rdquo;
3.完成即可_ (这里只是针对最简单的Dll，Win32 Application的方式稍有不同)_
这样一个静态Lib库的工程就建好了。代码如下：
////////////////////////////////////////////////////////////////////////// // Function.h ////////////////////////////////////////////////////////////////////////// void Print(); ////////////////////////////////////////////////////////////////////////// // Function.cpp ////////////////////////////////////////////////////////////////////////// #include &#34;Function.h&#34; void Print() { std::cout &amp;lt;&amp;lt; &#34;Hello world!&#34; &amp;lt;&amp;lt; std::endl; } 编译会生成一个以工程名作为名称的Lib文件。
在你的项目工程属性中包含这个Lib文件的头文件目录和Lib文件目录。
头目录包含方法：项目属性(Alt &#43; F7) -&amp;gt; 配置属性 -&amp;gt; C/C&#43;&#43; -&amp;gt; 常规 -&amp;gt; 附加包含目录，里面包含你的Lib库的头文件，你可以使用绝对路径，也可以使用VS中宏表示的相对路径，建议使用相对路径。
Lib文件包含方法：项目属性(Alt &#43; F7) -&amp;gt; 配置属性 -&amp;gt; 链接器 -&amp;gt; 常规 -&amp;gt; 附加库目录，在这里面填写你Lib文件的路径。项目属性(Alt &#43; F7) -&amp;gt; 配置属性 -&amp;gt; 链接器 -&amp;gt; 常规 -&amp;gt; 输入，在这里面填写你Lib文件的名称，例如： Function.lib
这样你在你的代码里就可以这样使用了：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &#34;Function.h&#34; int _tmain(int argc, _TCHAR* argv[]) { Print(); system(&#34;pause&#34;); return 0; } 这样就是一个完整生成并使用Lib库的例子。
当然了，你还可以使用#pragma comment(Lib, &amp;ldquo;LibPath&amp;rdquo;)的方法来调用Lib文件。
==============================================================
Dynamic Lib的调用方法与Static lib完全一致，唯一的区别就是使用Dynamic Lib编译出来的程序，运行时需要其对应的Dll文件。前面我们已经说过了。
DLL 下来我们好好谈谈Dll的问题，相对于Lib来说，Dll使用的频率应该是非常高的了，因为你的程序运行，系统运行等等都靠它，MS也是因为这个才导致操作系统封装的越来越好了。
Dll其实和Exe是几乎完全一样的，唯一的不一样就是Exe的入口函数式WinMain函数（console程序是main函数），而Dll是DllMain函数，其他完全是一样的。所以有人也戏称Dll是不能自己运行的Exe。
Dll创建的过程也比较简单，唯一麻烦的就是需要定义导出函数接口。
创建Dll工程过程很简单，建立win32控制台工程,在应用程序设置的步骤，选择&amp;rdquo;动态库 Dynamic Library&amp;rdquo;，完成即可。(这里只是针对最简单的Dll，Win32 Application的方式稍有不同)
定义导出函数接口有两种方式：
1.使用__declspec宏
// dllmain.cpp : 定义 DLL 应用程序的入口点。 #include &#34;stdafx.h&#34; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } ////////////////////////////////////////////////////////////////////////// // Fucntion.h ////////////////////////////////////////////////////////////////////////// extern &#34;C&#34; __declspec(dllexport) void Print(void); ////////////////////////////////////////////////////////////////////////// // Function.cpp ////////////////////////////////////////////////////////////////////////// #include &#34;Function.h&#34; void Print(void) { std::cout &amp;lt;&amp;lt; &#34;[Dll] Hello world!&#34; &amp;lt;&amp;lt; std::endl; } 这里假设我们的工程名叫Function，那么 编译后会生成一个Function.dll和一个Function.lib（Dynamic lib），Dynamic lib前面已经说过，此处不再赘述了。
Function.h头文件中的
extern &#34;C&#34; __declspec(dllexport) void Print(void); 我们只需要清楚其中函数的名称，返回值，参数就可以了。
extern &amp;ldquo;C&amp;rdquo;表示我们要按照C语言的方式编译该函数，防止在C&#43;&#43;工程中编译出现函数名错误，因为C&#43;&#43;中有函数重载，所以函数名编译后可能会出现Print@1的形式；而且这样也可以让C调用C&#43;&#43;的动态链接库；__declspec(dllexport)表示下来的函数是dll的导出函数接口。
2.使用def文件，类似于声明导出接口的方式，不过却不需要声明了，因为它专门定义了一个def文件来说明
// dllmain.cpp : 定义 DLL 应用程序的入口点。 #include &#34;stdafx.h&#34; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } ////////////////////////////////////////////////////////////////////////// // Fucntion.h ////////////////////////////////////////////////////////////////////////// void Print(void); ////////////////////////////////////////////////////////////////////////// // Function.cpp ////////////////////////////////////////////////////////////////////////// #include &#34;Function.h&#34; void Print(void) { std::cout &amp;lt;&amp;lt; &#34;[Dll] Hello world!&#34; &amp;lt;&amp;lt; std::endl; } ////////////////////////////////////////////////////////////////////////// // Fucntion.def ////////////////////////////////////////////////////////////////////////// EXPORTS Print 同样，类似于Static Lib的显式调用方法，dll也可以显式调用，前提是我们很清楚函数名、返回值、参数列表。
&amp;nbsp;
#include &amp;lt;stdlib.h&amp;gt; #include &#34;Function.h&#34; #include &amp;lt;windows.h&amp;gt; int _tmain(int argc, _TCHAR* argv[]) { HINSTANCE hInstance = LoadLibrary(&#34;Function.dll&#34;); typedef void(*_Print)(void); _Print printFunction; if (hInstance != NULL) { printFunction = (_Print)GetProcAddress(hInstance, &#34;Print&#34;); } printFunction(); FreeLibrary(hInstance); system(&#34;pause&#34;); return 0; } 当然了，有显式自然还有隐式调用了，这个时候Function.dll的伴生产物Function.lib就可以派上用场了，其使用方法和静态lib完全相同。
DLL调用的两种方法各有利弊：采用寻找DLL中函数地址的方法，优点是只要函数形参没变化，那么修改了函数实现也没关系，不需要重新编译Exe，只需要将新的DLL文件拷贝过来即可，大型项目上使用比较灵活；缺点是比较麻烦，需要定义实例，函数指针，加载DLL，释放DLL等过程。而采用Dynamic Lib的方法，优点是容易理解和接受(因为他跟静态库的调用方法类似)；缺点是修改了DLL工程的任何东西都需要使用最新的Dynamic Lib重新能编译Exe。
&amp;nbsp;
总结： DLL和Lib是各有千秋，使用的情况也是各不相同，不过最终还是需要大家在项目中实践到底哪种方法好，到底采用哪种类型的库，总之，一切都要按需求最优。
</content>
    </entry>
    
     <entry>
        <title>HTTP请求中GET和POST的分析</title>
        <url>https://cppfans.org/1391.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>GET</tag><tag>HTTP</tag><tag>POST</tag><tag>URL</tag><tag>分析</tag><tag>协议</tag><tag>请求</tag>
        </tags>
        <content type="html">  近期一位朋友想写iOS上的应用，打算从微博应用做起，第一步先做一个微博客户端出来，然后做一个手机微博应用出来，具体做什么还不甚清楚，其实是在尝试中。而我正好在用asio写网络库，于是主动提出了承担web服务器网络库的部分，也是为了给我自己封装的网络库中增加一个http模块。
http大家都不陌生，每天打开网页，地址栏前大多数显示的都是http，当然还有https等等，以前跟rangerlee讨论curl的时候有说过post和get，不是很清楚，查阅了众多文章和资料，有点小懂了。
统一资源定位符（URL，英语 Uniform / Universal Resource Locator 的缩写）也被称为网页地址，是因特网上标准的资源的地址（Address)。其实URL就是代表一个特定地址的因特网标准资源URI。http请求中的get post put delete就是对这个资源进行 查 增 改 删 ，有点类似于数据库中的四大操作。get和post最主要的区别是前者是查询，后者是修改，get类似于C&#43;&#43;中const函数，而post类似于set或者add函数。
原理： GET 根据HTTP标准，GET用于信息的获取，并且是安全和幂等的。
安全：GET操作用于获取信息/资源，并非修改信息/资源。主要表现在不能修改信息。
幂等：这是一个数学/计算机上的概念。对于单目运算来说，如果一次运算和多次运算的结果是一样的，则该运算是幂等的，例如：C&#43;&#43;中的abs(abs(a)) = abs(a)，所以abs函数运算就是幂等的；对于双目运算，两个相等的参与运算的值在运算之后的结果仍然等于这个值，则该运算是幂等的，例如：C&#43;&#43;中的max(a, a) = a，所以max函数的幂等的。
而GET是在同一个地址下获取到的资源是相同的，并且没有改变，所以GET是安全的、幂等的。
不过，有些特殊情况也会认为是幂等的。例如：新闻某门户网站的头条新闻，可能在不断的更新，用户可能在不同的时间看到的内容不尽相同，但是这也认为是幂等的，因为对用户来说，他们访问的资源是同一个地址的。
POST 根据HTTP标准，POST用于可能修改服务器资源的请求。并没有什么特殊规定。
例如：最常见的就是留言了，留言完之后页面会刷新，不管是整体刷新还是Ajax局部刷新，这时候用的请求就是POST。
&amp;nbsp;
表现形式： HTTP格式为：

[]
先是一个请求行(request line)，用来说明请求类型、请求地址、HTTP版本；然后是头部(headers)，用来说明服务器的一些附加信息；下来是一个空行(blank line)；再下来是数据主体(request-body)。
GET格式 GET / HTTP/1.1
Host: www.cppfans.org
Connection: keep-alive
Cache-Control: max-age=0
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.10 (KHTML, like Gecko) Chrome/23.0.1262.0 Safari/537.10 AlexaToolbar/alxg-3.1
Accept: text/html,application/xhtml&#43;xml,application/xml;q=0.9,*/*;q=0.8
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
&amp;nbsp;
POST格式 POST /api/posts/create.json HTTP/1.1
Host: duoshuo.com
Connection: keep-alive
Content-Length: 283
Origin: http://duoshuo.com
X-Requested-With: XMLHttpRequest
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.10 (KHTML, like Gecko) Chrome/23.0.1262.0 Safari/537.10 AlexaToolbar/alxg-3.1
Content-Type: application/x-www-form-urlencoded
Accept: */*
Referer: http://duoshuo.com/cors/index.html?xdm_e=http%3A%2F%2Fjkirin.com&amp;amp;xdm_c=default693&amp;amp;xdm_p=1
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8
Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3
以上数据是通过Chrome的元素审查中的Network抓取到的。
1.地址的区别 举个例子：
百度搜索的地址：
http://www.baidu.com/s?tn=monline_4_dg&amp;amp;ie=utf-8&amp;amp;bs=http&amp;amp;f=8&amp;amp;rsv_bp=1&amp;amp;wd=http&#43;get&#43;post&amp;amp;rsv_sug3=9&amp;amp;rsv_sug1=7&amp;amp;rsv_sug4=325&amp;amp;inputT=2533
Get请求会把数据附在URL之后，以?分割URL和传输数据，多个参数用&amp;amp;连接，上述URL地址可以堪为URL是http://www.baidu.com/s，后面的tn=monline_4_dg ie=utf-8 bs=http等都是参数。
遇到空格用&#43;替代，上述URL中的搜索词是http get post，而URL表现出来的是wd=http&#43;get&#43;post。
数字和字母原样不变。wd=http&#43;get&#43;post
中文和其他字符用Base64加密，例如有些URL表现为%D4%E3%A0%BD，其中%XX中XX表示该符号的16进制ANSII码。
POST请求：把修改的数据放置在是HTTP包的包体中进行发送。
Get请求的URL会在地址栏中显示出来，而Post只是修改，并不会改变URL。
2.传输数据的限制 HTTP协议对URL长度和传输的数据长度没有任何限制，不过在实际开发中会根据浏览器的限制条件做一些规定。
GET：根据浏览器和操作系统有一些限制。例如：IE(包含IE内核)浏览器的URL限制是2K&#43;35个字节长度，而其他浏览器理论没有限制，但却取决于操作系统支持的长度。
POST：理论没有传输数据的限制，但总不能提交一个过大的数据，这样会很慢，所以Web服务器一般都会做限制的。
3.安全性 POST的安全性高于GET，这里是指Security而不是Safe，因为Get的URL可以通过分析得出一些数据出来，还有Cookie和历史记录等等都会造成一些恶意攻击或破解。
&amp;nbsp;
好了，关于GET和POST就说这么多了，下来就是要写一个处理这些请求的http服务器了。有人会说为什么要自己写，而不是用Apache或者nginx等已经成熟的Web服务器？因为他们太复杂了，功能繁杂，而我却不需要这么多功能，所以我写一个简单实用的http server就可以了，不过可以借鉴成熟Web服务器的主要功能代码。敬请期待吧，估计测试和投入使用会时挺长时间的。
</content>
    </entry>
    
     <entry>
        <title>如何增加博客的订阅量？</title>
        <url>https://cppfans.org/1389.html</url>
        <categories>
          <category>Wordpress</category><category>技术文章</category>
        </categories>
        <tags>
          <tag>feed</tag><tag>feedburner</tag><tag>feedsky</tag><tag>提高订阅量</tag><tag>订阅</tag>
        </tags>
        <content type="html"> 订阅服务是如今各个网站都会增加的一个功能，他可以使读者第一时间获得订阅网站的新内容，同时好的订阅方式会让留住一大批读者和用户。国内主要提供订阅服务网站有那么几个，用的多的主要是FeedSky，下来应该是google的Feed burner和腾讯的QQ邮件订阅了，订阅服务现在免费提供了，那么能有多少用户订阅，各位站长就只好各凭本事了，下来我们来讨论下怎么样才能增加博客的订阅量。
第一位自然是高质量的文章了。好的文章可以让读者获得更多的知识或有更多的看点，网站带给读者好的内容，读者才能觉得有看头，自然会订阅该网站。
第二位是保持适当稳定的更新。只有网站在较短的时间内带给读者更多的内容，才能让读者保持一种新鲜感和索求欲望。试想一个博客长久不更新，没什么新内容，那么读者自然而然就少了，就算订阅了也不会去看了，同时新的读者也会越来越少。
第三.多提供在线阅读的订阅方式而不是离线的。如今，相信大多数人每天都会上网，不论是手机还是PC的方式，看看有趣的内容都会想着下次再看，提供一个在线的订阅方式可以让用户很方便阅读，离线的方式大多数更新较慢并且排版不好。
第四.提供多种订阅方式。例如google reader、抓虾、鲜果等等，多种阅读器让用户自行选择，给用户提供了更大的自由度，从而可以迎合更多人来订阅。因为很多用户都是因为阅读器的陌生而不订阅。
第五.让用户可以看到订阅的地方。很多优秀的网站可能因为早些年的一些习惯，feed标志比较小或者比较隐蔽，不容易发现，这样用户想订阅都找不到门路，这样就会丢失很大一部分订阅量。显眼、辨识度高的feed标志是很有用处的。
第六.教你的用户如何订阅。在你的订阅页面或者你额外说明的页面写清楚如何订阅网站内容，很多用户对于订阅还是很含糊的，不知道是干什么的。普及了订阅方式之后，大家如果喜欢就会持续订阅的。
&amp;nbsp;
暂时想到的就这么多了，其实总结来说主要是持续更新高质量的文章，让你的用户懂得订阅并且可以订阅，长久下来，订阅量想不上去都难。
最后，本博客求订阅求分享求推广，谢谢！
</content>
    </entry>
    
     <entry>
        <title>坚持写博客，即使你不擅长</title>
        <url>https://cppfans.org/1387.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>写作</tag><tag>博客</tag><tag>坚持</tag><tag>文章</tag>
        </tags>
        <content type="html"> 前几天看到了伯乐在线翻译的《开发者拒绝写技术博客的常见理由》，里面列举了一些开发者不愿意写博客的原因。
1.我不是这方面的专家，我写的东西不权威
2.我不擅长写作
3.如果我出错了，岂不是在整个互联网上丢人了
4.我不知道写哪个人群适合看的文章
这位叫Major Hayden的Linux工程师其实写的挺好的，总结的这几点都是很多人不愿意写博客的原因，这几点应该不只是开发者，而是所有想写又不能写博客人群的共同点。
PS:这位Linux工程师的文笔完全看不出来是个搞Linux的，倒像是专门搞教学或者演讲的，在我印象中，Linux程序员应该是坐在小黑屋完全看不清楚脸，只见其看着散发着黑色光芒的终端两眼发亮的人。哈哈……心里YY一下。
还记得我当初刚开始写博客的时候，也是不知道写些什么，后来慢慢在工作中获得了一些知识，就写出来给大家看。而且写之前都是各方面查资料，唯恐哪里没写到位或者写错。现在想想，觉得没有必要，一个完整的叙述固然是最好不过了，但是没必要强制自己在很短的一段时间内吸收那么多你可能不用到甚至写完本文就忘了的知识，因为你没学到什么知识，只是粗略的知道了一些，并且可能会给看这个文章的人带来一些误导，因为你自己就是临时抱佛脚的。所以没必要写那么多，写你知道的内容，可以略微的扩展一下，顺道让你自己也加深了学习。权威不权威并不重要，写的内容只是给适合看它的朋友写的，并不是给所有人写的，所以众口难调是肯定的。我写的IOCP的那三篇文章，虽然很简单，但是却一直是我博客最多访问的页面。
做任何事，没有人生来就擅长，都是在后天不断的学习和积累中锻炼出来的，写作并没有多高深，跟说话差不多，有嘴就能说，为何却有手不能写呢？其实只是心里作用，鲁迅先生都说过，世上本无路，走的人多了变成了路。
不要怕出错，根据那个XX定理，越怕出错，越容易出错，这是一种心理暗示，就是潜意识在操作你了，正所谓：他强任他强，清风拂山岗，他横由他横，明月照大江。出错并不可可怕，可怕的是出错了还不改，当你出错了，有两种方式来处理，一种就是说服别人，一种就是顺从别人，这里的“说服”和“顺从”是指你像正确的一方靠拢，这样通过多交流多沟通，不仅交到了朋友还增长了知识，何乐而不为呢？
最后的不清楚为哪类人写文章的问题，我觉得是最好解决的，你只是一个人，你的能力有限，知识面也有限，你只能写出来自己知道的，自己擅长的东西，自然会有跟你志同道合的一群人来看，不必勉强给哪一类人看，这样大家都费劲。
总结：写博客其实是一种习惯，一种表达自我的方式，当你想写的时候就将它写出来，分享给大家。坚持写博客，到最后你发现你会有一笔意外的财富，你的博客会给你沉淀写来很多东西的。
</content>
    </entry>
    
     <entry>
        <title>分享仿异次元百度分享工具条</title>
        <url>https://cppfans.org/1385.html</url>
        <categories>
          <category>Wordpress</category><category>技术文章</category>
        </categories>
        <tags>
          <tag>共享</tag><tag>工具条</tag><tag>开源</tag><tag>百度分享</tag><tag>百度喜欢</tag>
        </tags>
        <content type="html"> 现在做网站一个社会化分享工具还是很有必要的，百度在不久前提供了百度分享功能，据说这个功能会让百度更加青睐你的网站。百度提供的分享工具条样式比较单一而且不是太好看，看到异次元的百度分享工具条非常好看，于是仿了一个近似的，先分享出来给大家用。
 作者:eliteYang
博客地址:http://www.cppfans.org  C&#43;&#43;爱好者博客是一个以程序开发、IT资讯为主的个人博客，旨在与各位网友交流开发经验，分享知识。
发布时间:2012/10/20
使用声明:请尊重原创者,允许转载和修改,但需要保留链接,谢谢合作,祝大家使用愉快,如有疑问,请至 C&#43;&#43;爱好者博客(www.cppfans.org) 交流讨论。本工具条旨在学习CSS和JS开发，并无意抄袭或剽窃异次元博客风格，如过异次元发出禁止使用声明，请大家不要再使用了。
 &amp;nbsp;
使用说明：
1.将baidu_share_tool_bar文件夹里的所有文件上传到你的wordpress当前主题的目录下
** 2.在文章页面single.php适当的地方引用share.php即可，代码&amp;lt;?php include(&amp;ldquo;share.php&amp;rdquo;); ?&amp;gt;**
** 3.从百度分享http://share.baidu.com获取分享和喜欢按钮的代码，代码里有你自己的id，修改share.php中注释处的uid为你自己的**
** 4.需安装WP-PostViews插件，用来显示访问次数，一般都会安装的**
-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;华丽的分割线-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;
版本记录：
 2012/10/24 Version 0.5
1.修改围观次数错误的问题(感谢icedream同学的提醒)
0.5版本下载地址：yunfile网盘 | 百度网盘 | 千军万马网盘 | Box网盘
 &amp;nbsp;
2012/10/20 Version 0.4
1.修改上一篇和下一篇逻辑反了的问题
0.4版本下载地址：yunfile网盘 | 百度网盘 | 千军万马网盘 | Box网盘
&amp;nbsp;
2012/10/20 Version 0.3
1.修改前一页后一页导航条代码，使之功能正确(非常感谢icedream的帮忙，其博客地址为:http://tesfans.org/)
2.修改百度喜欢样式表like.css的like按钮图标使用JS获取，并分为使用JS获取版本和不使用JS获取版本(like.css和like_donot_use_js.css，如果你嫌JS加载慢的话，可以修改like_donot_use_js.css为like.css)
3.整理滚动后自动置顶代码为一个单独的JS(share_roll.js)
4.修改share.css和like.css为按需加载，在share.php顶部加载
0.3版本下载地址：yunfile网盘 | 百度网盘 | 千军万马网盘 | Box网盘
&amp;nbsp;
2012/10/14 Version 0.2
1.修改前一页后一页导航代码(还有错误)，title标签没有做
&amp;nbsp;
2012/10/13 Version 0.1
1.增加share.php代码
2.增加百度分享样式表share.css代码
3.增加百度喜欢样式表like.css代码
&amp;nbsp;
 FAQ：
1.我的博客文章页面较宽，如果修改百度分享工具条的宽度？
答：修改share.css中share_toolbar的widch属性为与你博客文章页面宽度符合的值
2.我的博客主题下没有js文件夹怎么办？
答：修改share.php最后一行代码中js文件的路径
3.为什么我博客里百度分享和喜欢的数量和我在百度分享后台看到的数据不一致？
答：请检查share.php中的uid是不是自己的id，如果不是请修改了。如果还不一致，请联系百度分享的工作人员解决
4.为什么我的工具条没有图片显示出来呢？
答：请查看您的博客当前主题image文件下share.gif图片是否正确
5.请问是否支持wordpress之外的其他建站系统？
答：需要修改里面WP提供的函数为你的建站系统的函数，其他不需要改动。
 更多使用问题和交流请留言说明。
效果可以参考本博客任意文章上的分享条
-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;华丽的分割线-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;
统一解压密码：www.cppfans.org
-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;华丽的分割线-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;
最新说明：
刚去看了异次元的工具条，又增加了g&#43;分享，不过我的博客宽度不够，所以就不增加了，如有需要增加的，可以找我修改代码。
</content>
    </entry>
    
     <entry>
        <title>Windows平台下如何检测C/C&#43;&#43;内存泄露？</title>
        <url>https://cppfans.org/1381.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C/C&#43;&#43;</tag><tag>VLD</tag><tag>_CrtDumpMemoryLeaks</tag><tag>内存泄露</tag><tag>垃圾回收器</tag><tag>检测</tag>
        </tags>
        <content type="html"> 对于C/C&#43;&#43;程序员来说，效率和优雅性大多数情况是对立的，我们经常会在这里面抉择，到底应该怎么取舍。而说到效率，就不得不说让这类程序员头疼了N年的问题，内存泄露，至少从C/C&#43;&#43;发明以来很多人都在头疼。而Java/C#之类的语言并不存在这种问题，因为他们从堆中申请内存，根据引用计数等(据说有六种方法，大家可以搜一下Java垃圾回收器简介)方法来管理内存，也就是传说中的垃圾回收器(Garbage collector)。C/C&#43;&#43;的程序员一向都是相信自己对内存的掌控能力，所以经常会出现各种内存泄露问题，有可能是因为自己疏忽大意，有可能是因为坑太深了，有可能是潜规则，总之，我们要做的是解决问题。
1.使用Window说自身的宏_CrtDumpMemoryLeaks
例如我们有如下的代码：
#include &amp;lt;crtdbg.h&amp;gt; int _tmain(int argc, _TCHAR* argv[]) { int* pInt = new int[10]; _CrtDumpMemoryLeaks(); return 0; } 执行之后，在输出窗口中会打印如下内容：
Detected memory leaks!
** Dumping objects -&amp;gt;**
** {108} normal block at 0x003BA1C0, 40 bytes long.**
** Data: &amp;lt; &amp;gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD**
** Object dump complete.**
** 程序“[5364] AllTest.exe”已退出，返回值为 0 (0x0)。**
他会告诉你检测到内存泄露，泄露了多少字节等内容。
遗憾的是看不到那里内存泄露了，我们可以稍微改下这个代码，让他支持在哪个文件的哪个函数里哪一行有内存泄露。修改内容如下：
//MemoryLeak_h // #ifdef _DEBUG #include &amp;lt;crtdbg.h&amp;gt; #define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__) #else #define DEBUG_NEW new #endif #ifdef _DEBUG #include &#34;MemoryLeak.h&#34; #endif int _tmain(int argc, _TCHAR* argv[]) { int* pInt = DEBUG_NEW int[10]; _CrtDumpMemoryLeaks(); return 0; } 再次运行输出窗口的内容如下：
Detected memory leaks!
Dumping objects -&amp;gt;
d:\project\alltest\alltest\alltest.cpp(12) : {108} normal block at 0x0060A1C0, 40 bytes long.
 Data: &amp;lt; &amp;gt; CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
Object dump complete.
程序“[6372] AllTest.exe”已退出，返回值为 0 (0x0)。
它标明了alltest.cpp第12行有内存泄露，泄露内存块在0x0060A1C0位置，泄露大小为40字节，这样就能帮助我们快速的定位问题所在了。
&amp;nbsp;
2.Visual Leak Detector 库（VLD）
项目主页地址：http://vld.codeplex.com/，codeproject和sourceforge上都有其项目主页，大家可以自行选择下载。
其中包含Windows版本和源代码版本，windows版本是头文件和lib文件，用户可以自行调用，而源码版本可以自己编译。
使用方法异常简单，只需要包含vld.h头文件即可
&amp;mdash;&amp;mdash;&amp;mdash;- Block 58 at 0x004EBF58: 76 bytes &amp;mdash;&amp;mdash;&amp;mdash;-
Call Stack:
 d:\project\alltest\alltest\alltest.cpp (9): AllTest.exe!wmain &#43; 0x7 bytes
f:\dd\vctools\crt_bld\self_x86\crt\src\crt0.c (240): AllTest.exe!__tmainCRTStartup &#43; 0x19 bytes
f:\dd\vctools\crt_bld\self_x86\crt\src\crt0.c (164): AllTest.exe!wmainCRTStartup
0x75C8339A (File and line number not available): kernel32.dll!BaseThreadInitThunk &#43; 0x12 bytes
0x772C9EF2 (File and line number not available): ntdll.dll!RtlInitializeExceptionChain &#43; 0x63 bytes
0x772C9EC5 (File and line number not available): ntdll.dll!RtlInitializeExceptionChain &#43; 0x36 bytes
Data:
40 BA 4E 00 00 00 00 00 00 00 00 00 00 00 00 00 @.N&amp;hellip;.. &amp;hellip;&amp;hellip;..
28 00 00 00 01 00 00 00 3A 00 00 00 FD FD FD FD (&amp;hellip;&amp;hellip;. :&amp;hellip;&amp;hellip;.
CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD &amp;hellip;&amp;hellip;.. &amp;hellip;&amp;hellip;..
CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD &amp;hellip;&amp;hellip;.. &amp;hellip;&amp;hellip;..
CD CD CD CD CD CD CD CD FD FD FD FD &amp;hellip;&amp;hellip;.. &amp;hellip;&amp;hellip;..
Visual Leak Detector detected 50 memory leaks (6904 bytes).
Largest number used: 11346 bytes.
Total allocations: 17030 bytes.
Visual Leak Detector is now exiting.
通过上面蓝色加粗的字体我们就很容易得知具体的泄露位置了。而且VLD现在2.2.3的新版本有一个vld.ini文件，用来配置各种开关和参数，具体的配置说明请查看http://vld.codeplex.com/wikipage?title=Configuration%20Options&amp;amp;referringTitle=Documentation
 注意：如果你发现你按照这种做法做了，但是却出现0xc0150002的问题，请拷贝vld安装目录下的对应平台的Microsoft.DTfW.DHL.manifest和dbghelp.dll到你的程序目录下。（To ensure that vld.dll finds the required private assembly, you need to copy dbghelp.dll and Microsoft.DTfW.DHL.manifest to the same directory that vld.dll is in.）
 最后不得不吐槽一下这种需要lib还需要dll的方法，甚至还需要对应mainfest文件，太麻烦了，还不如直接给一个Lib完事了。
</content>
    </entry>
    
     <entry>
        <title>几款好的图床介绍！</title>
        <url>https://cppfans.org/1375.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>Flickr</tag><tag>SkyDrive</tag><tag>又拍网</tag><tag>图床</tag>
        </tags>
        <content type="html"> 我们这些写博客或者做论坛的站长可能会经常因为没有大的网站空间而发愁，因为没钱换大的空间，所以如果是经常文章中会插入一些图片的朋友就会费尽心思的找图床，当然了，我指的是正常的图片(那些非正常的你懂的)。而因为各种问题，很多网盘不是速度慢，或者经营不善到关闭，国内的网盘现在做文件外链的很多，但是图片呢，就不怎么地了，千脑那速度，真心不给力。
今天呢，我就给大家介绍几款犀利的图床
1.强大的微软出品，SkyDrive在线存储服务
 SkyDrive在线存储    这个服务已经存在很多年了，最开始是只要有live账号，统一都是25G，后来慢慢改成了现在的模式，免费账户7G，再增加空间就得额外付钱了，如下图：
SkyDrive服务升级费用  当然了，我觉得7G已经完全够用了，大不了再申请几个账号用呗，当然如果你怕麻烦，就花点银子升级吧。
SkyDrive的好处是不怕MS不管这个服务了，图片有保障，不想国内某些小网站，一阵之后就消失了。而且空间够大，想让别人也看到的你的图片，就将图片放在公开文件夹里吧，私有文件夹里的图片也可以分享，不过需要向特定的用户或者邮件账户分享。
&amp;nbsp;
2.老牌名将flickr
 Flickr图床首页    很多早期用图床的朋友都会用到它，现在貌似用的少了，不过我个人觉得他还是非常好用，图片速度快，上传没限制。你只需要一个google或者雅虎的账号就全部搞定，支持内部编辑。
&amp;nbsp;
3.国内新生的一系列图片服务
由于国内网盘纷乱繁杂，各式各样的都有，不过无外乎几种方式，一个是永久提供多少空间，一个是每月提供多少上传流量，大同小异，特点是让你欣赏到其他用户的图片，交互性强，查看方式新颖奇特，容易吸引人。
这里用又拍网的服务举例吧(看到梦幻龙网在用这个图床，所以格外留意了下)
 又拍网图床展示    &amp;nbsp;
综合几点来说，推荐用SkyDrive，主要是因为稳定性强，当然了，可以尝试下国内的网盘，还是很不错的，具体选择，还要看各位看官的了。
</content>
    </entry>
    
     <entry>
        <title>[PC技术]硬盘从IDE修改为AHCI模式后蓝屏如何处理？</title>
        <url>https://cppfans.org/1369.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>AHCI</tag><tag>IDE</tag><tag>Win7</tag><tag>硬盘</tag><tag>蓝屏</tag>
        </tags>
        <content type="html"> 这几天将win7换到了64位下，本来想虚拟机装Mac，结果CPU因为不支持VT，所以就作罢了，不想折腾VMware了，太麻烦了。当时磁盘换到IDE模式下之后，忘了换回来了，直接装了Win7 x64，完了之后换回来却蓝屏了，连错误都不给我看。查了查原来是有方法可以修改的。
1.打开注册表，Win &#43; R 输入regedit可直接打开
2.查找HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\services\msahci（也有人说是这个项 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\msahci，不过我测试的结果是ControlSet001，大家不放心可以都试试），修改Start项数值为0,
3.重启电脑
4.进入bios，修改硬盘模式为AHCI，按F10保存
5.这个时候理论上已经结束了，不过有人估计还是不行，那是因为你没有安装AHCI驱动，不过一般是进去之后如果联网了，系统会自动安装AHCI驱动的，安装完之后在此重启
&amp;nbsp;
这个时候你就会发现已经没有任何问题了，试试拷贝速度是不是变快了。
</content>
    </entry>
    
     <entry>
        <title>[源代码]Nana GUI示例代码</title>
        <url>https://cppfans.org/1368.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>GUI</tag><tag>nana</tag><tag>分享</tag><tag>图形用户界面</tag><tag>源代码</tag>
        </tags>
        <content type="html"> 关于nana的介绍，可以查看《[GUI]nana GUI初尝试》，本文主要是分享其中UI的实现代码。
#include &amp;lt;tchar.h&amp;gt; #include &amp;lt;Windows.h&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;nana/gui/wvl.hpp&amp;gt; #include &amp;lt;nana/gui/basis.hpp&amp;gt; #include &amp;lt;nana/gui/widgets/label.hpp&amp;gt; #include &amp;lt;nana/gui/widgets/textbox.hpp&amp;gt; #include &amp;lt;nana/gui/widgets/combox.hpp&amp;gt; #include &amp;lt;nana/gui/widgets/button.hpp&amp;gt; #include &amp;lt;nana/paint/image.hpp&amp;gt; #include &amp;lt;nana/paint/graphics.hpp&amp;gt; #include &amp;lt;nana/gui/layout.hpp&amp;gt; #include &amp;lt;nana/gui/widgets/picture.hpp&amp;gt; int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow) { // 设置窗体属性 nana::gui::form my_form(nana::gui::API::make_center(450, 220), nana::gui::appearance(true, true, false, false, true, false, false)); my_form.caption(STR(&#34;Webpage2Image By eliteYang&#34;)); nana::gui::API::window_icon(my_form, nana::paint::image(STR(&#34;small.ico&#34;))); // 窗体背景图 nana::paint::image image_bg; bool bOpen = image_bg.open(STR(&#34;bg.png&#34;)); nana::gui::drawing drawing_bg(my_form); drawing_bg.clear(); drawing_bg.bitblt(0, 0, 450, 220, image_bg, 0, 0); drawing_bg.update(); // 设置label显示 nana::gui::label my_label(my_form, 10, 10, my_form.size().width - 10, my_form.size().width - 10); my_label.format(true); my_label.transparent(true); my_label.caption(STR(&#34;&amp;lt;bold=true, color=0xff0000, font=\&#34;Consolas\&#34;&amp;gt;\ &amp;lt;color=0x000000&amp;gt;Notes :&amp;lt;/&amp;gt;This is a tiny program to show how save a html webpage\ to an image.\n\n\ &amp;lt;color=0x000000&amp;gt;Author:&amp;lt;/&amp;gt;eliteYang\n\n\ &amp;lt;color=0x000000&amp;gt;Blog :&amp;lt;/&amp;gt;&amp;lt;color=0x0000ff, url=\&#34;http://www.cppfans.org\&#34;&amp;gt;http://www.cppfans.org\ &amp;lt;bold=false, italic=true, color=0xff0000&amp;gt;(Click url to access my blog)&amp;lt;/&amp;gt;&amp;lt;/&amp;gt;&amp;lt;/&amp;gt;&#34;)); // 设置输入框 nana::gui::label my_label_input(my_form, 10, 122, 80, 80); my_label_input.format(true); my_label_input.transparent(true); my_label_input.caption(STR(&#34;Website url:&#34;)); // url输入框 nana::gui::textbox my_text_box_url(my_form, 80, 120, 200, 20); my_text_box_url.border(true); my_text_box_url.multi_lines(false); // 保存格式组合框 nana::gui::combox my_combox_format(my_form, 290, 120, 60, 20); my_combox_format.push_back(STR(&#34;PNG&#34;)); my_combox_format.push_back(STR(&#34;JPG&#34;)); my_combox_format.push_back(STR(&#34;BMP&#34;)); my_combox_format.push_back(STR(&#34;GIF&#34;)); my_combox_format.push_back(STR(&#34;TIFF&#34;)); my_combox_format.option(0); // button // TODO:GetUrlImage nana::gui::button btn(my_form, my_form.size().width / 2 - 75, 160, 150, 30); btn.caption(STR(&#34;Get Image&#34;)); btn.make_event&amp;lt;nana::gui::events::click&amp;gt;(nana::gui::API::exit); my_form.show(); nana::gui::exec(); return 0; } 如有什么意见或问题，欢迎交流。
</content>
    </entry>
    
     <entry>
        <title>[GUI]nana GUI初尝试</title>
        <url>https://cppfans.org/1364.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>GUI</tag><tag>nana</tag><tag>图形用户界面</tag>
        </tags>
        <content type="html"> 前几天群里讨论GUI的时候大家各抒己见，提出了一些非常好的GUI工具和代码，大部分都是已经用过的，比如MFC，Qt，DirectUI等等，不过DUI现在基本都是收费的，有一个炫彩界面还不错，不过只是提供接口和dll，nana就是一位朋友提出来的，说很轻巧，全部是自己写，很方便，不需要借助其他的库。
花了一个小时研究了下，觉得还挺不错的，效果方面还是很满意的，截张图给大家看看。

因为想做一个网页保存为图片的小工具来自己玩玩，也是受了web2pic工具的启发了。
nana gui简介：
Nana is a C&#43;&#43; framework provides GUI, threads and filesystem. It provides many of the basic classes and functions for the cross-platform programming.
项目地址：http://stdex.sourceforge.net
这个作者是搞图形算法的，搞过很多独特的UI系统，CSDN上的朋友说坐等半年再看是否依然更新，结果这次他做到了，最新的0.23支持对C&#43;&#43; 11标准的支持，不过我的VS2010 SP1补丁打不上，lamda不支持，完全编译不过。
&amp;nbsp;
其中大多数控件支持字体和颜色，超链接支持，还是很不错的，而且很小。有一点不好的就是windows下还需要包含window.h有文件，没有完全分离开，不过作者下一步要改进这点瑕疵，拭目以待吧。
&amp;nbsp;
下一篇会将这个小例子的代码放出来给大家看看，代码非常简单。
</content>
    </entry>
    
     <entry>
        <title>请理性爱国，理性表达你的保钓思想</title>
        <url>https://cppfans.org/1363.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>保钓事件</tag><tag>理性爱国</tag>
        </tags>
        <content type="html"> 最近炒得很热的事件就是中日争夺钓鱼岛了，首先声明，钓鱼岛是属于中国人民的，而井空是属于全世界人民的。保钓事件从一开始的两国争纷到现在双方局势紧张，国民情绪愤涨，不得不说有很多暗中的推手。
刚刚在人人网上看到了西安的游行事件，为了钓鱼岛，首先很赞成你们的行动，但是看到图片却是另一种行为，变成了蛮横的打砸抢事件了。先看看下面的一组照片：
日本料理山葵被烧，浓烟滚滚  &amp;nbsp;
几十万的钢琴被砸毁，两部电梯被砸毁，事发地为南门城堡酒店。暴民们以为是日资，其实是新加坡的。  &amp;nbsp;
钟楼方向冒着滚滚浓烟，出动大量的防暴警察  据观察上面的图片，主要的游行地点在钟楼一带，据说咋了很多日本车。
我想问下在西安游行的朋友，你们到底在干什么，同胞们，这些车都是你老乡的，不是日本人的，只是因为别人买的是日本车你就砸了，那请问砸车者你们家的PS呢、你们家的索尼电器、松下电器，有本事都砸了啊，你自己收藏的爱情动作片呢，也没见的删掉啊，你丫以前看的爱情动作片、日本动漫、日本电影，也没见你挖眼珠子啊。
爱国是件很好的事情，但是到最后结局我们发现跟游行的目的不一致了，变成了刁民事件了。乱砸一通不说，还搞错对象，砸了新加坡的一家店，更搞笑的是有人T恤上写的保钓二字，钓字写成了钩，我不想说没文化，但是没事瞎掺和什么啊，有几个人是真心关注钓鱼岛的，你说你这新关心钓鱼岛，那请问“钓鱼岛在哪里？钓鱼岛多大面积？为什么要争钓鱼岛？钓鱼岛长什么样？”。大家都是图个热闹图个开心，觉得砸一砸挺好玩的，中国的法律向来是法不责众，但是就冲这个打砸行为，判个两三年也不成问题的。
最可笑的是每次游行里，最有热情冲在最前面的都是一帮SB学生，被人当枪使还乐在其中，有一票在校学生还兴奋的上传图片，这算什么啊，有种去踏平东京啊，然后想看什么电影看什么电影啊。各位同学，当年的醒还没记住啊？(具体的提醒是什么，大家心里都清楚。)
看看游行队伍中的人，真正挑事的人都是在鼓动别人，这些人是别有用心的，可能是商业之争，可能是想引起一些震动，然后发点小“国难财”，总之，是有人在背后将本次爱国行为促成了恶意事件。
国外游行，很有秩序，最多就是丢丢垃圾，而且他们都是为了自身利益，比如工作，待遇等等，而反观我们的国民，一个个都装作很愤青的样子，这里的愤青是骂人话，愤青在我那时候还不是骂人话呢。
我不想说鼓吹大家相信party，相信go——vern——ment，但是总得有人来领导。还有大量转发跪求一战的，我觉得你们可以报名参军，然后真的开打了，派你们冲锋，愿意吗？
最后，我一个小小的码畜，呼吁大家理性爱国，发表自己对钓鱼岛事件的呼声就行了，只有国内稳定下来，各位大佬才能安心处理国际事件，“攘外必先安内”这个道理大家都懂。
</content>
    </entry>
    
     <entry>
        <title>解决Ubuntu下输入法不显示问题</title>
        <url>https://cppfans.org/1360.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>ibus</tag><tag>Linux</tag><tag>Ubuntu</tag><tag>输入法</tag>
        </tags>
        <content type="html"> ubuntu下的默认输入法是ibus，还有一个sunpinyin，个人觉得ibus已经不比任何国内的输入法差了，词组很精确，非常完美。
那天遇到的输入法不显示可选项，着实比较郁闷，后来研究了下可能是键盘设备出了问题，ubuntu右上角有一个键盘的标志，里面有首选项可以选择输入法，并且进行设置快捷键等操作。
不过很多时候因为这样那样的原因，导致了输入法出现很奇怪的问题，这个时候就需要重启ibus的守护进程了。
1.打开终端 （大多数是alt &#43; F2， ubuntu是ctrl &#43; alt &#43; t， 当然了你可以在附件里找到它）
2.关闭ibus的守护进程 killall ibus-daemon
3.重启ibus守护进程 ibus-daemon -d
这样再尝试用ctrl &#43; whitespace试试能否切换输入法到中文了。
&amp;nbsp;
其实Linux的很多问题都很简单，主要是不熟悉的缘故，我写的这些问题都是我在玩Ubuntu的时候遇到的问题，写出来与大家分享。
</content>
    </entry>
    
     <entry>
        <title>Ubuntu12.04LTS下如何安装和彻底卸载xfce4？</title>
        <url>https://cppfans.org/1356.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>lxde</tag><tag>Ubuntu</tag><tag>Xfce</tag><tag>软件卸载</tag><tag>软件安装</tag>
        </tags>
        <content type="html"> 今天将Ubuntu12.04更新完了，用的网易的源，更新速度还是很给力的，平均500多K的下载速度。发现虚拟机上unity界面还是比较卡的，想换成gnome3.6试一下，结果rangerlee说xfce和lxde桌面很清爽，并且轻量占用内存少，打算试试。
xfce的安装命令为：
sudo apt-get install xfce4 会安装大约60M的包，然后注销系统，选择xfce会话进去就是一个类似与原来的gnome的桌面，壁纸有一个小老鼠。
后面又尝试了lxde，同样的安装方法，安装完之后发现挺像xp的，感觉还不错，决定使用这个了，于是想卸载xfce。
最简单的卸载命令：
sudo apt-get remove xfce4 结果仅仅删除了30多K 的文件，google了一下，原来这尊大神好请难送，查到了如下命令可以完全卸载掉
sudo apt-get purge xfconf xfce4-utils xfwm4 xfce4-session thunar xfdesktop4 exo-utils xfce4-panel xfce4-terminal libxfce4util-common scim xscreensaver 然后再执行自动移除没用的文件
sudo apt-get autoremove 这样就可以完全卸载了，还在纠结的你，快点试试吧。
PS：发现lxde各方面都挺不错的，就是打中文字不出现可选项，这个太糟糕了，谁知道怎么弄，救救我吧。
</content>
    </entry>
    
     <entry>
        <title>vmvare虚拟机下的Ubuntu如何设置设置无线联网？</title>
        <url>https://cppfans.org/1354.html</url>
        <categories>
          <category>技术文章</category>
        </categories>
        <tags>
          <tag>Linux</tag><tag>Ubuntu</tag><tag>网络设置</tag>
        </tags>
        <content type="html"> 今天晚上突然心血来潮，想更新一下很久不用的Ubuntu系统，因为已经到了12.04LTS版本了，打开vmvare启动电源后发现网络都无法连接，mozilla thunderbird提示无法连接网络，上次打开还没有问题，察看了网络设置是选择的NAT，按道理是没有任何问题的，以往设置网络都是这样的。
无奈只好求助google大神，原来是要设置网络为桥接模式，貌似是因为我在win7上禁掉了vmnat的服务还是说路由器上限制了IP(因为我们为了防止网络被别人利用，就在路由器上做了绑定)。我的vmvare是绿色版的，直接在vmvare目录下找到vmnetcfg.exe，打开选择桥接模式，底下有一个下拉选项，选择自己机器的网卡，然后应用保存就可以了，根本无需重启虚拟机，很是方便。
不过美中不足的是，网络很慢，FF开网页还是比较快的，但是下载12.04的更新竟然需要4-6个小时，网速只有平均40k/s左右，急死我了，查了下貌似大家在虚拟机里使用ubuntu网速都很慢，是因为dns解析比较慢，已经查到方法了，等更新完之后我试试那个方法，如果可行的话就转载过来。
PS：ubuntu增加了软件中心的方式非常好，我们在下载软件的时候不用像以前一样还苦苦的自己打命令，增加软件源什么的，现在之需要打开软件中心，搜索软件并点击安装就可以了，非常方便。（不过特别的软件可能会搜不到，还需要自己安装）
明天等更新万之后安装下gnome3.6，unity的界面还是觉得不是很舒服，很华丽但是有点过了，虽然这个说不上来名字的颜色(橙色？紫色？好吧，我是色盲)很棒。
试了下codeblocks，依然是那么爽，哈……以后得在Linux上花的时间多一点了。
</content>
    </entry>
    
     <entry>
        <title>[源码分享]Windows下的半自动线程锁</title>
        <url>https://cppfans.org/1350.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>半自动锁</tag><tag>多线程</tag><tag>线程锁</tag><tag>网络编程</tag>
        </tags>
        <content type="html">  写在前面的话：开始写一套网络库，打算先用IOCP吧，Asio毕竟还在学习阶段，定义名字为FreeNet，会慢慢放出来代码的，希望大家持续关注，并互相交流。
 关于IOCP的网络库，里面必不可少的肯定会用到多线程，所以轻量级的线程锁还是需要的，所以简单写了一个半自动的线程锁，所谓半自动，就是要显式的调用加锁，但是不必手动释放该锁。以前学的基础多线程中的都是显式的加锁，显式的解锁，比较繁琐。我们这里只是简单的封装了下而已。
Locker.h
/************************************************************************ FileName:Locker.h Author :eliteYang EMail :elite_yang[at]163.com Copyright (C) http://www.cppfans.org This file is a part of FreeNet, provide a semi-automatic thread lock. ************************************************************************/ #pragma once #include &amp;lt;Windows.h&amp;gt; class CLocker { public: CLocker(); ~CLocker(); void Lock(); void UnLock(); private: CRITICAL_SECTION m_access; }; ////////////////////////////////////////////////////////////////////////// class CAutoLocker { public: CAutoLocker( CLocker* pLocker ); ~CAutoLocker(); private: CLocker* m_pLocker; }; 这里我们用到的是临界区来加锁。
Locker.cpp
#include &#34;Locker.h&#34; CLocker::CLocker() { ::InitializeCriticalSection(&amp;m_access); } CLocker::~CLocker() { ::DeleteCriticalSection(&amp;m_access); } void CLocker::Lock() { ::EnterCriticalSection(&amp;m_access); } void CLocker::UnLock() { ::LeaveCriticalSection(&amp;m_access); } CAutoLocker::CAutoLocker(CLocker* pLocker) { m_pLocker = pLocker; if (m_pLocker) { m_pLocker-&amp;gt;Lock(); } } CAutoLocker::~CAutoLocker() { if (m_pLocker) { m_pLocker-&amp;gt;UnLock(); } } 这样的锁，我们在调用的时候定义一个锁对象，然后对其加锁，然后在跳出大括号的时候因为析构所以会自动解锁。
&amp;nbsp;
简单的使用例子：(注意：本例中的赋值操作是原子操作，不需要加锁的，但是只是展示如何使用的，所以就这样写了，大家千万不要多此一举啊)
#include &#34;stdafx.h&#34; #include &#34;Locker.h&#34; CLocker m_lock; int _tmain(int argc, _TCHAR* argv[]) { CAutoLocker m_autoLocker(&amp;m_lock); { int a = 0; } return 0; } </content>
    </entry>
    
     <entry>
        <title>[网络开发]boost::asio简介</title>
        <url>https://cppfans.org/1348.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>asio</tag><tag>boost</tag><tag>异步I/O</tag><tag>网络编程</tag>
        </tags>
        <content type="html"> boost前几天发布了1.51版本，更新内容请查看：http://www.boost.org/users/history/version_1_51_0.html，asio修改如下内容：
   Asio:    Fixed an incompatibility between ip::tcp::iostream and C&#43;&#43;11 (#7162).     Decorated GCC attribute names with underscores to prevent interaction with user-defined macros (#6415).     Added missing #include &amp;lt;cctype&amp;gt;, needed for some versions of MinGW.     Changed to use gcc&#39;s atomic builtins on ARM CPUs, when available (#7140).     Changed strand destruction to be a no-op, to allow strand objects to be destroyed after their associated io_service has been destroyed.     Added support for some newer versions of glibc which provide the epoll_create1() function but always fail with ENOSYS (#7012).     Changed the SSL implementation to throw an exception if SSL engine initialisation fails (#6303).     Fixed another regression in buffered_write_stream (#6310).     Implemented various minor performance improvements, primarily targeted at Linux x86 and x86-64 platforms.      对了，简单介绍一下asio吧，
原文：
Boost.Asio is a cross-platform C&#43;&#43; library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C&#43;&#43; approach.
Boost.Asio是一个跨平台的C&#43;&#43;语言的网络和低级的I/O编程库，用现代的方法为开发者提供了一个异步模型。(翻译的不是很到位，见谅)
他的核心是boost::asio::io_service，任何一个asio程序都需要一个io_service来run。
大家其实都很清楚，网络通信的瓶颈是在I/O上，也就是I/O读写速度不够快，至少没有CPU快，所以windowsNT上提供了重叠IO的方法，我们叫他IOCP，IOCP只是一个方法而已，大家在windows上的确是将他神话了，至少他的效率不是想象中的那么高，不过处理一般的网络通信够用了。asio其实也是采用了类似的方法，不过实现过程却不相同，具体请查看http://www.boost.org/doc/libs/1_51_0/doc/html/boost_asio/overview/core/basics.html，它提供了一个io_service来连接你的程序和操作系统。
1.你的程序数据给io_object
2.io_object发送请求给io_service
3.io_service通知操作系统
4.操作系统处理完之后返回给io_service
5.你的应用程序调用io_service::run()来接收操作系统的回馈
6.io_service将结果通知应用程序中的完成句柄
这就是一个简单的asio通信处理的过程，最近我正在学习asio，准备用asio封装一个网络库，同时IOCP也在参考很多游戏源代码中的网络库，不够IOCP得自己写tcp方面的东西，我很不熟悉，所以暂时只能照猫画虎了。最后这两种库都会放出来给大家看的。
PS:最近一段时间挺消极的，不知道为何总是没心思写东西，每天看着群里讨论的热烈程度，也想自己做点东西出来。决定从现在开始正常作息时间，每天晚上写一部分东西，不论多少，至少要写出来。看到的内容需要实践才能出结果，努力吧。
</content>
    </entry>
    
     <entry>
        <title>浅谈国产游戏业的问题——到底是谁玩了谁？</title>
        <url>https://cppfans.org/1342.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>内容</tag><tag>游戏行业</tag><tag>规则</tag>
        </tags>
        <content type="html"> 最近由于项目内的一些策划内容的调整，导致玩家大面积流失，针对最近的这些问题，思考了一下国内现在游戏行业存在的弊端，大家就当一篇杂谈，看看就好，万不可较真。
1.致力于圈钱国的内中小型游戏公司，甚至是大公司。
现在整个国情都浮躁起来了，所有的公司都想赚快钱，每周甚至每天都有各种花样的礼包，充值活动，有点类似于商场的做活动，打折、买一赠一等。纯粹是在提前消费玩家的钱，礼包开出来的东西并不是你需要的东西，但是却让玩家觉得不充值不买这次的礼包就亏大了。
其实这是一种饥饿消费或者叫饥渴消费，类似与国内的小米手机，每次都在每批手机销售前大肆宣传，在开始销售后的几个小时内准没货，就是抓住了国人的心理，爱凑热闹。
说个周立波曾经说过的笑话，世博会让国人学会了排队，有一天，一个男子站在某写字楼门口处等待，过往的人群慢慢都开始在该男子后排队，过了大概20多分钟下午六点了，男子回头一看，竟然身后有这么多人，于是他说了一句话，你们都接老婆下班吗？
2.游戏内容的无新意，重复。
众所周知，游戏可玩性、趣味性、平衡性都是由策划来设计的，所以以后请各位玩家遇到游戏内容的问题不要说是技术的问题了。
现在的策划团队众多都是偏年轻化，因为工作经验越少的人请过来越便宜(国内看工作年限的公司多不胜数，大家都懂得。)，这就导致了缺乏经验，没有游戏大方向感，通常是做着做着就偏离了原定的路线，取决于策划团队中的相对于有些经验的人。该人如果喜欢PVE则这个游戏就会朝着PVE的方向走了，不论这个游戏以前是什么方向，不论这个东西对玩家有没有好处，通常是他自己认为出发点是好的就应该存在。不禁想发问，难道某人心中故意要折腾玩家吗？
如今国内的游戏都是后人看前人，在前人的方案上改进，今天这个游戏出结婚系统了，明天一票游戏都能出结婚系统，今天这个游戏某系统了，明天你准能看到别的游戏也宣传类似的系统了。国内的游戏系统都比较跟风，看哪个东西玩家反响好，就抄过来用，看起来是大有不同，但是其实玩法都很相近，所以玩家都会在一段时间后感觉烦了，会从一票类似的游戏中流失。
3.游戏宣传的虚假性。
现在所谓的宣传，某某测试，某某引擎，某某次时代，某某新技术，某某国内首创，其实都有很大的水分在里头。主要的目的还是为了吸引玩家来，玩家试完了之后觉得还不错就留下了，这样就多了一部分数据了，国内的观点都是先聚集了人，然后才能赚钱。这是一种错误的心理，由于这个方式，导致玩家像蝗虫群一样，今天公会一喊，就去某游戏了，明天公会又一喊，又去别的游戏了，到最后其实也苦了游戏厂商了，大家都在砸钱，都在拼，自己没赚到，玩家也没爽到，两边不讨好。
4.运营团队的责任感问题。
四月份的时候看新浪游戏行业白皮书，上面对国产游戏包括国内运营的游戏分别作了6个方面的评分，分别是 游戏画面、游戏音效、基础设定、游戏性、相关服务、游戏特色。其中魔兽世界以平均9.6分稳居榜首，玩过WOW的朋友都会对该游戏赞叹不已，WOW的相关服务是9.7分。相关服务基本上指的是游戏客服对游戏内遇到的问题的解决，例如被封号了，被盗号了，密码错误，游戏内不明白的地方等等的解释和处理。魔兽世界的客服都会很迅速很专业的解决你的问题，甚至会回访，所以这个分不是网友白给的或者用钱砸出来的，是货真价实的。而再观国内众多游戏的客服，似乎玩家从来不知道有客服这样的东西，电话没人接，邮件没人理，投诉没人管，奖品发放错误没反应等等问题，基本都是在论坛里回答玩家问题，而且很不专业，客服对游戏都不了解，更不要说玩家了，更说明了游戏性太低了，没吸引到人群。客服因为薪水的问题、工作时间的问题都导致了客服在混日子，对玩家的问题没有上心，运营团队只对收入数据很关心，似乎这样才能获得对应的奖金。
5.因为某些问题擅自修改游戏数据。
某些项目可能因为当初设计时某个数值或公式有问题直接影响了游戏的平衡性，但是这个问题会在上线挺久后才会慢慢暴露出来，于是就会遭到开发团队的修改底层公式，导致玩家的利益受到损失，如果国内互联网虚拟财产保护法健全的话，这些改动都应该受到判刑或者罚款的。正是因为法律内容的不健全，导致了游戏厂商敢大肆作为。
&amp;nbsp;
以前看过一篇文章上面写道，现在不是玩家玩游戏，而是游戏在玩玩家，但是觉得挺好笑的没明白，现在终于明白了，玩家就是游戏厂商的小白鼠，游戏厂商想怎么蹂躏就怎么蹂躏，除非你发誓不玩国内游戏了，再玩就砍手，我觉得玩家还没这么有魄力，毕竟游戏是一个放松的东西。所以游戏行业，到底是谁玩了谁，大家都懂得。
</content>
    </entry>
    
     <entry>
        <title>[网络开发]RakNet翻译文档(6)——Bitstream</title>
        <url>https://cppfans.org/1335.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>BitStreams</tag><tag>RakNet</tag><tag>文档</tag><tag>翻译</tag>
        </tags>
        <content type="html">  Bitstream概述 Bitstream类是一个RakNet命名空间下的helper类，是一个用于打包、解包bits的动态数组。它有如下四个优点：
1.动态的创建数据包
2.压缩
3.写入Bits
4.字节序转化
对于结构体打包来说，需要预定义结构体，并将他们转化为一个(char*)的类型。使用Bitstream，你可以在运行时根据上下文选择写入数据块。Bitstreams可以使用SerializeBitsFromIntegerRange()和SerializeFloat16()函数压缩原有的数据类型。
当然了，你还可以写入Bits。大多数时间下你不需要关心这些事情。然而，当写入布尔值时它会自动仅仅写入一个Bit位。这种方式在加密中非常有效，因为你的数据不再是按照字节对齐。(译者注：使得破解者无法获取你的数据结构)
&amp;nbsp;
写入数据
Bitstream是一个可以带任何数据类型的模板类。如果是一个内建的数据类型(译者注：指的是非自定义的数据类型)，例如NetworkIDObject，它使用了局部模板特化来更有效的写入数据类型。如果它是一个原生类型或者一个结构体，他写入一个单独的bits，与memcpy()有些类似。你可以传递包含多个数据成员的结构体给bitstreams。然后，你需要序列化每一个单独的元素以纠正字节序。(例如：在PC和Mac之间通讯需要如此)
struct MyVector { float x,y,z; } myVector; // 没有字节序交换 bitStream.Write(myVector); // 有字节序交换 #undef __BITSTREAM_NATIVE_END bitStream.Write(myVector.x); bitStream.Write(myVector.y); bitStream.Write(myVector.z); // 你可以重载左移右移操作符 // 右移操作符必须在RakNet命名空间里，或者使用BitStream.h中的命名空间代替。 // 使用std::string会引起一些错误 namespace RakNet { RakNet::BitStream&amp; operator &amp;lt;&amp;lt; (RakNet::BitStream&amp; out, MyVector&amp; in) { out.WriteNormVector(in.x,in.y,in.z); return out; } RakNet::BitStream&amp; operator &amp;gt;&amp;gt; (RakNet::BitStream&amp; in, MyVector&amp; out) { bool success = in.ReadNormVector(out.x,out.y,out.z); assert(success); return in; } } // RakNet命名空间 // 从BitStream中读取 myVector &amp;lt;&amp;lt; bitStream; // 写入BitStream myVector &amp;gt;&amp;gt; bitStream; 可选的 —— 其中的一个构造函数是以字节长度为参数。如果你清楚传递的数据长度，你可以传递这个数给Bitstream的构造函数，可以避免创建bitstream时内部动态重新分配内存。
参见Creating Packets获得更多的细节。
&amp;nbsp;
读取数据 读取数据相对简单。创建一个bitstream，在构造函数中指定你的数据。
// 假设我们已经有了一个 Packet *对象 BitStream myBitStream(packet-&amp;gt;data, packet-&amp;gt;length, false); struct MyVector { float x,y,z; } myVector; // 没有字节序交换的 bitStream.Read(myVector); // 有字节序交换的 (RakNetDefines.h中的__BITSTREAM_NATIVE_END宏必须被注释掉) #undef __BITSTREAM_NATIVE_END #include &#34;BitStream.h&#34; bitStream.Read(myVector.x); bitStream.Read(myVector.y); bitStream.Read(myVector.z); 参见 Receiving Packets 获得完整的例子。
&amp;nbsp;
序列化数据 你可以通过使用BitStream::Serialize()替代Read()或者Write()，这样就可以使用相同的读写函数了。
struct MyVector { float x,y,z; // writeToBitstream==true 表示写数据 writeToBitstream==false 表示读数据 void Serialize(bool writeToBitstream, BitStream *bs) { bs-&amp;gt;Serialize(writeToBitstream, x); bs-&amp;gt;Serialize(writeToBitstream, y); bs-&amp;gt;Serialize(writeToBitstream, z); } } myVector; 参见 Receiving Packets 获得完整的例子。
&amp;nbsp;
有用的函数 参见BitSteam.h可以获得完整的函数列表
 Reset 函数
 重置字节流，清空所有数据
&amp;nbsp;
 Write 函数
 写入函数在字节流的结尾将数据写入。你应该使用类似的Read函数从bitstream中读取数据
&amp;nbsp;
 Read 函数
 读取函数按照从头到尾的顺序读取bitstream中已经存在的数据。如果bitstream中没有任何数据，Read函数返回false。
&amp;nbsp;
 WriteBitsFromIntegerRange, ReadBitsFromIntegerRange,SerializeBitsFromIntegerRange 函数
 如果一个数字知识使用的特殊的值区间(例如 10-20)，当比特数写入那个值区间内，这个函数将会自动。
&amp;nbsp;
 WriteCasted, ReadCasted 函数
 写一个类型的变量，当他需要被转化为其他数据类型。例如：WriteCasted&amp;lt; char &amp;gt;( 5 )等同于 char c = 5; Write( c );
&amp;nbsp;
 WriteNormVector, ReadNormVector 函数
 写入一个常规的向量，其中每一个元素的范围都是-1 — 1。每一个元素有16位。
&amp;nbsp;
 WriteFloat16, ReadFloat16 函数
 给出浮点数的最大最小值，以65535划分区间，将结果写入到一个16字节里(精度有损)。
&amp;nbsp;
 WriteNormQuat, ReadNormQuat 函数
 写入一个四元数到16 * 3 &#43; 4位数据中(精度有损)。
&amp;nbsp;
 WriteOrthMatrix, ReadOrthMatrix 函数
 转化一个正交矩阵为四元数，然后调用WriteOrthMatrix/ReadOrthMatrix函数
&amp;nbsp;
 GetNumberOfBitsUsed, GetNumberOfBytesUsed
 给出已写入的字节或者位的大小。
&amp;nbsp;
 GetData 函数
 给出bitstream内部数据的指针。他是一个由malloc分配的(char*)指针，在你需要直接访问bitstream的数据时使用。
&amp;nbsp;
</content>
    </entry>
    
     <entry>
        <title>[网络开发]RakNet翻译文档(5)——SystemAddress</title>
        <url>https://cppfans.org/1333.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>RakNet</tag><tag>SystemAddress</tag><tag>翻译文档</tag>
        </tags>
        <content type="html"> 什么是系统地址？
系统地址是网络中包含系统二进制IP地址和端口的结构体。这个结构体定义在RakNetTypes.h文件中，这里有一些你需要的系统地址的例子。
服务器收到一个特定客户端的消息，同时想要中转给其他客户端。你需要在发送函数中指定发送者的系统地址(在Packet::systemAddress域中给出)，同时设置广播设置为true。游戏世界里的一些物品，例如前面提到的炸弹，属于一个特定的玩家，当炸弹被杀死后，你应该给出适当的个人得分。
当你在P2P网络中想发送一条信息给任何peer时。
功能函数：
ToString() —— 给出一个系统地址的结构，可以返回点分的IP地址(译者注：例如127.0.0.1)
FromString() —— 给出一个点分的IP地址，填充结构体的binaryAddress部分
&amp;nbsp;
重要的注意事项：
1.数据包的接受方会自动知道任何发送数据包给自己的系统的系统地址，因为它可以从发送者的IP/Port组合中确定这个值。如果仅仅是为了让服务器知道系统地址，发送者不需要对它自己数据结构体中的系统地址进行编码。原始发送者的系统地址在数据包结构体中会自动传递给开发人员，该结构体是从Receive函数中返回的。
2.当使用C/S模式时，客户端无需知道数据包的原始发送者的系统四肢。客户端只关心所有从服务器发来的数据包。然后当你需要一个客户端知道令一个客户端的系统地址时，你需要在数据结构中填充SystemAddress域。可以让发送的客户端填充这个值，也可以让服务器从原始发送者那里接收数据包时填充它。
3.RakPeer特定实例的系统地址在连接过程中不会改变,唯一的例外是Router2插件。然而所有的系统都是这样的(例如在对称NAT后的系统就不是这样的)。作为一个独特的标识符,发现在数据包结构体中使用了rakNetGUID。RakPeerInterface中有操作RakNetGUID的函数。
4.当你涉及到远程系统时首选的是RakNetGUID远程系统,而不是SystemAddress。对于一个RakPeer来说RakNetGUID是惟一的标示符，然后SystemAddress却不是唯一的。同时如果你计划使用Router2插件，有必要专门使用RakNetGUID。
</content>
    </entry>
    
     <entry>
        <title>[网络开发]RakNet翻译文档(4)——Recieving Packets</title>
        <url>https://cppfans.org/1322.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>RakNet</tag><tag>recieve packet</tag><tag>文档</tag><tag>翻译</tag>
        </tags>
        <content type="html"> 抱歉这篇文章出现这么迟。
当一个数据包出现在网络上的时候，例如收到了返回值不为零的数据，涉及了三个步骤来处理它。
1.确定这个数据包的类型，它通过如下代码被返回
unsigned char GetPacketIdentifier(Packet *p) { if ((unsigned char)p-&amp;gt;data[0] == ID_TIMESTAMP) return (unsigned char)p-&amp;gt;data[sizeof(unsigned char) &#43; sizeof(unsigned long)]; else return (unsigned char) p-&amp;gt;data[0]; } 2.处理数据
接收到结构体
如果你最开始发送了一个结构体，你可以通过如下代码转化回这个结构体
if (GetPacketIdentifier(packet)==/* 用户分配的数据包标示符 */) DoMyPacketHandler(packet); // 放置在你想放置的任何地方，放在处理游戏的状态类中是个好地方. void DoMyPacketHandler(Packet *packet) { // 转化数据为适当的结构体 MyStruct *s = (MyStruct *) packet-&amp;gt;data; assert(p-&amp;gt;length == sizeof(MyStruct)); // 当你的传输结构体的时候这是个好习惯 if (p-&amp;gt;length != sizeof(MyStruct)) return; // 使用你的结构体MyStruct *s处理数据包类型的函数在此调用 } 有用的注释：
我们转化数据包的数据为一个适当的指针类型，如果我们真的要创建这个结构体时，可以避免拷贝的开销。然而在这个例子中，你修改了结构体中的任何数据，数据包中的内容也会被修改。这个可能不是我们想要的。作为一个服务器，在中转数据的时候要注意，可能会引起未知的错误。
尽管断言不是必要的，当我们发送一个数据包时，如果我们指定了错误的标识符或者错误包长度，断言对于捕获非常难发现的bug是非常有效的。
当某些人设法发送非法的长度或者类型为了让客户端或者服务器宕机时，if语句是非常有效的。在实践中，这种情况没有发生过，但是没有发生过并不代表是安全的。
接收到一个字节流
如果你最初发送的是个字节流，则需要创建一个字节流，按照我们写入的顺序来解析数据。我们创建一个使用数据和数据包长度的字节流。如果前面我们使用的是Write函数，则使用Read函数来读取他，如果使用了WriteCompressed函数，则使用ReadCompressed函数来读取。如果我们有条件性的写入任何数据，则接下来要使用同样的逻辑分支来处理。下面的例子说明了处理Creating Packets章节中的地雷数据。
void DoMyPacketHandler(Packet *packet) { Bitstream myBitStream(packet-&amp;gt;data, packet-&amp;gt;length, false); // false是为了效率，所以我们不复制传递的数据 myBitStream.Read(useTimeStamp); myBitStream.Read(timeStamp); myBitStream.Read(typeId); bool isAtZero; myBitStream.Read(isAtZero); if (isAtZero==false) { x=0.0f; y=0.0f; z=0.0f; } else { myBitStream.Read(x); myBitStream.Read(y); myBitStream.Read(z); } myBitStream.Read(networkID); // 在结构体中这个是NetworkID networlId myBitStream.Read(systemAddress); // 在结构体中这个是SystemAddress systemAddress } 3.释放数据包
将RakPeerInterface实例中得到的数据包,传递给DeallocatePacket(Packet* packet)函数，从而释放该数据包。
</content>
    </entry>
    
     <entry>
        <title>又一次最近总结</title>
        <url>https://cppfans.org/1318.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>感触</tag><tag>细心</tag>
        </tags>
        <content type="html"> 上次总结是在年底，这次总结貌似来的有点快，只是最近有点不太顺利而已，所以就发发感慨。最近犯的错误不大不小，但是影响面比较大，对外网玩家造成了很多问题，其实有时候想想玩家也很可怜，花钱了，还被我们这样折腾，觉得很对不起这些玩家。
任何程序员都想自己写出来的东西可以给更多的人使用，像我这种游戏程序员自然是希望给玩家带来更好的游戏体验和快乐，但是最近的一些事情却像是在折磨玩家似地，具体的事情就不提了，免得被喷。
这些问题都是因为不够细心，自己写完后跑流程测试不到位而导致的，所以决定以后写代码用2份时间，测试流程用1份时间，也就是要求写代码的时间缩短了，对自己的挑战也更大了。
戒骄戒躁，沉着冷静，大胆细心，这几句送给现在的我，也送给各位朋友，希望你们不要像我一样，在小问题上被找茬，从而导致前面的很多功劳而被扣分，这样的次数多了，就意味着要被抹杀了。
唠叨了这么多，今天早点睡吧，明天好心情，好身体，继续fighting。
</content>
    </entry>
    
     <entry>
        <title>Windows下如何编译使用boost？</title>
        <url>https://cppfans.org/1317.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>boost</tag><tag>命令行</tag><tag>安装编译</tag><tag>编译工具</tag>
        </tags>
        <content type="html"> 最近在看boost::asio的东西，所以必须要用到boost库，下载了一个，所以与大家分享下boost库的编译方法。
本方法应该适用于boost的任何版本，应该适用于任何C&#43;&#43;编译器(VC6.0可能对某些库不支持，因为模板的原因)，因为Linux没怎么用，所以只是分享下windows上的编译方法。
1.下载boost
从boost官网( http://www.boost.org )上下载最新的boost版本，现在最新是1.49版本，解压到自定义目录(为了后面好说明，这里假设为boost_1_49)
2.编译安装boost
boost_1_49目录下会有一个bootstrap.bat批处理，可以直接点击它，会在 boost_1_49\tools\build\v2 文件夹下生成两个exe，b2.exe；bjam.exe，拷贝这两个文件到boost_1_49目录下。从cmd命令进入到boost_1_49路径下，如果你不知道如何编译，可以输入&amp;ndash;help查看命令行帮助。
输入如下命令：
b2 toolset=msvc-10.0 --layout=versioned architecture=x86 address-model=64 link=static variant=debug,release threading=multi runtime-link=static --without-python --without-mpi --without-wave --without-graph --without-math --without-serialization stage 使用不同的命令对你使用boost也会产生很大的影响，因为CPU速度和硬盘现在都已经不是大问题了，所以本例中选择了除了不必要库的完全编译，当然了，你时间够，硬盘够，可以完全编译
b2 --toolset=msvc-10 --build-type=complete 解释完以上的命令后，再说完全编译的后果。
1.toolset：表示编译器工具，我安装的是VS2010，所以是msvc-10(如果你是VS2005，可以使用msvc-8.0 VS2008是msvc-9.0)
2.architecture：表示架构，也就是你的CPU架构，x86,x64，因为我安装的是win7 32位，所以使用了x86的架构
3.instruction-set：表示指令集，依然是8086指令集
4.address-model：表示地址长度为32位
5.link：表示生成动态/静态链接库，动态链接库是shared，静态链接库是static，一般都会编译成静态库，因为给出程序的时候打包boost的库会非常庞大
6.variant：表示生成的Debug或者release版本，一般情况下会两种版本都会编译出来的
7.threading：表示单/多线程编译，一般我们的程序都会用到多线程，所以选择了multi
8.runtime-link：表示动态/静态链接C/C&#43;&#43;运行时库(C/C&#43;&#43; Runtime)，我们选择了动态链接
9.without/with：表示不需要编译/需要编译哪些库，一些自己不用的库可以无需编译
10.stage/install：stage表示只生成库文件(DLL和Lib)，install还会生成包含头文件的include目录，推荐使用stage，因为boost_1_49\boost中就是boost库完整的头文件，所以无需再拷贝一份出来。编译出来的库会放在stage文件夹中
这样一份完整的boost库就生成了，剩下就是直接使用到项目中了。
上面的编译指令可以存成一个批处理，这样进入到boost_1_49目录后，只需要执行批处理就可以了，更方便。
(现在看到为什么不推荐使用完全编译了吧，因为完全编译会编译出各种组合的所有情况，需要占用更多的空间和时间，所以建议各位朋友还是放弃了吧)
使用的时候可以直接包含到项目中，然后在对应的文件中包含相应的头文件即可，例如
#include &#34;boost/asio.hpp&#34; 假如您还嫌上面你的方法太麻烦了，可以使用一个懒汉专用小工具boost setup，下载地址为http://www.boostpro.com/download/
这个工具可以帮你下载并编译好，你只需要点击鼠标配置下就可以了，一步步操作如下图：




最后点击Install之后就会编译并安装到你指定的目录，这个够方便吧(不过这个是下载后编译，可能会有点慢)。最后一步就不演示了，因为我还不想用这种方法。
以上就是boost在windows环境下的安装编译方法，boost库可以说是现在最强大的C&#43;&#43;类库了，你想要的任何功能都有，我认为每一个C/C&#43;&#43;程序员都应该学习的。
</content>
    </entry>
    
     <entry>
        <title>[开发工具]详解Visual Stdio之编译后事件</title>
        <url>https://cppfans.org/1315.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>VS2010</tag><tag>编译后事件</tag>
        </tags>
        <content type="html"> 用VS做开发，通常最痛苦的事情就是配置工程了，建各种目录结构，加入各种库头文件和Lib，输出路径，编译后事件等等，说起来都很麻烦。
今天主要想说一下编译后事件，因为其他的配置看着宏就可以配出来，而编译后事件还需要写一点点批处理，所以着重写一下，如果别的不会配置，大家可以留言说明，我会补上去。
 注意：
在VS2005版本中，工程属性可以直接按 Alt &#43; F7就可以打开，VS2008没用过，直接到2010的，VS2010是用 Alt &#43; Enter才可以打开属性，不过注意是当前选中项的属性，所以打开这个还是比较麻烦的，需要自己选中，而且自己也没改这个快捷键。
 工程属性打开后，后面列表中有一个生成事件，如下图所示：

其中命令行就是编译后要执行的操作，一般我们都会拷贝编译后的exe或者其他编译出的文件到一个指定的目录，以方便我们使用。
给出一个简单的例子，我的工程中的配置
if not exist &#34;$(ProjectDir)..\Bin\&#34; md &#34;$(ProjectDir)\..\Bin\&#34; xcopy &#34;$(TargetDir)$(TargetFileName)&#34; &#34;$(ProjectDir)..\Bin\&#34; 这个意思是如果不存Bin文件夹，创建Bin文件夹，然后拷贝输出路径中的编译文件拷贝到Bin路径下，都是一些批处理的命令，批处理大家不了解可以直接查询或者在cmd下输入help查看。
编译前事件和预链接事件没用到，因为项目中也没有用到，看了一些公司的代码，貌似都没有用到，以后用到了有经验了在介绍吧。
其他的关于VS工具使用的问题，大家请留言说明，如果较多的话，会开一个页面专门讲解的。
</content>
    </entry>
    
     <entry>
        <title>[网络开发]RakNet文档翻译(3)——Creating Packets</title>
        <url>https://cppfans.org/1314.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>RakNet</tag><tag>文档</tag><tag>翻译</tag>
        </tags>
        <content type="html"> 如何将你的数据编码到一个数据包中？
运行RakNet的系统通过人们所熟知的数据包进行通讯，实际上所有在Internet上运行的系统都如此。更准确的说，在UDP协议下，它用的是数据报。每一个通过RakNet创建的数据报中都包含了一条或者多条信息。消息可以是通过你创建的，例如位置信息，血量信息，或者其他通过RakNet内部创建的，例如ping消息。按照惯例，消息的第一个字节包含了一个0-255之间的数字标示符，它被用来标识消息的类型。RakNet已经在自己内部或者为插件使用了大量消息，这些可以在MessageIdentifiers.h文件中看到。
这个例子中，我们放置了一个定时炸弹在游戏里，我们需要以下的数据：
1.炸弹的位置信息，包含三个浮点数，x,y,z,你可能有自己定义的可以替代三个浮点数的向量。
2.一些所有系统都可以访问炸弹的方法。NetworkIDObject类是一个非常好的方法。让我们假设一个炸弹类继承自NetworkIDObject类。然后我们需要存储炸弹的NetworkID(更多的信息请查看Receiving Packets, Sending Packets, 后面会讲到)。
3.谁拥有这个炸弹。这样我们就知道有人踩中了它，该给谁积分。创建引用到玩家身上，最好是系统内存地址，这样就可以通过GetExternalID()来获得改内存地址，也就是拥有者。
4.当这个炸弹被放置后，这个炸弹会在我们倒计时10秒钟后自动爆炸，因此获得正确的时间是非常重要的，这样就不会出现在不同的电脑上爆炸时间不同的问题。幸好RakNet已经有了TimeStamping来处理这个问题。
&amp;nbsp;
使用一个结构体或者字节流？
任何你想发送的数据最终都会变成字节流发送，将你的数据变成字节流有两种简单的方法。一种是创建一个结构体然后将它转化为(char*)，另一种方法是使用内建的BitStream类。
第一种方法的优点是改变结构体非常容易，同时你也可以确切的看到你想要发送的数据。由于发送者和接收者都可以共享源文件中定义的结构体，所以可以避免转化错误。同样也没有让数据乱序，也不会出现使用错误的数据类型。缺点是你经常不得不修改结构体并且重编译许多文件。这样你就失去了可以总是用字节流类来自动执行的便利，同时Raknet不能自动为结构体成员转化字节序。(译者注：网络传输字节序与内存字节序是相反的，所以发送的时候需要转化一下。)
第二种方法的优点是你不需要改变任何外部文件。简单的创建字节流，写入你想要发送的任何排序的数据，然后发送它。可以使用“压缩”版本的读写方法来写入较少的比特数据，例如它写入bool值，只需要一个比特位。当某些情况下是true或者false，你可以动态的写入数据。使用Serialize(), Write()或者Read()写入，BitStream可以自动将数据成员转化为网络字节序。BitStream的缺点是你现在使用它很容易犯错误，比如读写的方法不完全相同，错误的排序，错误的数据类型，或者其他错误。
我们将要使用两种方法来创建数据包。
&amp;nbsp;
用结构体创建数据包
正如我可能前面提到的，RakNet有一个标识数据包类型的约定惯例。数据段的第一个字节是一个单字节枚举，它标识了数据包的类型，接下来是数据传输。数据包中包含了一个时间戳，第一个字节包含了ID_TIMESTAMP，接下来的4个字节是真正的时间戳值，然后下一个字节是数据包类型的标识，接下来才是真正传输的数据。
没有时间戳的情况
#pragma pack(push, 1) struct structName { unsigned char typeId; // 数据类型 // 你的数据 }; #pragma pack(pop) 注意 #pragma pack( push, 1 ) #pragma pack( pop )，他强制你的编译器(在本例子中是VC&#43;&#43;)，将结构体按照1字节对齐。检查你的编译器文档学习更多。
&amp;nbsp;
有时间戳的情况
#pragma pack(push, 1) struct structName { unsigned char useTimeStamp; // 赋值ID_TIMESTAMP给它 RakNet::Time timeStamp; // 通过RakNet::GetTime()获得系统时间或者其他返回类似值的函数 unsigned char typeId; // 数据包类型 // 你的数据 }; #pragma pack(pop) 注意：当发送数据时，RakNet假设时间戳是网络字节序的。你应该使用BitStream::EndianSwapBytes()函数将时间戳数据进行转序。在接受时间戳数据的系统上，使用
if ( bitSteam-&amp;gt;DoEndianSwap() ) bitSteam-&amp;gt;ReverseBytes( timeStamp, sizeof( timeStamp ) ); 如果使用的是BitSteam这个步骤可以省略。
填充数据包，对于我们的定时炸弹，我们想试用有时间戳的方法。因此最终的结果看起来应该如下所示：
#pragma pack(push, 1) struct structName { unsigned char useTimeStamp; // 赋值ID_TIMESTAMP RakNet::Time timeStamp; // 通过RakNet::GetTime()获得系统时间 unsigned char typeId; // 一个自定义的枚举类型，该枚举定义在 MessageIdentifiers.h最后，例如ID_SET_TIMED_MINE float x,y,z; // 炸弹的坐标 NetworkID networkId; // 炸弹的网络ID，作为一种通用的方法来制定不同计算机上的炸弹 SystemAddress systemAddress; // 拥有该炸弹玩家的系统地址 }; #pragma pack(pop) 像我上面的注释写到，我们必须定义一个自己数据包的枚举，当数据流到达接收函数时，我们就知道我们关注的数据包是哪一个了。你应该从ID_USER_PACKET_ENUM开始定义枚举，就像下面的例子：
//定义你自己的枚举 enum { ID_SET_TIMED_MINE = ID_USER_PACKET_ENUM, // 更多的枚举 }; 注意：结构体中不应该直接或者间接包含指针。
结构体或者类中包含指针貌似是一个普遍的错误，人们认为指向数据的指针应该可以在网络中被发送。也不是没有这种情况，它会被当做一个指针地址被发送出去的。
&amp;nbsp;
嵌套结构体
使用嵌套结构体没有任何问题，不过请保持第一个字节总是决定了数据包的类型。
#pragma pack(push, 1) struct A { unsigned char typeId; // ID_A }; struct B { unsigned char typeId; // ID_A }; struct C // Struct C is of type ID_A { A a; B b; } struct D // Struct D is of type ID_B { B b; A a; } #pragma pack(pop) 使用字节流来创建数据包
我们继续使用上面的炸弹例子，使用字节流将他发送出去，我们使用与前面相同的数据。
MessageID useTimeStamp; // 将ID_TIMESTAMP赋值给它 RakNet::Time timeStamp; // 使用RakNet::GetTime()获得的系统时间 MessageID typeId; // 这个赋值给一个类型，在ID_USER_PACKET_ENUM后添加，让我们叫它ID_SET_TIMED_MINE useTimeStamp = ID_TIMESTAMP; timeStamp = RakNet::GetTime(); typeId=ID_SET_TIMED_MINE; Bitstream myBitStream; myBitStream.Write(useTimeStamp); myBitStream.Write(timeStamp); myBitStream.Write(typeId); // 假设我们已经有了一个Mine* mine对象 myBitStream.Write(mine-&amp;gt;GetPosition().x); myBitStream.Write(mine-&amp;gt;GetPosition().y); myBitStream.Write(mine-&amp;gt;GetPosition().z); myBitStream.Write(mine-&amp;gt;GetNetworkID()); // 这个是结构体中的NetworkID networkId myBitStream.Write(mine-&amp;gt;GetOwner()); // 这个是结构体中的系统地址 如果哦我们想将myBitStream发送到RakPeerInterface::Send，这时候它会在内部被转化为结构体。现在让我们试着做一点改进。因为一些原因让我们假设定时炸弹的坐标为0,0,0。我们可以替换为下面的。
MessageID useTimeStamp; // 将ID_TIMESTAMP赋值给它 RakNet::Time timeStamp; // 使用RakNet::GetTime()获得的系统时间 MessageID typeId; // 这个赋值给一个类型，在ID_USER_PACKET_ENUM后添加，让我们叫它ID_SET_TIMED_MINE useTimeStamp = ID_TIMESTAMP; timeStamp = RakNet::GetTime(); typeId=ID_SET_TIMED_MINE; Bitstream myBitStream; myBitStream.Write(useTimeStamp); myBitStream.Write(timeStamp); myBitStream.Write(typeId); // 假设我们已经有了一个Mine* mine对象 // 如果炸弹的坐标是0,0,0，使用一位数据来代表这个情况 if (mine-&amp;gt;GetPosition().x==0.0f &amp;&amp; mine-&amp;gt;GetPosition().y==0.0f &amp;&amp; mine-&amp;gt;GetPosition().z==0.0f) { myBitStream.Write(true); } else { myBitStream.Write(false); myBitStream.Write(mine-&amp;gt;GetPosition().x); myBitStream.Write(mine-&amp;gt;GetPosition().y); myBitStream.Write(mine-&amp;gt;GetPosition().z); } myBitStream.Write(mine-&amp;gt;GetNetworkID()); // 这个是结构体中的NetworkID networkId myBitStream.Write(mine-&amp;gt;GetOwner()); // 这个是结构体中的系统地址 这个方法在网络传输中可以节省3个float，而是用1位数据代替。
&amp;nbsp;
通常的错误
当用bitstream写第一个字节的时候，必须转化为MessageID或者 unsigned char类型，如果你仅是直接写入枚举数据类型，那将会是一个整数(4字节)
正确的方法是：
bitStream-&amp;gt;Write((MessageID)ID_SET_TIMED_MINE); 错误的方法是：
bitStream-&amp;gt;Write(ID_SET_TIMED_MINE); 第二种情况下，RakNet中读取出来的第一个字节是，这个是为ID_INTERNAL_PING保留的，千万记住。
&amp;nbsp;
写入字符串
可以使用BitStream的数组来写入字符串。一种是先写入长度，然后再写入数据，例如：
void WriteStringToBitStream(char *myString, BitStream *output) { output-&amp;gt;Write((unsigned short) strlen(myString)); output-&amp;gt;Write(myString, strlen(myString); } 解码是类似的，然而，效率却不高。RakNet存在一个内建的StringCompressor函数&amp;hellip;stringCompressor。它是一个全局实例，使用它写入字串变成了：
void WriteStringToBitStream(char *myString, BitStream *output) { stringCompressor-&amp;gt;EncodeString(myString, 256, output); } 不仅是字符串编码，所以数据包嗅探器不是很容易读取字符串，而且它压缩了字符串。解码一个字串可以使用：
void WriteBitStreamToString(char *myString, BitStream *input) { stringCompressor-&amp;gt;DecodeString(myString, 256, input); } 在这个例子里，256是读写的最大长度。在EncodeString中，如果你的字串长度小于256，他将会写入整个字串。如果超过256个字符，它会被截短，它将会被当成一个256个字符的数据进行解码，包含结束符。
RakNet还有一个字符串类，RakNet::RakString，在RakString.h中可以找到
RakNet::RakString rakString(&#34;The value is %i&#34;, myInt); bitStream-&amp;gt;write(rakString); RakString比std::string约快3倍。
RakString支持Unicode
&amp;nbsp;
程序员们请注意：
1.可以直接将结构体写入BitsStream，只需要简单的将他转化为(char*)。使用memcpy拷贝你的结构体。在结构体中，因为不能包含指针，所以不允许将指针写入bitstream。
如果你经常使用字符串，你可以使用StringTable代替。它和StringCompressor类似，但是可以发送代表一个已知字串的两字节数据。
</content>
    </entry>
    
     <entry>
        <title>[网络开发]RakNet文档翻译(2)——Connecting</title>
        <url>https://cppfans.org/1299.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>Connect</tag><tag>RakNet</tag><tag>翻译文档</tag>
        </tags>
        <content type="html">  Connecting to other systems &amp;nbsp;
找到连接的对象 下面是5种连接到其他系统的方法：
1.直接通过IP地址(前提是你已经知道该IP)
2.LAN广播
3.使用云服务器或者云客户端插件
4.使用大厅服务器或者房间插件(译者注：类型与游戏大厅和游戏房间的模式，想想QQ棋牌游戏)
5.使用DirectoryServer.php
方法1：直接使用IP地址 从编码的角度来说，最简单最容易的方法是硬编码的IP地址或者域名或者给出一个GUI要求用户输入他们相连接到其他系统的IP地址，大部分例子使用此方法。回顾网络游戏刚刚出现的时候使用此方法，也是当时唯一可用的方法。
 优点：
 对程序员或者美工来说很简单，GUI界面可以很简单 如果IP地址或者域名是固定的，例如你运行了一个专用服务器，这是一个正确的解决方案。  缺点：
 不够灵活 用户只能与他们认识的人玩游戏   注意：在同一台电脑或者相同的应用程序，可以使用127.0.0.1或者 localhost连接到另外一个RakPeer实例。
方法2：局域网广播 RakNet支持广播一个数据包找到本地局域网内其他系统的功能，使用可选的数据包发送和检测应用程序，LANServerDiscovery例子展示了这个技术。
在RakPerrInterface.h中，Ping函数可以试下如下个功能
rakPeer-&amp;gt;Ping( &#34;255.255.255.255&#34;, REMOTE_GAME_PORT, onlyReplyOnAcceptingConnections ); REMOTE_GAME_PORT可以是你关心的应用程序运行在其他系统上的任何端口。onlyReplyOnAcceptingConnections 是一个标志其他系统是否应该答复的布尔值，即使你没有连接到其他系统上的可用连接。
开放系统将会用ID_UNCONNECTED_PONG，看看下面的例子：
if (p-&amp;gt;data[0]==ID_UNCONNECTED_PONG) { RakNet::TimeMS time; RakNet::BitStream bsIn(packet-&amp;gt;data,packet-&amp;gt;length,false); bsIn.IgnoreBytes(1); bsIn.Read(time); printf(&#34;Got pong from %s with time %i\n&#34;, p-&amp;gt;systemAddress.ToString(), RakNet::GetTime() - time); } 为了发送用户自定义数据，调用 RakPeer::SEtOfflinePingResponse( customUserData, lengthInBytes ); RakNet将会拷贝传给他的数据，同时返回值追加到ID_UNCONNECTED_PONG。(译者注：猜想是以位与的方式)
注意：在RakPeer.cpp中定义了一个硬编码的MAX_OFFLINE_DATA_LENGTH长度，它限制了用户数据长度。如果你的数据超过这个定义，修改该值并且重编译。
 优点：
 你可以在程序启动的时候自动的加入游戏，不需要GUI或者其他用户交互 在局域网内发现游戏的最佳方式  缺点：
 在一般的Internet网络上没用 不如轻量级数据库插件灵活。   方法3：使用 云服务器/云客户端 插件 云服务器/云客户端不需要修改可直接作为服务器目录。
方法4：使用大厅服务器或者房间插件 大厅服务器为玩家交互和启动游戏提供了一个数据库驱动服务。它提供了一些功能，例如朋友，配对，邮件，排名，即时通信，快速匹配，房间和房间调整。
LobbyServerTest和LobbyClientTest例子展示了如何使用该功能。
 优点：
 对于加油游戏的玩家来说比较灵活 允许用户在启动游戏之前进行互动 建立联系 支持多个标题(称号)  缺点：
 需要一个单独并且专用的服务器来承载该插件，并且服务器需要数据库支持 相比一个简单的游戏列表来说，该功能需要一个相对较大的并且复杂，需要在时间和编程上投入更多。   方法5：DirectoryServer.php DirectoryServer.php 和相关的代码可以在Samples\PHPDirectoryServer2中找到。通过你的Web服务器去存储一个游戏的上传，同时该游戏是基于字串的信息，这种给出游戏列表的方法比较廉价。要获得更多的信息，请查看该功能的用户手册。
 优点：
 不需要一台专用的服务器，只需要一个网页 缺点：  不够灵活
 有时候不可用(可能需要多次查询请求)   尝试启动链接 一旦你知道了你要连接到的远程系统的IP地址，使用RakPeerInterface::Connect()尝试启动异步的连接，连接参数如下：
ConnectionAttemptResult Connect( const char* host, unsigned short remotePort, const char *passwordData, int passwordDataLength, PublicKey *publicKey=0, unsigned connectionSocketIndex=0, unsigned sendConnectionAttemptCount=6, unsigned timeBetweenSendConnectionAttemptsMS=1000, RakNet::TimeMS timeoutTime=0 ) ;  host 是一个IP地址或者域名 remotePort 是一个远程系统监听的端口，你传递给Startup()函数的端口 passwordData 是随着连接请求发送可选的二进制数据。如果该数据与传递给RakPeerInterface::SetPassword()函数的参数内容不匹配，远程系统会回应ID_INVALID_PASSWORD passwordDataLength是passwordData的长度，单位是Byte publicKey是远程系统上一个传递给InitializeSecurity()函数的公共键值。如果你不想使用，传0值 connectionSocketIndex是一个传递给RakPeer::Startup()中确定要发送的socket描述符数组中的索引. sendConnectionAttempyCount是在放弃连接之前尝试发送的数据包次数。这是用于三种不同MTU大小的检测。默认值为12以为着每个MTU发送4次，这应该适合于任何形式的丢包了。值越低意味着收到ID_CONNECTION_ATTEMPT_FAILED越快。 timeBetweenSendConnectionAttemptsMS是指发送下一个连接尝试的间隔毫秒数。4倍的ping值是比较好的。 timeOutTime是这次特别的连接中一条消息丢失远程系统之前等待的毫秒数，(译者注：其实就是无响应超时时间)。默认值为0意味着使用从SetTimeOutTime()中得到的全局值。 Connect()如果尝试连接成功则会返回CONNECTION_ATTEMPT_STARTED，其他返回值都是失败的。  注意：Connect()函数返回true并不意味着你已经连接上了。如果连接成功你会收到ID_CONNECTION_REQUEST_ACCEPTED 消息，否则你会收到其他的错误消息。
连接消息作为Packet::data结构的第一个字节返回 连接关闭: ID_DISCONNECTION_NOTIFICATION, ID_CONNECTION_LOST
新的连接: ID_NEW_INCOMING_CONNECTION, ID_CONNECTION_REQUEST_ACCEPTED
尝试连接失败: ID_CONNECTION_ATTEMPT_FAILED, ID_REMOTE_SYSTEM_REQUIRES_PUBLIC_KEY, ID_OUR_SYSTEM_REQUIRES_SECURITY, ID_PUBLIC_KEY_MISMATCH, ID_ALREADY_CONNECTED, ID_NO_FREE_INCOMING_CONNECTIONS, ID_CONNECTION_BANNED, ID_INVALID_PASSWORD, ID_INCOMPATIBLE_PROTOCOL_VERSION, ID_IP_RECENTLY_CONNECTED
ID_CONNECTION_ATTEMPT_FAILED故障排除 ID_CONNECTION_ATTEMPT_FAILED是通用的消息，他以为这没有建立与远程系统的沟通。可能的原因如下：
 IP地址错误 对方的系统可能没有运行RakNet或者没有调用RakPeerInterface::Startup() 远程系统已经开始了RakNet，但是没用调用RakPeerInterface()::SetMaximumIncomingConnections() 远程系统的防火墙阻止了你所选择端口上的UDP包 远程系统上的路由器阻止了你所选择端口上的UDP包，查看NAT Punchthrough插件解决该问题 在Windows Vista，网络驱动安全服务有时候会断掉UDP，并不是针对Raknet的，而是针对所有UDP连接，甚至是DirectPlay。该服务应该被回滚或者不要安装。 开启了安全连接，并且你的系统安全检查失败 你的IP地址在RakPeerInterface::AddToBanList()函数中被禁用了。注意一些插件，例如有自动禁用IP地址功能的Connection filter插件。   假设你已经连接上了，请转向下一部分:Createing Packets
 </content>
    </entry>
    
     <entry>
        <title>[源码分享]Aion模拟器</title>
        <url>https://cppfans.org/1294.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>Aion</tag><tag>模拟器</tag><tag>网游</tag>
        </tags>
        <content type="html"> 永恒之塔游戏介绍：
 通向Abyss世界的“永恒之塔”被强大的恶魔打开，囚禁在Abyss世界的龙类被唤醒，开始了它们对世界的报复。一场围绕在天使，恶魔和龙类之间的史诗大战风雨欲来。为完成拯救世界的使命，玩家踏上漫漫征途……
你可能会是魔族的一员&amp;hellip;也可能会是天族的一员&amp;hellip;&amp;hellip;..
但将幻想世界用自己的意志来变动是多么伟大的事..而这，将由你来决定！
飞吧&amp;hellip;.永恒之歌..在歌颂着你&amp;hellip;.
飞吧&amp;hellip;.永恒之泉..在照耀着你的未来&amp;hellip;..
飞来吧&amp;hellip;..永恒之塔：Aion　等你改变世界！
“相信天使，相信魔鬼，相信《Aion》。”在《Aion》的世界中，玩家可以选择两个派系：“The Choosen”（神佑）和“The Fallen”（堕落）……
《Aion：The Tower Of Eternity》是韩国第一网游巨头NCsoft投入了所有韩国国内网游研发精英，精心打磨制作的新一代奇幻MMORPG，是一款集NCsoft开发实力之大成的产品。
《Aion》拥有与《天堂II》等现行MMORPG完全不同的风格。开发小组力图在游戏中实现“让玩家的行动来左右世界的变化，然后世界的变化再反过来影响玩家的这种循环关系”、“三个种族纷争的世界”，和“不同于科幻小说以及幻想风格的原创世界”。
不同于科幻、幻想风格的奇异世界——
游戏的设计者们提出了很多构想，希望能够缔造出一个不同以往的世界。既不是科幻风格也不是幻想型风格，但是也不会过于怪异而让人无法理解。这一点，我们可以通过游戏截图、原画以及视频去仔细体会。
画面与表现——
NCsoft的制作团队使《Aion》继承了韩国网络游戏一贯华丽的画面与爽快的战斗感，同时糅合了其他网络游戏的成功元素，例如，在《Aion》中游戏角色可以蹲、站、跳跃(有翻跟头效果)，可以长出翅膀在空中飞行，可以纯鼠标操作或使用键盘W A S D……是的，魔兽世界的玩家们尤其熟悉这个键位。
玩家与世界的互动影响——
当前已有的网络游戏，包括《天堂II》在内，玩家都受制于开发者缔造的世界。但是在《Aion》之中，玩家和游戏之间的互动能够改变游戏世界。
举例说明，譬如一个村庄里面只有两个店铺，如果前往其中一个店铺的玩家特别多的话，这家店铺可以买的东西将会越来越多，欣欣向荣。而另一间就会随着时间的推移而不断缩小规模，最后关门大吉。此外，游戏的地图扩展，也不再只依靠补丁或资料片，玩家可以通过自己的行动去探索新的区域，甚至自己建造地下城..
在这样的设计下，每个玩家将能够享受变化中的游戏世界带来的乐趣，也会带给世界更多的变化，玩家将决定自己的命运。同时，未来《Aion》各个服务器的状况也将会不一样，将会由于玩家行动的不同而呈现截然不同的游戏世界与游戏环境……
三个种族纷争的世界——
NCsoft吸收了《魔兽世界》等游戏在阵营势力设定上的成功经验，为《Aion》设计了“天族”、“魔族”与“龙族”，故事主要围绕这三者的战争展开，可以实现大规模的“种族vs种族”。玩家可以成为天族或者魔族，而龙族就是怪物以及NPC。
但《Aion》中的三个种族并非始终敌对的。天族和魔族可以携手来攻击龙族，也可以收纳NPC当作同伴，缩小敌对玩家的领土范围。游戏并不是单纯的PvP那么简单，如何处置第三势力将是《Aion》的大规模PvP关键所在。在这样的设定下，《Aion》中的PvP战斗将变得错综复杂——显然，平衡性将是开发团队将解决的重要课题。
此外，《Aion》力图开创PvPvE战斗的新模式，包括设计多种崭新形态的怪物，用前所未见的方式去攻击玩家，使玩家在游戏中的冒险富有新鲜的体验感……
 &amp;nbsp;
下载地址：(因为网盘上传太慢，所以将文件压缩为3个压缩包，解压后大概700M)
1.yunfile网盘下载
下载： AionSvn.7z.001
下载： AionSvn.7z.002
下载： AionSvn.7z.003
2.千军万马网盘下载
下载：AionSvn.7z.001
下载：AionSvn.7z.002
下载：AionSvn.7z.003
&amp;nbsp;
免责声明：以上资源来自网络，与本博客和本人无关，资源仅供学习所用，请在下载后24小时内删除，谢谢合作。
</content>
    </entry>
    
     <entry>
        <title>[网络开发]IOCP完整例子</title>
        <url>https://cppfans.org/1267.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>IOCP</tag><tag>Socket</tag><tag>网络，C&#43;&#43;</tag>
        </tags>
        <content type="html">  本文是我在学习IOCP的时候，第一次写一个完整的例子出来，当然了，参考了CSDN上一些朋友的博客，大部分都是按照他们的思路写的，毕竟我是初学者，参考现成的学起来比较快。当然了，真正用到项目中的IOCP肯定不止这么简单的，还有内存池，环形缓冲区，socket连接池等高端内容，后面我会参考一些例子，写出一个完整的给大家看。
 /************************************************************************ FileName:iocp.h Author :eliteYang http://www.cppfans.org ************************************************************************/ #ifndef __IOCP_H__ #define __IOCP_H__ #include #include #define DefaultPort 20000 #define DataBuffSize 8 * 1024 typedef struct { OVERLAPPED overlapped; WSABUF databuff; CHAR buffer[ DataBuffSize ]; DWORD bytesSend; DWORD bytesRecv; }PER_IO_OPERATEION_DATA, *LPPER_IO_OPERATION_DATA; typedef struct { SOCKET socket; }PER_HANDLE_DATA, *LPPER_HANDLE_DATA; #endif 前面讲过IOCP里面一个很重要的东西就是IO重叠了，所以结构体里有一个OVERLAPPED结构。
/************************************************************************ FileName:iocp.cpp Author :eliteYang http://www.cppfans.org ************************************************************************/ #include &#34;iocp.h&#34; #include using namespace std; #pragma comment( lib, &#34;Ws2_32.lib&#34; ) DWORD WINAPI ServerWorkThread( LPVOID CompletionPortID ); void main() { SOCKET acceptSocket; HANDLE completionPort; LPPER_HANDLE_DATA pHandleData; LPPER_IO_OPERATION_DATA pIoData; DWORD recvBytes; DWORD flags; WSADATA wsaData; DWORD ret; if ( ret = WSAStartup( 0x0202, &amp;wsaData ) != 0 ) { std::cout &amp;lt;&amp;lt; &#34;WSAStartup failed. Error:&#34; &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; std::endl; return; } completionPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, 0 ); if ( completionPort == NULL ) { std::cout &amp;lt;&amp;lt; &#34;CreateIoCompletionPort failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } SYSTEM_INFO mySysInfo; GetSystemInfo( &amp;mySysInfo ); // 创建 2 * CPU核数 &#43; 1 个线程 DWORD threadID; for ( DWORD i = 0; i &amp;lt; ( mySysInfo.dwNumberOfProcessors * 2 &#43; 1 ); &#43;&#43;i ) { HANDLE threadHandle; threadHandle = CreateThread( NULL, 0, ServerWorkThread, completionPort, 0, &amp;threadID ); if ( threadHandle == NULL ) { std::cout &amp;lt;&amp;lt; &#34;CreateThread failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } CloseHandle( threadHandle ); } // 启动一个监听socket SOCKET listenSocket = WSASocket( AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED ); if ( listenSocket == INVALID_SOCKET ) { std::cout &amp;lt;&amp;lt; &#34; WSASocket( listenSocket ) failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } SOCKADDR_IN internetAddr; internetAddr.sin_family = AF_INET; internetAddr.sin_addr.s_addr = htonl( INADDR_ANY ); internetAddr.sin_port = htons( DefaultPort ); // 绑定监听端口 if ( bind( listenSocket, (PSOCKADDR)&amp;internetAddr, sizeof( internetAddr ) ) == SOCKET_ERROR ) { std::cout &amp;lt;&amp;lt; &#34;Bind failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } if ( listen( listenSocket, 5 ) == SOCKET_ERROR ) { std::cout &amp;lt;&amp;lt; &#34;listen failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } // 开始死循环，处理数据 while ( 1 ) { acceptSocket = WSAAccept( listenSocket, NULL, NULL, NULL, 0 ); if ( acceptSocket == SOCKET_ERROR ) { std::cout &amp;lt;&amp;lt; &#34;WSAAccept failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } pHandleData = (LPPER_HANDLE_DATA)GlobalAlloc( GPTR, sizeof( PER_HANDLE_DATA ) ); if ( pHandleData = NULL ) { std::cout &amp;lt;&amp;lt; &#34;GlobalAlloc( HandleData ) failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } pHandleData-&amp;gt;socket = acceptSocket; if ( CreateIoCompletionPort( (HANDLE)acceptSocket, completionPort, (ULONG_PTR)pHandleData, 0 ) == NULL ) { std::cout &amp;lt;&amp;lt; &#34;CreateIoCompletionPort failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } pIoData = ( LPPER_IO_OPERATION_DATA )GlobalAlloc( GPTR, sizeof( PER_IO_OPERATEION_DATA ) ); if ( pIoData == NULL ) { std::cout &amp;lt;&amp;lt; &#34;GlobalAlloc( IoData ) failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } ZeroMemory( &amp;( pIoData-&amp;gt;overlapped ), sizeof( pIoData-&amp;gt;overlapped ) ); pIoData-&amp;gt;bytesSend = 0; pIoData-&amp;gt;bytesRecv = 0; pIoData-&amp;gt;databuff.len = DataBuffSize; pIoData-&amp;gt;databuff.buf = pIoData-&amp;gt;buffer; flags = 0; if ( WSARecv( acceptSocket, &amp;(pIoData-&amp;gt;databuff), 1, &amp;recvBytes, &amp;flags, &amp;(pIoData-&amp;gt;overlapped), NULL ) == SOCKET_ERROR ) { if ( WSAGetLastError() != ERROR_IO_PENDING ) { std::cout &amp;lt;&amp;lt; &#34;WSARecv() failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return; } else { std::cout &amp;lt;&amp;lt; &#34;WSARecv() io pending&#34; &amp;lt;&amp;lt; std::endl; return; } } } } DWORD WINAPI ServerWorkThread( LPVOID CompletionPortID ) { HANDLE complationPort = (HANDLE)CompletionPortID; DWORD bytesTransferred; LPPER_HANDLE_DATA pHandleData = NULL; LPPER_IO_OPERATION_DATA pIoData = NULL; DWORD sendBytes = 0; DWORD recvBytes = 0; DWORD flags; while ( 1 ) { if ( GetQueuedCompletionStatus( complationPort, &amp;bytesTransferred, (PULONG_PTR)&amp;pHandleData, (LPOVERLAPPED *)&amp;pIoData, INFINITE ) == 0 ) { std::cout &amp;lt;&amp;lt; &#34;GetQueuedCompletionStatus failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return 0; } // 检查数据是否已经传输完了 if ( bytesTransferred == 0 ) { std::cout &amp;lt;&amp;lt; &#34; Start closing socket...&#34; &amp;lt;&amp;lt; std::endl; if ( CloseHandle( (HANDLE)pHandleData-&amp;gt;socket ) == SOCKET_ERROR ) { std::cout &amp;lt;&amp;lt; &#34;Close socket failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return 0; } GlobalFree( pHandleData ); GlobalFree( pIoData ); continue; } // 检查管道里是否有数据 if ( pIoData-&amp;gt;bytesRecv == 0 ) { pIoData-&amp;gt;bytesRecv = bytesTransferred; pIoData-&amp;gt;bytesSend = 0; } else { pIoData-&amp;gt;bytesSend &#43;= bytesTransferred; } // 数据没有发完，继续发送 if ( pIoData-&amp;gt;bytesRecv &amp;gt; pIoData-&amp;gt;bytesSend ) { ZeroMemory( &amp;(pIoData-&amp;gt;overlapped), sizeof( OVERLAPPED ) ); pIoData-&amp;gt;databuff.buf = pIoData-&amp;gt;buffer &#43; pIoData-&amp;gt;bytesSend; pIoData-&amp;gt;databuff.len = pIoData-&amp;gt;bytesRecv - pIoData-&amp;gt;bytesSend; // 发送数据出去 if ( WSASend( pHandleData-&amp;gt;socket, &amp;(pIoData-&amp;gt;databuff), 1, &amp;sendBytes, 0, &amp;(pIoData-&amp;gt;overlapped), NULL ) == SOCKET_ERROR ) { if ( WSAGetLastError() != ERROR_IO_PENDING ) { std::cout &amp;lt;&amp;lt; &#34;WSASend() failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return 0; } else { std::cout &amp;lt;&amp;lt; &#34;WSASend() failed. io pending. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return 0; } } std::cout &amp;lt;&amp;lt; &#34;Send &#34; &amp;lt;&amp;lt; pIoData-&amp;gt;buffer &amp;lt;&amp;lt; std::endl; } else { pIoData-&amp;gt;bytesRecv = 0; flags = 0; ZeroMemory( &amp;(pIoData-&amp;gt;overlapped), sizeof( OVERLAPPED ) ); pIoData-&amp;gt;databuff.len = DataBuffSize; pIoData-&amp;gt;databuff.buf = pIoData-&amp;gt;buffer; if ( WSARecv( pHandleData-&amp;gt;socket, &amp;(pIoData-&amp;gt;databuff), 1, &amp;recvBytes, &amp;flags, &amp;(pIoData-&amp;gt;overlapped), NULL ) == SOCKET_ERROR ) { if ( WSAGetLastError() != ERROR_IO_PENDING ) { std::cout &amp;lt;&amp;lt; &#34;WSARecv() failed. Error:&#34; &amp;lt;&amp;lt; GetLastError() &amp;lt;&amp;lt; std::endl; return 0; } else { std::cout &amp;lt;&amp;lt; &#34;WSARecv() io pending&#34; &amp;lt;&amp;lt; std::endl; return 0; } } } } } 整个过程还是类似于最基础的socket连接方式，主要部分就是使用IOCP的两个函数，创建IOCP和检测当前的状态。
大家先凑活看吧，后面本博客会有更精彩的IOCP内容呈现给大家，我也是逐步在学习，大家稍安勿躁。
</content>
    </entry>
    
     <entry>
        <title>[网络开发]Raknet文档翻译(1)——Startup</title>
        <url>https://cppfans.org/1239.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>RakNet</tag><tag>Startup</tag><tag>翻译</tag>
        </tags>
        <content type="html"> 开始Raknet
[cpp]
StartupResult RakPeer::Startup( unsigned short maxConnections, SocketDescriptor *
socketDescriptors,unsigned socketDescriptorCount, int threadPriority );
[/cpp]
第一件你应该做的事情是调用RakpeerInterface::StartUp()函数，Startup()函数将会：
1.生成RakNet Guid，一个RakpeerInterface的唯一实例，你可以通过下面函数得到这个Guid
[cpp]
RakNetGUID g = rakPeer-&amp;gt;GetGuidFormSystemAddress( UNASSIGNED_SYSTEM_ADDRESS );
[/cpp]
2.分配一组可靠的连接点，通过maxConnections参数定义,这个可能是你游戏中最大的玩家个数，你可能需要分配更多的连接点，手动的控制进入游戏的玩家。
3.通过socketDescriptors来创建1个或者多个Socket
在调用Startup()函数之前，通常只有原始的UDP函数可以使用，比如：Ping(), AdvertiseSystem(),SendOutOfBand().
&amp;nbsp;
maxConnections 参数
RakNet预先分配了连接到其他系统的内存，指定的maxConnections 参数作为在本RakPeerInterface实例和其他RakPeerInterface实例之间最大可支持的连接数(包含进出)。注意:如果你想让其他系统连接到你，你必须调用SetMaximunIncomingConnections( value )函数来设置最大进来的连接数，其中value参数不大于maxConnections值。
&amp;nbsp;
socketDescriptors 参数
在95%以上的情况下，你可以如下传递参数，
[cpp]
SocketDescriptor( MY_LOCAL_PORT, 0 );
[/cpp]
对于MY_LOCAL_PORT 参数，如何想运行一个Server或者Peer，你必须为想要运行的Server或者Peer设置一个端口。这个是要传递给Connect()函数的 remotePort(远程端口)。如果要隐形一个客户端，你可以设置一个端口，或者设置为0，让系统自动选择一个没有用到的端口。注意:在Linux系统下设置1000一下的端口必须有管理员权限。尽管一些端口是保留的，但是无法限制你使用，但是请尽量不要使用。请查看：http://www.iana.org/assignments/port-numbers
通常你可以创建一组socket描述符。
[cpp]
SocketDescriptor sdArray[2];
sdArray[0].port=SERVER_PORT_1;
strcpy(sdArray[0].hostAddress, &amp;rdquo;192.168.0.1&amp;rdquo;);
sdArray[1].port=SERVER_PORT_2;
strcpy(sdArray[1].hostAddress, &amp;rdquo;192.168.0.2&amp;rdquo;);
if (rakPeer-&amp;gt;Startup( 32, 30, &amp;amp;sdArray, 2 )
OnRakNetStarted();
[/cpp]
此功能是给高级用户绑定多块网卡设定的功能.例如一块网卡绑定到到Lan后的安全服务器，而另外一块网卡绑定到到Internet，为了访问不同的绑定组，你可以穿衣绑定的索引值给有connectionSocketIndex参数的RakPeerInterface 函数。
IPV6是一个新的网络协议，代替了例如 94.198.81.195 这样的IP地址，你可以使用如fe80::7c:31f7:fec4:27de:14 的地址，4字节的编码方式被16字节的编码方式代替了，所以IPV6用于游戏上不太适合。从正面来说，因为有足够的地址，路由器不需要创建地址映射，所以IPV6不需要NAT穿透。
IPV6默认是不可用的，为了支持IPV6，可以设置 socket的族群为AF_INET6，例如：
[cpp]
socketDescriptor.socketFamily = AF_INET6;
[/cpp]
IPV6只能连接其他IPV6 socket，同样的，默认的IPV4也只能连接到其他的IPV4 socket。
&amp;nbsp;
threadPriority (线程优先级)
对于windows操作系统，这个参数是RakPeer更新线程传递给_beginthreadex()函数的优先级。对于Linux系统，这个参数是传递给pthread_attr_setschedparam()函数,用于pthread_create()函数。默认的参数是 -99999，在windows上意味着使用优先级0(NORMAL_PRIORITY),而在Linux上意味着使用优先级为1000。在windows上默认的优先级就可以了，在Linux上，你需要设置该值为普通线程的优先级的值。
</content>
    </entry>
    
     <entry>
        <title>网络编程系列文章声明</title>
        <url>https://cppfans.org/1237.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 最近一段也算稍微闲下来了，至少没以前那么忙了，对于以前没有写完的raknet的文章开始继续写了。而对于IOCP方面的东西，还在研究，已经参考网上的例子写出来一个了，不过肯定是没法用到项目中去，因为还差很多东西。
ICOP的网络引擎，需要用到的东西，比如：环形缓冲区，内存池，线程池，连接池等东西都才开始接触。
想过使用boost::pool，但是发现过于复杂，所以就作罢，还是自己写一个内存池吧。
以后的博客内容规划如下：
1.RakNet核心内容翻译，将会是一个比较漫长的结果，大概一星期最多两篇吧，发现如果不翻译出来，自己完全没看明白，导致使用的时候会出各种问题
2.RakNet内容翻译的同时，会逐渐给出小例子，配合翻译内容
3.Raknet翻译完后会给一些综合的应用
4.IOCP内容完善，各种模块，例子等
5.完成自己的IOCP网络引擎
6.翻译ZeroMQ文档
7.抽离或者借鉴ZMQ的部分东西，用来做服务器间的通讯
8.将IOCP和raknet或者ZMQ合并，客户端到服务器使用IOCP/raknet，服务器间使用ZMQ，完成一个综合的网络引擎
9.试着将其引用到未来的新项目中
&amp;nbsp;
以上就是今年的大致打算，当然了，博客中肯定还会出现其他的文章，不能老是技术文章，我自己也吃不消啊，这东西不像网络写手有存稿的。
为什么要将IOCP,raknet，zmq联合使用，因为zmq的机制非常好，很多人都推荐说做服务器间的通讯，而且raknet中的BitStream很是犀利，而IOCP最为windows上网络编程最津津乐道的东西，自然是不能少了，所以决定联合起来。
大家可能也发现了，这两天访问博客会出现一些问题，我怀疑是主机资源用干净了，分配不到资源就会出现无法打开等情况，每次回收进程池之后就可以访问了，所以更加确定了是主机的问题，过几天会换一个主机，是一个朋友提供的，质量挺不错的。
谢谢大家的访问，最近几天访问不流畅的问题希望大家原谅。
</content>
    </entry>
    
     <entry>
        <title>[源代码]如何删除svn版本控制文件夹</title>
        <url>https://cppfans.org/1212.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>svn</tag><tag>删除</tag><tag>批处理</tag>
        </tags>
        <content type="html"> 许多时候，我们拿到的代码都是带有版本控制文件的，比如说.svn文件夹，这些文件非常大， 占用了很多硬盘，但是自己删除也很慢，工具下来也不好用，怕出问题，误删等情况，不过批处理就可以很轻松的实现这个功能。
批处理算是一项简单而且实用的语言了，大家都可以写，但是实现的功能确是非常大的，我们一些常见的操作都可以使用批处理来写。
还是直接贴出来删除SVN文件夹的代码吧，后面也会有完整的文件，如果不放心我提供的文件，可以自己拷贝下面代码存为批处理文件。
@echo off :start ::启动过程，切换目录 set pwd=%cd% cd %1 echo 工作目录是：&amp; chdir :input ::获取输入，根据输入进行处理 set source=: set /p source=确定要清楚当前目录下的svn信息吗？[Y/N/Q] set &#34;source=%source:&#34;=%&#34; if &#34;%source%&#34;==&#34;y&#34; goto clean if &#34;%source%&#34;==&#34;Y&#34; goto clean if &#34;%source%&#34;==&#34;n&#34; goto noclean if &#34;%source%&#34;==&#34;N&#34; goto noclean if &#34;%source%&#34;==&#34;q&#34; goto end if &#34;%source%&#34;==&#34;Q&#34; goto end goto input :clean ::主处理过程，执行清理工作 @echo on @for /d /r %%c in (.svn) do @if exist %%c ( rd /s /q %%c &amp; echo 删除目录%%c) @echo off echo &#34;当前目录下的svn信息已清除&#34; goto end :noclean ::分支过程，取消清理工作 echo &#34;svn信息清楚操作已取消&#34; goto end :end ::退出程序 cd &#34;%pwd%&#34; pause &amp;nbsp;
注意：文件夹不要有中文名字，文件夹名字不能有空格，否则不能删除。
保存以上代码为 del_svn.bat，放在想要删除.svn的文件夹里，双击然后输入y即可快速删除，省力又省心。
下载： del_svn.txt
</content>
    </entry>
    
     <entry>
        <title>《水浒无双》内测继续开启，欢迎大家试玩</title>
        <url>https://cppfans.org/1202.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>国战</tag><tag>武神</tag><tag>水浒无双</tag><tag>网游</tag>
        </tags>
        <content type="html">  今天是《水浒无双》内测第一天，总体效果来说还不错，今天大家都很给力，没出什么问题，也算是对玩家的一个交代吧，希望大家继续支持《水浒无双》。
今天的场面挺火爆的，下午我在登录 水泊梁山-&amp;gt;青龙山 的时候，排队人数达到1600多人，兄弟们很给力，依然碰到了 情风逝公会的一些朋友，都是以前天机星翠屏山的朋友，很是亲切。当时情风逝带领着大家取得天机星第一强国，还是很犀利的。这次我玩的是猎人，从此副本打架不求人了，嚯嚯…………
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;
下来和大家分享一些新闻。
 新服！人气爆棚《水浒无双》19：00再增开8组服务器 2012国战网游巅峰之作《水浒无双》无禁忌不删档内测今日已正式拉开帷幕，玩家化身梁山好汉瞬间涌入所有服务器，全线爆满，三十二个内测服务器外加下午15:00紧急增开4组新服均维持爆满状态，无数玩家排队等候游戏，致使玩家高呼要求增开新服，场面可以说是火爆异常！
为了能给玩家们更好的国战体验，《水浒无双》将于今日19：00再度增开2组区服，8组国战服满足玩家们变身好汉的强烈需求！
28日19：00火爆增开新服
电信一区： 一夫当关
【睦南关】
【嘉峪关】
【玉门关】
【山海关】
网通一区：威震天下
【相思林】
【赤松林】
【不归林】
【快活林】
现在完成注册及角色创建，即可参与“百万现金计划”，百元话费、全网VIP特权立即到手！
人气火爆
今日12:00：《水浒无双》刚刚开服就迎来了无数玩家的火热入驻，场面堪称疯狂，全部服务器已经开始排队。
今日15:00：在玩家强烈的呼声下《水浒无双》决定紧急增开电信一区【龙啸九天】4组万人新服。
今日19:00：在36组万人新服火热爆棚的情况下，玩家入驻的意愿依然高涨，为了使更多玩家能够如愿体验游戏，《水浒无双》决定再次增开电信一区【一夫当关】、网通一区【威震天下】共8组万人新服。
火爆变身梁山好汉
 
《水浒无双》先进的“云国战”技术，稳定的“万人跨服”系统完全承载了无数玩家的水浒梦，“跨服国战”、“全自由变身”也已经受到了玩家的肯定，目前游戏在线人数急速攀升，为此我们后续也将继续增开万人新服，给玩家们一个优异的游戏体验环境，同时也请玩家们密切关注《水浒无双》的最新动态。
耗资千万，历时三年，3D引擎开发，梁山原景再现，当红男星钟汉良倾情代言，电视剧《水浒传》好汉扮演者倾情加盟，荣获全国网游界最高奖项金翎奖，数十家权威媒体一致推荐，《水浒无双》将掀起2012年无双国战的狂潮！云国战万人跨服、全自由变身好汉、成人化血腥效果、无双技炫动江湖、踏破山河家族系统，海量玩法相聚《水浒无双》，还有真情馈赠“百万现金”计划，共同开启2012真好汉血战纪元！
 分享一些活动给大家，希望大家不要错过拿超值礼包。
《水浒无双》百万现金计划 1888元无双大礼包立即领取 《水浒无双》公会争霸送现金 百万现金计划送一年的起点会员，QQ会员，迅雷会员，红钻，绿钻，蓝钻，甚至是现金大奖等豪礼，大家只要有角色就可以去领取，每天可以领三次。 公会争霸现金大礼为每周10W元，具体活动规则可以通过上面的链接过去细看。 内测继续开启中，大家有兴趣的可以试玩下，横向对比下《水浒无双》作为一款次时代国战网游大作跟其他网游的区别。大家有想法可以多多交流，欢迎联系。 </content>
    </entry>
    
     <entry>
        <title>[软件]如何使用分布式版本控制工具Git？</title>
        <url>https://cppfans.org/1198.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>git</tag><tag>msysgit</tag><tag>TortoiseGit</tag><tag>分布式</tag><tag>版本控制</tag>
        </tags>
        <content type="html">  Git是一个由林纳斯·托瓦兹为了更好地管理linux内核开发而创立的分布式版本控制／软件配置管理软件。需要注意的是和GNU Interactive Tools，一个类似Norton Commander界面的文件管理器相区分。
Git最初的开发动力来自于BitKeeper和Monotone[2][3]。Git最初只是作为一个可以被其他前端比如Cogito或StGIT[4]包装的后端而开发的。不过，后来Git内核已经成熟到可以独立地用作版本控制[5]。很多有名的软件都使用Git来进行版本控制[6]，其中有Linux内核、X.Org服务器和OLPC内核开发。
Git -&amp;ndash; The stupid content tracker，傻瓜内容跟踪器。Linux是这样给我们介绍Git的。
Git是用于Linux内核开发的版本控制工具。与常用的版本控制工具CVS、Subversion等不同，它采用了分布式版本库的方式，不必服务器端软件支持，使源代码的发布和交流极其方便。Git的速度很快，这对于诸如Linux kernel这样的大项目来说自然很重要。Git最为出色的是它的合并跟踪（merge tracing）能力。
实际上内核开发团队决定开始开发和使用Git来作为内核开发的版本控制系统的时候，世界开源社群的反对声音不少，最大的理由是Git太艰涩难懂，从Git的内部工作机制来说，的确是这样。但是随着开发的深入，Git的正常使用都由一些友好的脚本命令来执行，使Git变得非常好用，即使是用来管理我们自己的开发项目，Git都是一个友好，有力的工具。现在，越来越多的著名项目采用Git来管理项目开发，例如：wine、U-boot等。
作为开源自由原教旨主义项目，Git没有对版本库的浏览和修改做任何的权限限制，通过其他工具也可以达到有限的权限控制，比如：gitosis, CodeBeamer MR。原本Git的使用范围只适用于Linux / Unix平台，但逐步并成熟了在Windows平台下的使用，主要归功于Cygwin与msysgit环境与TortoiseGit这样易用的GUI工具。其实Git的源代码中已经加入了对Cygwin与MinGW编译环境的支持并被逐步完善，对于Windows使用者是个福音。
 以上介绍摘自维基百科Git。
现在sf上的代码用git的越来越多了，以前安装的TortoiseSVN就歇菜了，所以安装了git，我的电脑用的是win7，自然第一步是要找到git for windows，好在两款git软件适合在windows下使用。
1.TortoiseGit
TortoiseGit和TortoiseSVN类似，是一款有GUI的软件，操作方法和TortoiseSVN类似，只不过将SVN改成了Git，就不多介绍了，它的项目主页介绍的很清楚，有很多截图，相信你看了一定会明白的。
TortoiseGit项目主页：http://code.google.com/p/tortoisegit/
2.msysgit
msysgit这个工具是一款类似于控制台的应用程序，它是与MinGW并存的，你要使用它，必须先安装Cygwin，由于我之前编译代码，已经安装过了，所以就不再安装了。msysgit安装后，会生成一个快捷方式在桌面，打开之后是一个shell程序，里面可以输入需要的命令。
如果你不清楚命令，可以去项目主页查看命令，也可以在shell界面上输入git help git，会带你到msysgit的帮助页面(需要联网)。
不过我们一般最常用到的命令就是clone了，因为要获取代码。
比如说获取OpenVPN的代码，OpenVPN的地址是 git://openvpn.git.sourceforge.net/gitroot/openvpn/openvpn，我们可以输入如下命令获取代码。
.创建一个文件夹：mkdir /d/Project/openvpn
.进入该路径 cd /d/Project/openvpn
.获取代码 git clone git://openvpn.git.sourceforge.net/gitroot/openvpn/openvpn
这样就可以获取到openvpn的代码到d:/Project/openvpn路径下了
msysgit项目地址：http://code.google.com/p/msysgit/
&amp;nbsp;
小结：TortoiseGit使用比较方便，而且不用安装别的环境，建议用惯了TortoiseSVN的朋友使用；msysgit比较接近linux的使用，建议经常用linux或者window上有cygwin环境的朋友使用。不过msysgit是shell界面，在console上打命令不是显得更酷吗？
</content>
    </entry>
    
     <entry>
        <title>C&#43;&#43;使用MySql&#43;&#43;操作数据库实例</title>
        <url>https://cppfans.org/1117.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>MySQL</tag><tag>数据库</tag><tag>连接</tag>
        </tags>
        <content type="html"> 有朋友让帮忙写个C&#43;&#43;修改数据库中用户名密码的工具，因为他是做VPN的，要给很多客户端展示访问速度等，有一个固定的用户名来展示，但是每次给用户试用的是不同的密码，是随机生成的。
所以就想到了用MySql&#43;&#43;这个数据库操作类库，我们项目中也是用这个的，非常好用。
 MySql&#43;&#43;简介：
MySQL&#43;&#43; is a C&#43;&#43; wrapper for MySQL’s C API. It is built around the same principles as the Standard C&#43;&#43; Library, to make dealing with the database as easy as dealing with STL containers. In addition, MySQL&#43;&#43; provides facilities that let you avoid the most repetitive sorts of SQL within your own code, providing native C&#43;&#43; interfaces for these common tasks.
 MySql&#43;&#43;下载地址：
http://tangentsoft.net/mysql&#43;&#43;/ （最新版本是3.1.0）
安装MySql Server在本机上，需要其中的库和头文件来编译，安装过程就不介绍了。
解压Mysql&#43;&#43;后，里面有VS的工程文件，2003、2005、2008，我使用的是VS2010，所以挑了一个最近的2008工程来update。
单独编译mysqlpp工程，因为其他的工程都是例子和测试代码，可以看看，但是没必要编译。
注意：可能会提示mysql_version.h文件无法找到，请打开项目属性配置，看看MySql的配置路径是否正确。
使用其中的 install.hta 文件来拷贝一份 .h .lib .dll文件，都是我们的工程中需要的文件，这样一份完整的MySql&#43;&#43;的静态动态库就准备好了。
在我们的工程中加入头文件和静态库目录（这些大家应该都是轻车熟路的，我就不再赘述了）。
下来就是编写我们的代码来操作数据库了，当然了，在这之前，你的mysql服务要安装好，并且建立一个要使用的数据库和表来操作。
&amp;nbsp;
[cpp]
#include  // 因为要使用socket，所以需要包含socket2.1头文件
#include &amp;ldquo;mysql&#43;&#43;.h&amp;rdquo; // Mysql&#43;&#43;头文件
#include 
#include 
using namespace mysqlpp;
using namespace std;
const DWORD SpaceTime = 20 * 60 * 1000; // 20分钟
const int LEN_NAME = 8;
const char CCH[] = &amp;ldquo;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;rdquo;; // 随机字串字典
// 简单的随机字串生成函数
char* rand_password( char* str, int len )
{
int i = 0, n = 0;
int nLength = strlen( CCH );
for ( i = 0, n = 0; i &amp;lt; LEN_NAME &amp;amp;&amp;amp; n &amp;lt; nLength; &#43;&#43;i, &#43;&#43;n )
{
int x = rand() % ( nLength - 1 );
str[i] = CCH[x];
}
str[ i &#43; 1 ] = &amp;lsquo;&amp;#92;&amp;#48;&amp;rsquo;;
return str;
}
int _tmain(int argc, _TCHAR* argv[])
{
std::cout &amp;lt;&amp;lt; &amp;ldquo;VPN_Modify_MySql_User_Password Tool&amp;rdquo; &amp;lt;&amp;lt; std::endl;
std::cout &amp;lt;&amp;lt; &amp;ldquo;Copyright &amp;copy; eliteYang&amp;rdquo; &amp;lt;&amp;lt; std::endl;
std::cout &amp;lt;&amp;lt; &amp;ldquo;http://www.cppfans.org&amp;quot; &amp;lt;&amp;lt; std::endl;
mysqlpp::Connection _vpnConn;
// 设置数据库编码
_vpnConn.set_option( new mysqlpp::SetCharsetNameOption( &amp;ldquo;utf8&amp;rdquo; ) );
string dbIp, dbUserName, dbPwd, dbName;
cout &amp;lt;&amp;lt; &amp;ldquo;\n\n\nMySql DataBase Info Input&amp;rdquo; &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;ldquo;请输入MySQL服务器IP地址 : &amp;ldquo;;
cin &amp;gt;&amp;gt; dbIp;
cout &amp;lt;&amp;lt; &amp;ldquo;请输入MySql管理员账号 : &amp;ldquo;;
cin &amp;gt;&amp;gt; dbUserName;
cout &amp;lt;&amp;lt; &amp;ldquo;请输入MySql管理员账号密码 : &amp;ldquo;;
cin &amp;gt;&amp;gt; dbPwd;
cout &amp;lt;&amp;lt; &amp;ldquo;请输入MySql数据库名 : &amp;ldquo;;
cin &amp;gt;&amp;gt; dbName;
cout &amp;lt;&amp;lt; &amp;ldquo; 默认端口号为 3306 &amp;rdquo; &amp;lt;&amp;lt; endl;
bool bConnect = _vpnConn.connect( dbName.c_str(), dbIp.c_str(), dbUserName.c_str(), dbPwd.c_str(), 3306 );
if ( !bConnect )
{
cout &amp;lt;&amp;lt; &amp;ldquo;VPN Connect mysql failed! Error: &amp;ldquo; &amp;lt;&amp;lt; _vpnConn.error() &amp;lt;&amp;lt; endl;
system( &amp;ldquo;Pause&amp;rdquo; );
return -1;
}
else
{
cout &amp;lt;&amp;lt; &amp;ldquo;VPN Connect mysql success!&amp;rdquo; &amp;lt;&amp;lt; endl;
}
DWORD timeSlot = timeGetTime();
char szChar[ 256 ] = { 0 };
string strName = &amp;ldquo;123&amp;rdquo;;
cout &amp;lt;&amp;lt; &amp;ldquo;请输入需要定时修改密码的用户名 :&amp;ldquo;;
cin &amp;gt;&amp;gt; strName;
sprintf_s( szChar, &amp;ldquo;select * from vpn_user_info where UserName=%s&amp;rdquo;, strName.c_str() );
while ( true )
{
if ( timeGetTime() - timeSlot &amp;lt; SpaceTime )
{ continue; }
try
{
mysqlpp::Query _query = _vpnConn.query( szChar );
mysqlpp::StoreQueryResult _result = _query.store();
if ( _result.num_rows() != 1 )
{
cout &amp;lt;&amp;lt; &amp;ldquo;UserName[123] repeat, please check&amp;rdquo; &amp;lt;&amp;lt; endl;
timeSlot = timeGetTime();
continue;
}
string strUserName = _result[0][0].c_str();
string strUserPassword = _result[0][1].c_str();
cout &amp;lt;&amp;lt; &amp;ldquo;CurentInfo UserName[ &amp;ldquo; &amp;lt;&amp;lt; strUserName.c_str() &amp;lt;&amp;lt; &amp;ldquo; ] Password[ &amp;ldquo; &amp;lt;&amp;lt; strUserPassword.c_str() &amp;lt;&amp;lt; &amp;ldquo; ]&amp;rdquo; &amp;lt;&amp;lt; endl;
char strTemp[ LEN_NAME &#43; 1 ] = { 0 };
strUserPassword = rand_password( strTemp, LEN_NAME );
char szTemp[ 256 ] = { 0 };
sprintf_s( szTemp, &amp;ldquo;UPDATE vpn_user_info SET Password = &amp;lsquo;%s&amp;rsquo; WHERE UserName = &amp;lsquo;%s&amp;rsquo;;&amp;ldquo;, strUserPassword.c_str(), strUserName.c_str() );
_query &amp;lt;&amp;lt; szTemp &amp;lt;&amp;lt; endl;
_query.execute();
cout &amp;lt;&amp;lt; &amp;ldquo;ModifyUserInfo UserName[ &amp;ldquo; &amp;lt;&amp;lt; strUserName.c_str() &amp;lt;&amp;lt; &amp;ldquo; ] Password[ &amp;ldquo; &amp;lt;&amp;lt; strUserPassword.c_str() &amp;lt;&amp;lt; &amp;ldquo; ]&amp;rdquo; &amp;lt;&amp;lt; endl;
}
catch (const mysqlpp::BadQuery&amp;amp; er)
{
// Handle any query errors
cerr &amp;lt;&amp;lt; &amp;ldquo;Query error: &amp;ldquo; &amp;lt;&amp;lt; er.what() &amp;lt;&amp;lt; endl;
return -1;
}
catch (const mysqlpp::BadConversion&amp;amp; er)
{
// Handle bad conversions
cerr &amp;lt;&amp;lt; &amp;ldquo;Conversion error: &amp;ldquo; &amp;lt;&amp;lt; er.what() &amp;lt;&amp;lt; endl &amp;lt;&amp;lt;
&amp;ldquo;\tretrieved data size: &amp;ldquo; &amp;lt;&amp;lt; er.retrieved &amp;lt;&amp;lt;
&amp;rdquo;, actual size: &amp;ldquo; &amp;lt;&amp;lt; er.actual_size &amp;lt;&amp;lt; endl;
return -1;
}
catch (const mysqlpp::Exception&amp;amp; er)
{
// Catch-all for any other MySQL&#43;&#43; exceptions
cerr &amp;lt;&amp;lt; &amp;ldquo;Error: &amp;ldquo; &amp;lt;&amp;lt; er.what() &amp;lt;&amp;lt; endl;
return -1;
}
}
_vpnConn.disconnect();
system( &amp;ldquo;Pause&amp;rdquo; );
return 0;
}
[/cpp]
里面的异常catch是比较多的，不过有异常捕获总比没有好，出了问题还可以看异常。
以上就是一个完整的使用MySql&#43;&#43;操作数据库的例子，其实可以使用config或者ini配置整个数据库的信息，使用Log4cxx来打印Log，想想还是算了，看来是被项目中整套的库给惯懒了。
Mysql&#43;&#43;中很多值得去看的地方，很好用，封转的很好，当然了，你也可以直接使用MySql的库，也是可以的，不过就没有这么舒服了，主要是MySql&#43;&#43;封装了输入输出流，让整个操作看起来容易了。
以上代码可以编译过，并可以使用，均为本人亲测，如有问题，欢迎交流。
PS：oracle还有一个工具叫MySql Connecter for C&#43;&#43;，这个工具也是很简洁的，但是毕竟太新了，大家还没接受，这个库的优点是非常干净，没有libmysql.lib的C-Lib，不过它里面有一个MySQL C&#43;&#43; Driver是基于JDBC4.0规范事先的，所以不太喜欢，下一篇会用这个库写一个例子给大家看。
</content>
    </entry>
    
     <entry>
        <title>[编程工具]CppCheck代码检测工具</title>
        <url>https://cppfans.org/1101.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>CppCheck</tag><tag>代码</tag><tag>检测</tag>
        </tags>
        <content type="html">  我们在写代码的时候通常会犯两样低级错误，这种低级错误和那种低级错误。在编译的时候可能不会报错，但是在程序运行的时候就会发现很奇怪的结果，莫名其妙，如果不仔细点查找可能就让我们焦头烂额。
其实可能是一个简单的指针没有释放的问题，亦或是一个赋值写错了的问题，而CppCheck这个工具可以为我们的静态代码检测语法错误和内存泄露等问题。
CppCheck简介：
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;
 Cppcheck - A tool for static C/C&#43;&#43; code analysis Overview Cppcheck is an analysis tool for C/C&#43;&#43; code. Unlike C/C&#43;&#43; compilers and many other analysis tools, we don&amp;rsquo;t detect syntax errors. Cppcheck only detects the types of bugs that the compilers normally fail to detect. The goal is no false positives.
We recommend that you enable as many warnings as possible in your compiler.
If you use Visual C&#43;&#43;: you should use warning level 4.
If you use GCC: take a look at Warning options - using GCC
If you use another compiler: look in the manual.
Supported platforms:
  You can check non-standard code that includes various compiler extensions, inline assembly code, etc. Cppcheck is supposed to be compilable by any C&#43;&#43; compiler which handles the latest C&#43;&#43; standard. Cppcheck is supposed to work on any platform that has sufficient cpu and memory.  cppcheck的使用方法可能是代码工具中最简单的了，说一下使用方法。
1.下载CppCheck CppCheck下载地址
2.下载完后是一个MSI的安装包，安装之后，安装目录下有两个工具，一个是带界面的程序(cppcheckgui.exe)，一个是console程序(cppcheck.exe)
3.
 cppcheckgui.exe的使用方法
点击工具栏的第一个图标，是加载文件夹，也就是你的项目文件夹，加载完成后它会自动检测所有可能的问题并列出来，然后选择File-&amp;gt;Save results to file，检测结果如下图

 cppcheck.exe的使用方法
通过命令行进入cppcheck的安装目录并输入以下命令
cppcheck D:/Project/XXX(文件夹完整路径) 2&amp;gt;error.txt
会将错误生成在安装目录下名为error.txt的文件中，方便查看，结果如下：
[D:\Studio\BKWin\BKWin\resource.h:1]: (error) The code contains characters that are unhandled. Neither unicode nor extended ASCII are supported. (line=1, character code=ff)
[D:\Studio\BKWin\BKWin\resource.h:1]: (error) The code contains characters that are unhandled. Neither unicode nor extended ASCII are supported. (line=1, character code=fe)
 可以看到两种方法检测到的结果是一样的。
cppcheck支持的编译器有很多种，分别如下：
 =========
Cppcheck
=========
About
The original name of this program is &amp;ldquo;C&#43;&#43;check&amp;rdquo; but it was later changed to &amp;ldquo;cppcheck&amp;rdquo;.
Manual
A manual is available online:
http://cppcheck.sf.net/manual.pdf
Compiling
Any C&#43;&#43; compiler should work.
To build the GUI, you need Qt.
When building the command line tool, PCRE is normally used.
PCRE is optional.
There are multiple compilation choices:
 qmake - cross platform build tool
 Windows: Visual Studio
 Windows: Qt Creator &#43; mingw
 gnu make
 g&#43;&#43;
  qmake
=====
You can use the gui/gui.pro file to build the GUI.
cd gui
qmake
make
Visual Studio
=============
Use the cppcheck.sln file. The rules are normally enabled.
To compile with rules (pcre dependency):
 the pcre dll is needed. it can be downloaded from:   http://cppcheck.sf.net/pcre-8.10-vs.zip
To compile without rules (no dependencies):
 remove the preprocessor define HAVE_RULES from the project
 remove the pcre.lib from the project
  Qt Creator &#43; mingw
==================
The PCRE dll is needed to build the CLI. It can be downloaded here:
http://software-download.name/pcre-library-windows/
gnu make
========
To build Cppcheck with rules (pcre dependency):
make HAVE_RULES=yes
To build Cppcheck without rules (no dependencies):
make
g&#43;&#43; (for experts)
=================
If you just want to build Cppcheck without dependencies then you can use this command:
g&#43;&#43; -o cppcheck -Ilib cli/*.cpp lib/*.cpp
If you want to use &amp;ndash;rule and &amp;ndash;rule-file then dependencies are needed:
g&#43;&#43; -o cppcheck -lpcre -DHAVE_RULES -Ilib -Iexternals cli/*.cpp lib/*.cpp externals/tinyxml/*.cpp
mingw
=====
make LDFLAGS=-lshlwapi
Cross compiling Win32 (CLI) version of Cppcheck in Linux
sudo apt-get install mingw32
make CXX=i586-mingw32msvc-g&#43;&#43; LDFLAGS=&amp;ldquo;-lshlwapi&amp;rdquo;
mv cppcheck cppcheck.exe
Webpage
http://cppcheck.sourceforge.net/
 我们可以不用担心写出来的简单错误了，用它很轻松就检测出来了，非常容易使用，写代码的朋友，可以去试试了。
</content>
    </entry>
    
     <entry>
        <title>IOCP浅析[二]——IOCP出现的意义和函数接口</title>
        <url>https://cppfans.org/1089.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>API</tag><tag>IOCP</tag><tag>网络编程</tag>
        </tags>
        <content type="html"> 上一篇《IOCP浅析》中翻翻的谈了一下IOCP的简单含义，这篇稍微深入讨论下IOCP到底有什么好的，让大家将他推向神坛，同时简单的讨论下基本函数。
IOCP出现的意义？
写过网络程序的朋友应该很清楚网络程序的原型代码，startup一个WSADATA，然后建立一个监听socket对象，绑定一个服务器地址，然后开始监听，无限循环的accept来自客户端的消息，建立一个线程来处理消息，accept之后线程就被挂起了，知道收到来自客户端的消息。
这样的模型中服务器对每个客户端都会创建一个线程，优点在于等待请求的线程只做很少的事情，大部分时间该线程都在休息，因为recv函数是阻塞的。
所以这样的效率并不是很高，NT小组意识到这样CPU的大部分时间都耗费在线程的上下文切换上，线程并没有抢到cpu时间来处理自己的工作。
NT小组想到了一个解决办法，实现开好N个线程，将用户的消息都投递到一个消息队列中去，然后事先开好的N个线程逐一从消息队列中取出消息并加以处理，就可以避免为每一个客户端的请求单独开线程，既减少了线程的资源，也提高了线程的利用率。所以I/O完成端口的内核对象在NT3.5中首次被引入，MS还是比较伟大的。
这里你也看到了，IOCP其实称作是一种消息处理的机制差不多，而叫完成端口估计也是有历史原因，亦或者是因为他提供了用户与操作系统的一种接口吧。
ICOP的基本函数接口
创建完成端口
[cpp]
HANDLE WINAPI CreateIoCompletionPort(
__in HANDLE FileHandle, // An open file handle or INVALID_HANDLE_VALUE
__in_opt HANDLE ExistingCompletionPort, // A handle to an existing I/O completion port or NULL
__in ULONG_PTR CompletionKey, // Completion key
__in DWORD NumberOfConcurrentThreads // Number of threads to execute concurrently
);
[/cpp]
第一个参数是指一个已经打开的文件句柄或者空句柄值，一般为客户端的socket 注意：第一个参数HANDLE在创建时需要在CreateFile()中制定FILE_FLAG_OVERLAPPED标志。
第二个参数是指一个已经存在的IOCP句柄或者NULL
第三个参数是指完成Key，是一个unsigned long的指针，可以为NULL
第四个参数才是我们比较关心的，是指已经创建好的线程数，一般我们会用一个公式来计算，预设的线程数 = CPU核心数 * 2 &#43; 2，有人也说是 &#43; 1，我是没明白为什么要这样计算，希望大神指教。
对于第三个参数的意思，MSDN上解释如下 Use the CompletionKey parameter to help your application track which I/O operations have completed.(用来检测那些IO操作已经完成)
该函数用于两个不同的目的
1.创建一个完成端口的句柄对象
HANDLE h = CreateIoCompletionPort((HANDLE) socket, hCompletionPort, dwCompletionKey, m_nIOWorkers);
2.将一个句柄和完成端口关联在一起
在绑定每一个CLIENT到IOCP时，需要传递一个DWORD CompletionKey, 该参数为CLIENT信息的一个指针。
IO的异步调用
[cpp]
BOOL WINAPI PostQueuedCompletionStatus(
__in HANDLE CompletionPort,
__in DWORD dwNumberOfBytesTransferred,
__in ULONG_PTR dwCompletionKey,
__in_opt LPOVERLAPPED lpOverlapped
);
[/cpp]
第一个参数为创建的完成端口句柄
第二个参数传输了多少字节
第三个参数同样为完成键指针
第四个参数为重叠I/O buffer，其结构如下
[c]
typedef struct _OVERLAPPED {
ULONG_PTR Internal;
ULONG_PTR InternalHigh;
union {
struct {
DWORD Offset;
DWORD OffsetHigh;
};
PVOID Pointer;
};
HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;
[/c]
线程的同步
[cpp]
BOOL WINAPI GetQueuedCompletionStatus(
__in HANDLE CompletionPort,
__out LPDWORD lpNumberOfBytes,
__out PULONG_PTR lpCompletionKey,
__out LPOVERLAPPED *lpOverlapped,
__in DWORD dwMilliseconds
);
[/cpp]
第一个参数为创建的完成端口句柄
第二个参数同样为传输了多少字节
第三个参数同样为完成键指针
第四个参数为重叠I/O buffer
第五个参数的解释如下
The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion port. If a completion packet does not appear within the specified time, the function times out, returns FALSE, and sets *lpOverlapped to NULL.（等待完成端口上的完成packet出现的毫秒数。如果一个完成在特殊时间内没有出现，则认为超时，返回false，同时将重叠buffer置为NULL）
大体上函数就有这么几个，大家有兴趣可以去看看MSDN上关于完成端口上的英文介绍，比较准确，中文翻译上难免出现歧义，同时还可以锻炼英文阅读。
好了，I/O完成端口的API就介绍到这里，下一篇会尝试着写出一个简单的完成端口模型来通讯，这篇可能会比较晚出来，因为自己也是摸索阶段，大家互勉。
</content>
    </entry>
    
     <entry>
        <title>博客再次更新主题，希望大家不会烦</title>
        <url>https://cppfans.org/1077.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>主题</tag><tag>博客</tag>
        </tags>
        <content type="html"> 上个星期折腾博客到wp3.3.1版本，结果发现喜欢的主题不能用，所以昨天晚上思前想后，决定将博客的版本降下去，幸好数据库没有改动，否则还真是悲剧了。
折腾博客也不是一天两天了，万幸的是wp经得起折腾，数据库直接使用 帝国数据库备份软件 来备份，可以自动选择数据库编码和数据库版本，非常方便。
降回去版本之后，现在博客正在使用的这款主题也可以用了，这款主题非常漂亮，支持五种颜色，喜欢的朋友可以去下载：Weisay Simple，作者非常的耐心讲解了如何使用，在这里谢谢作者提供这么优秀的主题给我使用，非常感谢。
昨天晚上紧急发布了一个更新公告的页面，对大家的访问带来不便敬请谅解，实在是迫不得已而为之的。
现在博客已经完全搞定，大概很长时间都不会在更换主题的，换怕了。
博客现在的广告位非常统一清爽，只有三个位置，希望大家高抬贵手，给予一定的支持，谢谢了，下来的计划我就不多说了，还是以网络开发为主。
特别说明一点，现在博客的订阅不是很显眼，所以会单独加一个RSS订阅的小工具，Icon正在制作当中，希望大家多多订阅我的博客，交流经验。
最后，祝大家情人节快乐，单身的早日脱光。
</content>
    </entry>
    
     <entry>
        <title>WordPress修改主题后无法正常显示页面解决方法</title>
        <url>https://cppfans.org/1066.html</url>
        <categories>
          <category>Wordpress</category><category>技术文章</category>
        </categories>
        <tags>
          <tag>wordpress</tag><tag>主题</tag><tag>数据库</tag>
        </tags>
        <content type="html"> 下午看到一个挺漂亮的主题，下载来想试用下看看效果，结果却导致我的前台页面无法正常显示，成白板儿了，这下郁闷了，难道又要折腾了，悲剧，不过想起来WP的所有配置相关的东西全存在数据库里，去数据库里改了主题不就行了吗？绝佳的好办法。
从空间后台进入phpMyAdmin，打开wp_options表（注意：你的表格名称前缀可能和我的不一样，取决于当初你安装wp时候给的后缀，不过一般都没人改的），翻到第二页，大概在中间的位置有两个主题的字段，如下：
    45    template   SimplePro-TT   yes       46    stylesheet   SimplePro-TT   yes    这个里面的红色部分就是wp的主题和css样单名称，大家看到了，我的是现在的主题，将这两个改回你原来的主题就可以了，点击前面的“编辑”，修改optionvalue为原来的主题名称就可以了，这样就可以进入后台修改重新启用旧主题了。
好了，解决了，没什么可说的了，如有问题，可以直接联系我交流。
</content>
    </entry>
    
     <entry>
        <title>最近情况说明</title>
        <url>https://cppfans.org/1061.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 虽然说这周是上班的第一周，但是的确非常忙，显示服务器莫名的国家信息没有入库，导致国王战无效，部分帮会数据没有入库，总之一团糟糕，查了所有的Log，线程没有挂起，SQL没有错误打出来，MySql的Log拿过来第一个国家的信息存的是对的，后面三个国家存的数据都是老数据，所有东西都查了，有点进了死胡同的样子，有点烦躁。
最近过完年博客一周没更新了，所以在此对大家说声抱歉，由于项目马上要推广了，所以可能会主要精力在项目上，希望大家理解。
后面的博客计划是：
1.IOCP的东西继续深入学习，并且会发博文谈学习心得的。
2.继续ZeroMQ的学习，前面只写了一篇，很抱歉，因为是英文文档，看起来毕竟有点慢。
3.接触软件安全方面的东西，了解下底层的东西，也算是为了项目安全性吧。这个也是我们头建议有时间就看看，因为他也在学，所以想找人一块学这个，毕竟一个人学东西没人讨论很枯燥的。
4.继续深入网络方面的东西，从ACE上看起，同时Nous的GCE文档快写完了，也会去看看他自己写的这个中间件，学习一下
&amp;nbsp;
今年的大致安排就是这样，而且还想学车，不一定有时间，如果没时间就明年5月份学吧，反正也买不起车，哈……
今年算是比较关键的一年，所以需要更努力的，所以，学习，工作，生活都不会落下的，希望大家继续关注我的博客，今天看了一下博客的访问量，是过完年最高的一天，还算不错，谢谢大家，今年一起努力吧，fighting！！！！！！
</content>
    </entry>
    
     <entry>
        <title>IOCP浅析</title>
        <url>https://cppfans.org/1054.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>IOCP</tag><tag>网络开发</tag>
        </tags>
        <content type="html">  这一年半来一直在做游戏项目逻辑层，学会了不少东西，觉得自己应该看看服务器底层的东西了，主要的东西就是网络模块，网络模块是沿用以前项目的，在 我们项目中被我们头改动过几次，现在还是比较稳定的。因为是Windows平台，所以用的依然是被大多数人神话了的IOCP，不过的确IOCP 表现的非常不错。
什么是IOCP？ 众所周知，为了绝对同步，所以很多模式都采用的是同步模式，而不是异步，这样就会产生很大情况下在等待，CPU在切换时间片，从而导致效率比较低。自从MS在winsocket2中引入了IOCP这个模型之后，他才开始被大家所认知。
IOCP （I/O Completion Port），中文译作IO完成端口，他是一个异步I/O操作的API，他可以高效的将I/O事件通知给我们的应用程序，那游戏项目来说，就是客户端或者服务器。
他与Socket基础API select()或其他异步方法不同的是，他需要讲一个Socket和一个完成端口绑定在一起，然后就可以进行网路通信了。
什么是同步/异步？ 所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。
异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。
逻辑上通俗来讲是完成一件事再去做另外一件事情就是同步，而一起做两件或者两件以上的事情就是异步了。类似于Win32API中的SendMessage()和PostMessage()，你可以将他理解成单线程和多线程的区别。
拿游戏服务器与客户端通信来说：
如果是同步：
ClientA发送一条Msg1Req消息给Server，这个时候ClientA就会等待Server处理Msg1Req。这段时间内ClientA只有等待，因为Server还没有给ClientA回复Msg1Ack消息，所以ClientA只能痴痴的等，等到回复之后，才能处理第二条Msg2Req消息，这样无疑就会大大的降低性能，产生非常差的用户体验。
如果是异步：
ClientA发送一条Msg1Req消息给Server，ClientA有发送第二条Msg2Req消息给Server，Server会将他们都存入队列，一条一条处理，处理完之后回复给ClientA，这样用户就可以不必等待，效率就会非常高。
什么是阻塞/非阻塞？ 阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。可能阻塞和同步有点类似，但是同步调用的时候线程还是激活的，而阻塞时线程会被挂起。
非阻塞调用和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。
对象的阻塞模式和阻塞函数调用 对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方 式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数 select就是这样的一个例子。
对IOCP的评价如何？ I/O完成端口可能是Win32提供的最复杂的内核对象。 Jeffrey Richter
这是实现高容量网络服务器的最佳方法。Microsoft Corporation
完成端口模型提供了最好的伸缩性。这个模型非常适用来处理数百乃至上千个套接字。Anthony Jones &amp;amp; Jim Ohlund
I/O completion ports特别显得重要，因为它们是唯一适用于高负载服务器[必须同时维护许多连接线路]的一个技术。Completion ports利用一些线程，帮助平衡由I/O请求所引起的负载。这样的架构特别适合用在SMP系统中产生的”scalable”服务器。 Jim Beveridge &amp;amp; Robert Wiener 
IOCP中的完成是指什么意思？ 网络通信说白了就是将一堆数据发过来发过去，到底还是数据的操作。不过大家都知道I/O操作是非常慢的，包括打印机、调制解调器、硬盘等，至少相对于CPU来说是非常慢的。坐等I/O是很浪费时间的事情，可能你只需要读取100KB的数据，假设读了0.1秒，假设CPU是3.0G Hz，那么CPU已经运行了0.3G次了，所以CPU这个时候就不满意了，哥这么NB，为什么要等你？
所以我们用另外一个线程来处理I/O操作，使用重叠IO（Overlapped I/O）技术，应用程序可以要求OS为其传输数据，在完成的时候通知应用程序，然后在进行相应操作，这也就是为什么叫完成的原因。这可以使得应用程序在I/O传输期间可以做其他事情，这也可以最大限度的利用线程，而让最NB的CPU不至于痴痴等待。
下来会将IOCP和网络有什么关系，以及IOCP的简单应用。
</content>
    </entry>
    
     <entry>
        <title>2011年小结</title>
        <url>https://cppfans.org/1051.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>2011，总结</tag>
        </tags>
        <content type="html"> 周五晚上公司开了年会，突然发现2011年已经结束了，年会上大家都很开心，很幸运的获得一个奖品——iPod shuffle，还是我们头抽中的，看来2012的运气还不赖。
今年主要的做的东西就是全面熟悉项目中的东西了，得到一个结果，越做发现自己对那套代码知道的东西越少，里面还有很多东西都没认真去看，里面还有很多值得重构和优化的地方，2012年慢慢改吧。
还有很对不起来看我博客的人，计划了很多要写出来的内容，却因为工作缘故&#43;自己偷懒等一些原因，没有能够及时的奉献给大家，大家通过我更新博客的速度就能看出来的确是有点小忙，也可能是自己没有养成“每日一博”的原因吧。
所以请大家原谅，一定会慢慢写出来的，2012年希望公司和自己都是收获最多的一年吧。希望我们的项目顺利上线。
2012年据说是玛雅预言地球毁灭的一年，网上传的版本是五花八门的，不知道该信哪个了，所以干脆不信了，反正也没有买船票的钱，大家有钱的快点去抢啊，但是不知道卖船票的网站会不会因为访问人数过多而服务器顶不住压力宕机了，O(∩_∩)O哈哈~
谢谢大家一直对我博客的关注，祝大家新年快乐，龙年的生活都能如自己所愿，自己第二个本命年了，哈……
</content>
    </entry>
    
     <entry>
        <title>简单的模拟多线程引用计数原理</title>
        <url>https://cppfans.org/1033.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C&#43;&#43;</tag><tag>引用计数</tag><tag>模拟</tag><tag>源码</tag>
        </tags>
        <content type="html"> 大家都知道多线程编程学习中有一个很重要的东西——引用计数，一个线程的生或死或运行状态都跟这个计数有关，他同样是在适当的时候加加减减的。这篇文章的目的就是模拟下简单的引用计数，原因是因为项目中GateServer莫名宕机，而且运维没有给过来宕机详细信息中的偏移地址，所以纵然我们又cod文件也没法查找问题所在，所以就想出了这样一个笨办法，在每个函数都加上调用计数，这样超过一定次数的我们就认为它可能是死递归，从而方便确定问题。下面给出一个简单的引用计数类的代码。（没有写成模板，因为模板的理解成本有点高，所以在项目中不太使用）
[cpp]
/************************
FileName:AutoRefCount.h
Author :eliteYang
URL :http://www.cppfans.org
Desc :引用计数
************************/
#ifndef __AUTO_REF_COUNT_H\__
#define __AUTO_REF_COUNT_H\__
#pragma once
class RefCount
{
public:
RefCount() : _refCount( 0 ){}
~RefCount(){}
void AddRefCount(){ &#43;&#43;_refCount; }
void DecRefCount()
{
&amp;ndash;_refCount;
if ( _refCount &amp;lt; 0 )
{ _refCount = 0; }
}
int GetRefCount(){ return _refCount; }
private:
int _refCount;
};
class PtrRefCount
{
public:
PtrRefCount( RefCount* pRef, int nValue = 100 ) : pRefCount( pRef ), nCount( nValue )
{
if ( NULL != pRefCount )
{
pRefCount-&amp;gt;AddRefCount();
}
}
~PtrRefCount()
{
if ( NULL != pRefCount )
{
pRefCount-&amp;gt;DecRefCount();
}
}
bool CheckCount( char* szFunction )
{
if ( NULL == pRefCount )
{ return false; }
if ( pRefCount-&amp;gt;GetRefCount() &amp;gt; nCount )
{
std::cout &amp;lt;&amp;lt; &amp;ldquo;Function &amp;rdquo; &amp;lt;&amp;lt; szFunction &amp;lt;&amp;lt; &amp;ldquo; call error, maybe dead recursion, please check the code&amp;rdquo; &amp;lt;&amp;lt; std::endl;
return false;
}
return true;
}
private:
RefCount* pRefCount;
const int nCount;
};
#endif
[/cpp]
下载我们写一个例子来测试下，我们故意写一个死递归来检验代码。如下：
[cpp]
#include &amp;ldquo;AutoRefCount.h&amp;rdquo;
#include 
#define __FUNCTION_CALL_COUNT__ RefCount _ref; PtrRefCount ptrRef( &amp;amp;_ref ); ptrRef.CheckCount( __FUNCTION__ );
void function()
{
__FUNCTION_CALL_COUNT__;
function();
}
int _tmain(int argc, _TCHAR* argv[])
{
function();
return 0;
}
[/cpp]
结果我们发现打出了该函数可能死递归的Log，这样我们就方便查找问题了。希望对你有用！
</content>
    </entry>
    
     <entry>
        <title>[网络开发]ZeroMQ初体验——hello world</title>
        <url>https://cppfans.org/1018.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>ZeroMQ</tag><tag>ZMQ</tag><tag>消息内核</tag><tag>网络库</tag><tag>网络编程</tag>
        </tags>
        <content type="html"> 群里最近在说网络库的东西，群主推荐说可以看看ØMQ，说非常精简，而且支持多种语言，非常高效率，于是下载来看看。
ØMQ官网 www.zeromq.org
Guide还没看完，大概先看了下，觉得很精简，而且写的非常清里面包含了多种设计模式的应用，建议大家有时间看看。
 所有网络交互所使用的API实际上是Berkeley套接字(BSD) 。这个源自1980年代早期的协议是TCP/IP协议的最原始实现。而且可以说，在当今各操作系统中，它是受到最广泛支持的API，也是这些操作系统的核 心组件之一。人们对BSD套接字的了解较多的是点对点的连接。点对点连接需要显式地建立连接、销毁连接、选择协议（TCP/UDP）和处理错误等。一旦你 解决了以上所有问题，你就进入应用协议层（如HTTP）的世界了，这里需要的是组帧、缓存和处理逻辑等。换言之，编写高性能网络协议的应用程序一点儿也不 复杂。
如果我们能对各种套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，这不是件很好的事情吗？这正是ZeroMQ（ØMQ/ZMQ）网络库的由来：“它提供一些跨多种传输协议（如进程内通讯、IPC、TCP和广播）的套接字供你使用。你可使用多种方式实现N对N的套接字连接，譬如：扇出、发布订阅、任务分发以及请求响应。”
ØMQ是网络栈中新的一层，它是个可伸缩层，分散在分布式系统间。因此，它可支持任意大的应用程序。ØMQ不是简单的点对点交互，相反，它定义了分布式系统的全局拓扑。ØMQ应用程序没有锁，可并行运行。此外，它可在多个线程、内核和主机盒之间弹性伸缩。
 ZeroMQ交互是面向消息的。它将人们每天为应用程序周而复始地进行的例行消息处理封装起来。这意味着如果当客户端套接字发送一条150KB大小的消息时，服务端套接字无需显式处理任何缓存（buffer）或组帧，即能接接收到一条完整而相同的消息。 ZeroMQ套接字与传输协议无关：对于任何协议，只有单一且统一的发送消息和接收消息API。缺省情况下支持进程内通讯、IPC、广播和TCP。此外，协议间切换非常简单，仅需更改连接字符串的前缀即可。 ZeroMQ套接字能感知路由和网络拓扑。因为我们不再需要显示地管理点对点的连接状态——在上面我们已经看到，所有这些都已经由 ZeroMQ库封装好——所以单个ZeroMQ套接字可以绑定两个独立的端口并监听他们的入站请求消息；也可使用一个API调用向两个独立的套接字发送数 据。
 TCP：ZeroMQ基于消息，消息模式，而非字节流。
 XMPP：ZeroMQ更简单、快速、更底层。Jabber可建在ØMQ之上。
 AMQP：完成相同的工作，ZeroMQ要快100倍，而且不需要代理（规范更简洁——少278页）
 IPC：ZeroMQ可以跨多个主机盒，而非单台机器。
 CORBA：ZeroMQ不会将复杂到恐怖的消息格式强加于你。
 RPC：ZeroMQ完全是异步的，你可以随时增加/删除参与者。
 RFC 1149：ZeroMQ比它快多了！
 29west LBM：ZeroMQ是自由软件！
 IBM低延迟：ZeroMQ是自由软件！
 Tibco：仍然是自由软件！
   看了第一部分的guide，试了试最简单的hello world，觉得非常好用，完全可以用来做聊天软件或者游戏的消息内核。
下载ØMQ最新版本，3.0.2Beta版本，zeromq-3.0.2\builds\msvc路径下有一个msvc.sln文件，这个是VS2008的解决方案文件，我用的是VS2010，转换完后编译，我自己按照Debug和Release分开编译生成的，方便工程使用，特别强调下，编译完最外层文件夹Lib中会生成一个libzmq.dll的文件，使用该库编译的程序必须得有该链接库才可以运行。（不知道为什么官网要这样做，直接变成Lib文件，然后使用就可以了，还得转两次，如果需要Lib文件的同学可以自己将他编译为Lib文件。）
在自己工程中添加头文件和库文件路径，然后开始编写测试代码。
建立两个工程一个为ZMQServer 一个为ZMQTest
代码片段如下：
[cpp]
// hello world server
#include &amp;ldquo;zmq.h&amp;rdquo;
#include &amp;ldquo;zmq.hpp&amp;rdquo;
#include 
int _tmain(int argc, _TCHAR* argv[])
{
std::cout &amp;lt;&amp;lt; &amp;ldquo;-&amp;ndash;-&amp;ndash;-&amp;ndash;Test Client Start&amp;hellip; &amp;copy; www.cppfans.org-&amp;ndash;-&amp;ndash;-&amp;ndash;&amp;rdquo; &amp;lt;&amp;lt;std::endl;
std::cout &amp;lt;&amp;lt; &amp;ldquo;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;Author:eliteYang-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;&amp;rdquo; &amp;lt;&amp;lt;std::endl;
void* context = zmq_init( 1 );
void* responder = zmq_socket( context, ZMQ_REP );
zmq_bind( responder, &amp;ldquo;tcp://*:5555&amp;rdquo; );
while ( true )
{
zmq_msg_t msg;
zmq_msg_init( &amp;amp;msg );
zmq_recv( responder, &amp;amp;msg, 0 );
std::cout &amp;lt;&amp;lt; &amp;ldquo;Recv Hello world! from Client&amp;rdquo; &amp;lt;&amp;lt; std::endl;
zmq_msg_close( &amp;amp;msg );
Sleep( 100 );
}
zmq_close (responder);
zmq_term (context);
system( &amp;ldquo;Pause&amp;rdquo; );
return 0;
}
[/cpp]
[cpp]
// hello world client
#include &amp;ldquo;zmq.h&amp;rdquo;
#include &amp;ldquo;zmq.hpp&amp;rdquo;
#include 
#include 
#include 
int _tmain(int argc, _TCHAR* argv[])
{
std::cout &amp;lt;&amp;lt; &amp;ldquo;-&amp;ndash;-&amp;ndash;-&amp;ndash;Test Client Start&amp;hellip; &amp;copy; www.cppfans.org-&amp;ndash;-&amp;ndash;-&amp;ndash;&amp;rdquo; &amp;lt;&amp;lt;std::endl;
std::cout &amp;lt;&amp;lt; &amp;ldquo;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;Author:eliteYang-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;&amp;rdquo; &amp;lt;&amp;lt;std::endl;
void* context = zmq_init( 1 );
void* responder = zmq_socket( context, ZMQ_REQ );
int nRet = zmq_connect( responder, &amp;ldquo;tcp://localhost:5555&amp;rdquo; );
if ( nRet == 0 )
{ std::cout &amp;lt;&amp;lt; &amp;ldquo;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;Client Connect Server OK-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;&amp;rdquo; &amp;lt;&amp;lt;std::endl; }
for ( int i = 0; i &amp;lt; 10; &#43;&#43;i )
{
zmq_msg_t msg;
zmq_msg_init_size( &amp;amp;msg, 32 );
memcpy( zmq_msg_data( &amp;amp;msg ), &amp;ldquo;Hello world!&amp;rdquo;, 15);
zmq_send( responder, &amp;amp;msg, 0 );
zmq_msg_close( &amp;amp;msg );
std::cout &amp;lt;&amp;lt; &amp;ldquo;Send Msg&amp;rdquo; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;ldquo;Times&amp;rdquo; &amp;lt;&amp;lt; std::endl;
}
zmq_close (responder);
zmq_term (context);
system( &amp;ldquo;Pause&amp;rdquo; );
return 0;
}
[/cpp]
这样一个简单的网络程序就写好了，无需你对网络协议和网络编程多熟悉就可以完成，非常简单实用，大家有兴趣可以看下。后面我会对现有的几个网络库慢慢研究的（ZMQ RakNet IOCP LibEvent ICE等），希望大家继续关注！
</content>
    </entry>
    
     <entry>
        <title>关于11.21博客访问异常的说明</title>
        <url>https://cppfans.org/1011.html</url>
        <categories>
          <category>互联网</category>
        </categories>
        <tags>
          <tag>主机</tag><tag>域名</tag><tag>备案</tag><tag>新誉</tag>
        </tags>
        <content type="html"> 今天打开博客发现速度很慢，而且有几率打不开，ping了一下发现丢包很严重，与IDC说了下，原来是37段内的主机均出现大量丢包的问题，估计是出现了些什么问题吧，而在我发文之前已经修好了，他们的速度还是很犀利的，谢谢主机商的快捷服务。
在此对今天的情况对大家说声道歉，今天一天都在公司忙，也没发现，晚上回来才发现的，对各位打来的访问不便敬请谅解。
同时顺便给我的主机商信誉中国做个广告，服务真的挺好，而且空间速度快，有问题都会在10分钟内响应，最多1小时内解决，很放心。
如果需要主机的朋友可以联系我购买，价格表在这里http://www.cppfans.org/525.html有提到，对经常访问我博客的朋友可以优惠。
</content>
    </entry>
    
     <entry>
        <title>VMware下Fedora16不能全屏的简易解决办法</title>
        <url>https://cppfans.org/1009.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>Fedora</tag><tag>vmware</tag><tag>全屏</tag>
        </tags>
        <content type="html"> 虚拟了Fedora之后，发现桌面并不能全屏，查了查vmware提供的帮助，大致是需要下载vmware tools然后挂载安装调整配置这种方法，不过想着Linux现在也是做的越来越好，难道在windows上这样一个小问题，在Linux下就这么麻烦的解决办法？于是想了想应该也有类似调整分辨率的东西，在Fedora左上角的应用程序-&amp;gt;系统工具-&amp;gt;系统设置-&amp;gt;显示，调整适合你的电脑的分辨率即可。
简单实用见效快，而且这么一个小问题也不用浪费很多时间。我的分辨率是1366 X 768 ( 16 ： 9 )的。
</content>
    </entry>
    
     <entry>
        <title>[转]现代C&#43;&#43;风格的新元素</title>
        <url>https://cppfans.org/1003.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>C 11</tag><tag>C&#43;&#43;</tag><tag>新特性</tag>
        </tags>
        <content type="html"> ****“C&#43;&#43;11就像一门新的语言。” – Bjarne Stroustrup
C&#43;&#43;11标准推出了很多有用的新特性。本文特别关注相比C&#43;&#43;98更像是一门新语言的那部分特性，因为：
这些特性改变了编写C&#43;&#43;程序使用的代码风格和习语[TODO]，通常也包括你设计C&#43;&#43;函数库的方式。例如，你会看到更多参数和返回值类型为智能指针_(smart pointer)_，同时也会看到函数通过值传递返回大型对象
你将会发现在大多数的代码示例中充斥着新特性的身影。例如，几乎每5行现代C&#43;&#43;代码示例都会使用到auto
C&#43;&#43;11的其他特性也很棒。但是请先熟悉下面这些，正是因为这些特性的广泛使用使得C&#43;&#43;11代码如同其他现代主流语言一样整洁、安全和高效，与此同时保持了C&#43;&#43;传统的性能优势。
提示：
 与Strunk &amp;amp; White[TODO]一样，本文只做概要的总结性指导而不做详尽基本原理和优缺点分析。详细分析请参见其他文章 本文会不断更新，主要变更及内容增加请参见文末变更记录  auto
基于以下两个原因，尽可能使用auto：首先，使用auto会避免重复声明编译器已经知道的类型。
[cpp]
// C&#43;&#43;98
map::iterator i = m.begin ();
// C&#43;&#43;11
auto i = begin (m);
[/cpp]
其次，当使用未知类型或者类型名称不易理解时使auto会更加便利，例如大多数的lambda函数［TODO］——你甚至不能简单的拼写出类型的名字。
[cpp]
// C&#43;&#43;98
binder2nd&amp;lt; greater &amp;gt; x = bind2nd ( greater()， 42 );
// C&#43;&#43;11
auto x = [](int i) { return i &amp;gt; 42; };
[/cpp]
需要注意，使用auto并不改变代码的含义。代码仍然是静态类型［译注］，每个表达式的类型都是清晰和明确的；C&#43;&#43;11只是不需要我们重复声明类 型的名字。一些人刚开始可能会害怕在这里使用auto，因为感觉好像没有（重复）声明我们需要的类型就意味着会碰巧得到一个不同的类型。如果你想要明确地 进行一次_强制类型转换_，没有问题，声明目标类型就好了。然而大多数情况下，只要使用auto就可以了；几乎不会出现错误地拿到一个不同类型的情况，即便出现错误，C&#43;&#43;的强静态类型系统也会由编译器让你知道这个错误，因为你正试图访问一个变量没有的成员函数或是错误地调用了该函数。
译注：动态类型语言（dynamic typing language）是指类型检查发生在运行期间（run-time）的语言。静态类型语言（static typing language）是类型检查发生在编译期间（compile-time）的语言。
智能指针：无须delete
请始终使用标准智能指针以及非占有原始指针(non-owning raw pointer)。绝不要使用占有原生指针(owning raw pointer)和delete操作，除非在实现你自己的底层数据结构这种少见的情况下（即使在此时也需要在 class 范围内保持完好的封装）。如果只能够知道你是另一个对象唯一的所有者，请使用unique_ptr来表示唯一所有权（TODO)。一个”new T”表达式会马上初始化另一个引用它的对象，通常是一个unique_ptr。
[cpp]
// C&#43;&#43;11 Pimpl Idiom
class widget {
widget ();
~widget ();
private:
class impl;
unique_ptr pimpl;
};
// in .cpp file
 class impl {  :::
};
 widget::widget () pimpl ( new impl () )
  {
}
widget::~widget () = default;
[/cpp]
使用shared_ptr来表示共享所有权。推荐使用make_shared来有效地创建共享对象。
[cpp]
// C&#43;&#43;98
 widget* pw = new widget ();  :::
delete pw;
// C&#43;&#43;11
auto pw = make_shared();
[/cpp]
使用 weak_ptr 来退出循环并且表示可选性（例如，实现一个对象缓存）
[cpp]
// C&#43;&#43;11
class gadget;
class widget {
private:
shared_ptr g; // if shared ownership
};
class gadget {
private:
weak_ptr w;
};
[/cpp]
如果你知道另一个对象存在时间会更长久并且希望跟踪它，使用一个（非占有non-owning)原始指针。
[cpp]
// C&#43;&#43;11
class node {
vector&amp;lt; unique_ptr &amp;gt; children;
node* parent;
 public:  :::
};
[/cpp]
nullptr
始终使用nullptr表示一个null指针值，绝不要使用数字0或者NULL宏，因为它们也可以代表一个整数或者指针从而产生歧义。
Range for
基于范围的循环使得按顺序访问其中的每个元素变得非常方便。
[cpp]
// C&#43;&#43;98
for( vector::iterator i = v.begin (); i != v.end (); &#43;&#43;i ) {
total &#43;= *i;
}
// C&#43;&#43;11
for( auto d : v ) {
total &#43;= d;
}
[/cpp]
非成员（nonmember） begin 和 end
始终使用非成员begin和end，因为它是可扩展的并且可以应用在所有的容器类型(container type)，不仅仅是遵循了STL风格提供了 .begin ()和 .end ()成员函数的容器，甚至数组都可以使用。
如果你使用了一个非STL风格的collection类型，虽然提供了迭代但没有提供STL的 .begin ()和 .end ()，通常可以为这个类型编写自己的非成员begin和end来进行重载。这样你就可以使用STL容器的编程风格来遍历该类型。C&#43;&#43;11标准提供了示 例:C数组就是这样一个类型，标准同时为数组提供了begin和end。
[cpp]
vector v;
int a[100];
// C&#43;&#43;98
sort ( v.begin ()， v.end () );
sort ( &amp;amp;a[0], &amp;amp;a[0] &#43; sizeof(a)/sizeof(a[0]) );
// C&#43;&#43;11
sort ( begin (v)， end (v) );
sort ( begin (a)， end (a) );
[/cpp]
Lambda 函数和算法
Lambda[TODO]是决定乾坤的因素，它会使你编写的代码变得更优雅、更快速。Lambda使得STL算法的可用性提高了近100倍。新近开 发的C&#43;&#43;函数库都是基于lambda可以用的前提（例如，PPL）并且有些函数库甚至要求你编写lambda来调用函数库（例如，C&#43;&#43; AMP）
下面是一个快速示例：找到v里面大于x并且小于y的第一个元素。在C&#43;&#43;11中，最简单和干净的代码就是调用一个标准函数。
[cpp]
// C&#43;&#43;98: write a naked loop (using std::find_if is impractically difficult)
vector::iterator i = v.begin (); // because we need to use i later
for( ; i != v.end (); &#43;&#43;i ) {
if( *i &amp;gt; x &amp;amp;&amp;amp; *i &amp;lt; y ) break;
}
// C&#43;&#43;11: use std::find_if
auto i = find_if ( begin (v)， end (v)， [=](int i) { return i &amp;gt; x &amp;amp;&amp;amp; i &amp;lt; y; } );
[/cpp]
想要使用C&#43;&#43;编写一个循环或者类似的新特性？不用着急；只要编写一个模板函数（template function)(函数库算法），并且几乎可以将lambda当做语言特性来使用，与此同时会更加灵活，因为它不是固定的语言特性而是一个真正的函数库。
[csharp]
// C#
lock( mut_x ) {
&amp;hellip; use x &amp;hellip;
}
// 不使用 lambda 的C&#43;&#43;11：已经非常简洁并且更灵活（例如，可以使用超时以及其他选项）
{
lock_guard hold ( mut_x );
&amp;hellip; use x &amp;hellip;
}
// C&#43;&#43;11 with lambdas, and a helper algorithm: C# syntax in C&#43;&#43;
// 使用了 lambda 的C&#43;&#43;11可以带一个辅助算法：在 C&#43;&#43; 中使用 C# 的文法
// Algorithm: templatevoid lock ( T&amp;amp; t, F f ) { lock_guard hold (t); f (); }
lock( mut_x， [&amp;amp;]{
&amp;hellip; use x &amp;hellip;
});
[/csharp]
去熟悉lambda吧。你会大量使用它，不仅仅在C&#43;&#43;中——它已经广泛应用于很多主流的编程语言。一个开始的好去处请参考我在PDC2010的演讲《无处不在的 lambda》
Move / &amp;amp;&amp;amp;
Move被认为是copy的最佳优化，尽管它也使得其他事情成为可能比如信息被转发。
[cpp]
// C&#43;&#43;98：避免 copy 的替代方法
 vector* make_big_vector (); // 选择1: 返回指针: 没有拷贝，但不要忘记 delete  :::
vector* result = make_big_vector ();
 void make_big_vector ( vector&amp;amp; out ); // 选择2: 通过引用传递: 没有拷贝，但是调用者需要传入一个有名对象  :::
vector result;
make_big_vector ( result );
// C&#43;&#43;11: move
 vector make_big_vector (); // 通常对于”被调用者(callee)分配的空间“也适用  :::
vector result = make_big_vector ();
[/cpp]
Move语法改变了我们设计API的方式。我们可以更多地设计通过值传递。为你的类型启用move语法，使用时会比copy更有效。
更多变化
还有更多现代C&#43;&#43;的特性。并且我计划在未来编写更多深入C&#43;&#43;11新特性以及其他特性的短文，我们会知道更多并且喜欢上它。
但目前，这是必须知道的新特性。这些特性组成了现代C&#43;&#43;风格的核心，使得C&#43;&#43;代码看起来和执行时像他们设计的那样，你将会看到这些特性会出现在 几乎每一段你看到或者编写的现代C&#43;&#43;代码中。并且它们使得现代C&#43;&#43;更加干净、安全且快速，使得C&#43;&#43;在未来的若干年仍然是我们产业的依靠。
主要变更
2011-10-30:为Lambda增加C#lock示例。重新组织智能指针首先介绍unique_prt。
文章出自：伯乐在线
</content>
    </entry>
    
     <entry>
        <title>[加密解密]使用CryptoAPI进行文件加密解密——源码</title>
        <url>https://cppfans.org/985.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>CryptoAPI</tag><tag>加密</tag><tag>文件</tag><tag>解密</tag>
        </tags>
        <content type="html"> 前一篇简单介绍了下CryptoAPI的东西，这篇就将那点代码放出来给大家看看，以作交流参考目的。
[cpp]
/************************
FileName:CryptoDefine.h
Author :eliteYang
Mail :elite_yang@163.com
Desc :加密需要的常量定义
************************/
#ifndef __CRYPTO_DEFINE_H_
#define __CRYPTO_DEFINE_H_
#include 
#define MY_ENCODING_TYPE ( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING )
#define KEY_LENGTH 0x00800000
#define ENCRYPT_ALGORITHM CALG_RC4
#define ENCRYPT_BLOCK_SIZE 8
#endif
[/cpp]
[cpp]
/************************
FileName:LogDefine.h
Author :eliteYang
Mail :elite_yang@163.com
Desc :提示信息
************************/
#ifndef __LOG_DEFINE_H__
#define __LOG_DEFINE_H__
#define MAX_INFO 1024
#include 
void (*g_fnPrintInfoCallBack)( char* format ) = NULL;
void OutputInfoMessage( char* format )
{
if ( g_fnPrintInfoCallBack != NULL )
{
char temp[ MAX_INFO ] = { 0 };
memset( temp, 0, sizeof( temp ) );
va_list list;
va_start( list, format );
vsprintf_s( temp, sizeof( temp ) - 1, format, list );
va_end( list );
g_fnPrintInfoCallBack( temp );
}
}
#endif
[/cpp]
[cpp]
/************************
FileName:Crypto.h
Author :eliteYang
Mail :elite_yang@163.com
Desc :Crypto加解密算法实现函数
************************/
#ifndef __CRYPTO_H\__
#define __CRYPTO_H\__
#pragma once
#define MAX_INFO_LENGTH 1024
#include &amp;ldquo;CryptoDefine.h&amp;rdquo;
#include 
#include 
#include 
#include &amp;ldquo;LogDefine.h&amp;rdquo;
extern void MyOutputInfoMessage( char* format );
void HandleError( char* s )
{
char cErrorInfo[ MAX_INFO_LENGTH ];
memset( cErrorInfo, 0, sizeof( cErrorInfo ) );
sprintf_s( cErrorInfo, sizeof( cErrorInfo ) - 1, &amp;ldquo;%s 错误代码:%x 程序终止执行！&amp;rdquo;, s, GetLastError() );
MyOutputInfoMessage( cErrorInfo );
exit(1);
}
HCRYPTPROV GetCryptProv()
{
HCRYPTPROV hCryptProv;
if ( CryptAcquireContext( &amp;amp;hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, 0 ) )
{
MyOutputInfoMessage( &amp;ldquo;加密服务提供者(CSP)句柄获取成功&amp;rdquo; );
}
else
{
if ( !CryptAcquireContext( &amp;amp;hCryptProv, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET ) )
{
HandleError( &amp;ldquo;重新建立一个新的密钥集出错!&amp;rdquo; );
}
}
return hCryptProv;
}
HCRYPTKEY GetKeyByPassword( HCRYPTPROV hCryptProv,PCHAR szPassword )
{
HCRYPTKEY hKey;
HCRYPTHASH hHash;
if ( CryptCreateHash( hCryptProv, CALG_MD5, 0, 0, &amp;amp;hHash ) )
{
MyOutputInfoMessage( &amp;ldquo;一个Hash句柄已经被创建&amp;rdquo; );
}
else
{
HandleError( &amp;ldquo;CryptCreateHash 创建Hash句柄失败&amp;rdquo; );
}
if ( CryptHashData( hHash, (BYTE*)szPassword, strlen( szPassword ), 0 ) )
{
MyOutputInfoMessage( &amp;ldquo;密码已经被添加到了Hash表中&amp;rdquo; );
}
else
{
HandleError( &amp;ldquo;CryptHashData 计算密码的Hash值失败&amp;rdquo; );
}
// 通过Hash创建值创建会话密钥
if ( CryptDeriveKey( hCryptProv, ENCRYPT_ALGORITHM, hHash, KEY_LENGTH, &amp;amp;hKey ) )
{
MyOutputInfoMessage( &amp;ldquo;通过密码的Hash值获得了加密密钥&amp;rdquo; );
}
else
{
HandleError( &amp;ldquo;CryptDeriveKey 通过Hash值创建会话密钥失败&amp;rdquo; );
}
if ( hHash )
{
if ( !CryptDestroyHash( hHash ) )
{
HandleError( &amp;ldquo;CryptDestroyHash 销毁Hash句柄失败&amp;rdquo; );
}
else
{
MyOutputInfoMessage( &amp;ldquo;释放Hash句柄成功&amp;rdquo; );
hHash = 0;
}
}
return hKey;
}
HCRYPTKEY GenKeyByRandom( HCRYPTPROV hCryptProv,FILE* hDestination )
{
HCRYPTKEY hKey;
HCRYPTKEY hXchgKey;
PBYTE pbKeyBlob;
DWORD dwKeyBlobLen;
if( CryptGenKey( hCryptProv, ENCRYPT_ALGORITHM, KEY_LENGTH | CRYPT_EXPORTABLE, &amp;amp;hKey) )
{
MyOutputInfoMessage( &amp;ldquo;一个会话密钥已经被创建&amp;rdquo; );
}
else
{
HandleError(&amp;ldquo;CryptGenKey 创建会话密钥失败&amp;rdquo;);
}
// 创建交换密钥
if( CryptGenKey( hCryptProv, AT_KEYEXCHANGE, 0, &amp;amp;hXchgKey ) )
{
MyOutputInfoMessage( &amp;ldquo;交换密钥对已经创建&amp;rdquo; );
}
else
{
HandleError(&amp;ldquo;在试图创建交换密钥时出错&amp;rdquo;);
}
// 确定密钥数据块长度，并分配空间.
if( CryptExportKey( hKey, hXchgKey, SIMPLEBLOB, 0, NULL, &amp;amp;dwKeyBlobLen ) )
{
char cInfo[ MAX_INFO_LENGTH ];
memset( cInfo, 0, sizeof( cInfo ) );
sprintf_s( cInfo, sizeof( cInfo ) - 1, &amp;ldquo;此密钥块的长度是 %d 字节&amp;rdquo;, dwKeyBlobLen );
MyOutputInfoMessage( cInfo );
}
else
{
HandleError( &amp;ldquo;计算密钥数据块长度出错&amp;rdquo; );
}
if (pbKeyBlob =(BYTE *)malloc( dwKeyBlobLen ) )
{
MyOutputInfoMessage( &amp;ldquo;已经问此密钥块分配了内存&amp;rdquo; );
}
else
{
HandleError(&amp;ldquo;所需内存不够&amp;rdquo;);
}
// 导出会话密钥到简单密钥数据块中.
if( CryptExportKey( hKey, hXchgKey, SIMPLEBLOB, 0, pbKeyBlob, &amp;amp;dwKeyBlobLen ) )
{
MyOutputInfoMessage( &amp;ldquo;此会话密钥已经被导出&amp;rdquo; );
}
else
{
HandleError(&amp;ldquo;CryptExportKey 导出会话密钥到简单密钥数据块中失败&amp;rdquo;);
}
//释放交换密钥句柄.
if( hXchgKey )
{
if(!(CryptDestroyKey(hXchgKey)))
{
HandleError(&amp;ldquo;CryptDestroyKey 释放交换密钥句柄失败&amp;rdquo;);
}
else
MyOutputInfoMessage( &amp;ldquo;释放交换密钥句柄成功&amp;rdquo; );
hXchgKey = 0;
}
// 写密钥块长度到目标文件.
fwrite( &amp;amp;dwKeyBlobLen, sizeof(DWORD), 1, hDestination );
if( ferror( hDestination ) )
{
HandleError(&amp;ldquo;写密钥块长度出错&amp;rdquo;);
}
else
{
MyOutputInfoMessage( &amp;ldquo;密钥块长度已经被写入&amp;rdquo; );
}
//写密钥块数据到目标文件.
fwrite( pbKeyBlob, 1, dwKeyBlobLen, hDestination );
if( ferror( hDestination ) )
{
HandleError( &amp;ldquo;写密钥数据出错&amp;rdquo; );
}
else
{
MyOutputInfoMessage( &amp;ldquo;此密钥块数据已经被写入目标文件&amp;rdquo; );
}
// 释放内存空间.
free(pbKeyBlob);
//返回创建的会话密钥
return hKey;
}
BOOL MyEncryptFile( char* szSource, char* szDestination, char* szPassword )
{
FILE *hSource;
FILE *hDestination;
HCRYPTPROV hCryptProv;
HCRYPTKEY hKey;
PBYTE pbBuffer;
DWORD dwBlockLen;
DWORD dwBufferLen;
DWORD dwCount;
char cInfo[ MAX_INFO_LENGTH ] = { 0 };
// 打开原文文件.
hSource = fopen( szSource,&amp;ldquo;rb&amp;rdquo; );
if ( hSource )
{
memset( cInfo, 0, sizeof( cInfo ) );
sprintf_s( cInfo, sizeof( cInfo ) - 1, &amp;ldquo;原文文件 %s 已经打开&amp;rdquo;, szSource );
MyOutputInfoMessage( cInfo );
}
else
{
HandleError(&amp;ldquo;打开原文文件出错!&amp;rdquo;);
}
// 打开目标文件.
hDestination = fopen(szDestination,&amp;ldquo;w&#43;&amp;rdquo;);
if( hDestination )
{
memset( cInfo, 0, sizeof( cInfo ) );
sprintf_s( cInfo, sizeof( cInfo ) - 1, &amp;ldquo;目标文件 %s 已经打开&amp;rdquo;, szDestination );
MyOutputInfoMessage( cInfo );
}
else
{
MyOutputInfoMessage( &amp;ldquo;文件不存在，创建文件&amp;rdquo; );
}
//获取加密服务者句柄
hCryptProv = GetCryptProv();
// 创建会话密钥.
if( !szPassword || strcmp(szPassword,&amp;ldquo;&amp;rdquo;)==0 )
{
// 当输入密码为空时，则创建随机的加密密钥，并导出创建的密钥保存到文件中.
hKey = GenKeyByRandom( hCryptProv, hDestination);
}
else
{
hKey = GetKeyByPassword( hCryptProv, szPassword);
}
// 因为加密算法按ENCRYPT_BLOCK_SIZE 大小块加密，所以被加密的
// 数据长度必须是ENCRYPT_BLOCK_SIZE 的整数倍。下面计算一次加密的
// 数据长度。
dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE;
// 确定加密后密文数据块大小. 若是分组密码模式，则必须有容纳额外块的空间
if( ENCRYPT_BLOCK_SIZE &amp;gt; 1 )
dwBufferLen = dwBlockLen &#43; ENCRYPT_BLOCK_SIZE;
else
dwBufferLen = dwBlockLen;
// 分配内存空间.
if( pbBuffer = (BYTE*)malloc( dwBufferLen ) )
{
MyOutputInfoMessage( &amp;ldquo;已经为缓冲区分配了内存&amp;rdquo; );
}
else
{
HandleError( &amp;ldquo;所需内存不够&amp;rdquo; );
}
// 循环加密 原文件
while( !feof(hSource) )
{
// 每次从原文件中读取dwBlockLen字节数据.
dwCount = fread(pbBuffer, 1, dwBlockLen, hSource);
if( ferror(hSource) )
{
HandleError(&amp;ldquo;读取明文文件出错&amp;rdquo;);
}
// 加密数据.
if( !CryptEncrypt(
hKey, //密钥
0, //如果数据同时进行散列和加密，这里传入一个散列对象
feof(hSource), //如果是最后一个被加密的块，输入TRUE.如果不是输入FALSE.
//这里通过判断是否到文件尾来决定是否为最后一块。
0, //保留
pbBuffer, //输入被加密数据，输出加密后的数据
&amp;amp;dwCount, //输入被加密数据实际长度，输出加密后数据长度
dwBufferLen)) //pbBuffer的大小。
{
HandleError(&amp;ldquo;CryptEncrypt 加密失败&amp;rdquo;);
}
// 把加密后数据写到密文文件中
fwrite(pbBuffer, 1, dwCount, hDestination);
if( ferror(hDestination) )
{
HandleError(&amp;ldquo;写入密文时出错&amp;rdquo;);
}
}
// 关闭文件
if( hSource )
{
if(fclose(hSource))
{
HandleError(&amp;ldquo;关闭源文文件出错!&amp;rdquo;);
}
}
if( hDestination )
{
if(fclose(hDestination))
{
HandleError(&amp;ldquo;关闭目标文件出错!&amp;rdquo;);
}
}
// 释放内存空间.
if(pbBuffer)
free(pbBuffer);
// 销毁会话密钥
if ( hKey )
{
if( !CryptDestroyKey( hKey ) )
{
HandleError(&amp;ldquo;CryptDestroyKey 会话密钥失败&amp;rdquo;);
}
}
// 释放CSP句柄
if ( hCryptProv )
{
if( !CryptReleaseContext(hCryptProv, 0) )
{
HandleError(&amp;ldquo;CryptReleaseContext 释放CSP句柄失败&amp;rdquo;);
}
}
return(TRUE);
}
HCRYPTKEY GenKeyFromFile(HCRYPTPROV hCryptProv,FILE* hSource)
{
HCRYPTKEY hKey;
PBYTE pbKeyBlob;
DWORD dwKeyBlobLen;
//从密文文件中获取密钥数据块长度，并分配内存空间.
fread(&amp;amp;dwKeyBlobLen, sizeof(DWORD), 1, hSource);
if(ferror(hSource) || feof(hSource))
{
HandleError(&amp;ldquo;读取密文文件中密钥数据块长度出错!&amp;rdquo;);
}
if(!(pbKeyBlob = (BYTE *)malloc(dwKeyBlobLen)))
{
HandleError(&amp;ldquo;内存分配出错.&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 从密文文件中获取密钥数据块
fread(pbKeyBlob, 1, dwKeyBlobLen, hSource);
if(ferror(hSource) || feof(hSource))
{
HandleError(&amp;ldquo;读取密文文件中密钥数据块出错!\n&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 导入会话密钥到 CSP.
if(!CryptImportKey(
hCryptProv,
pbKeyBlob,
dwKeyBlobLen,
0,
0,
&amp;amp;hKey))
{
HandleError(&amp;ldquo;Error during CryptImportKey!&amp;rdquo;);
}
if(pbKeyBlob)
free(pbKeyBlob);
//返回导出的会话密钥
return hKey;
}
BOOL MyDecryptFile( char* szSource, char* szDestination, char* szPassword)
{
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 局部变量申明与初始化.
FILE *hSource;
FILE *hDestination;
HCRYPTPROV hCryptProv;
HCRYPTKEY hKey;
PBYTE pbBuffer;
DWORD dwBlockLen;
DWORD dwBufferLen;
DWORD dwCount;
BOOL status = FALSE;
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 打开密文文件.
if(!(hSource = fopen(szSource,&amp;ldquo;rb&amp;rdquo;)))
{
HandleError(&amp;ldquo;打开密文文件出错!&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 打开目标文件，用于存储解密后的数据.
hDestination = fopen( szDestination,&amp;ldquo;wb&amp;rdquo; );
if( !hDestination )
{
HandleError(&amp;ldquo;打开明文文件出错!&amp;rdquo;);
}
//获取加密服务者句柄
hCryptProv = GetCryptProv();
//获取或创建会话密钥
if(!szPassword|| strcmp(szPassword,&amp;ldquo;&amp;rdquo;)==0 )
{
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
//从密文文件导入保存的会话密钥
hKey = GenKeyFromFile( hCryptProv,hSource);
}
else
{
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 通过输入密码重新创建会话密钥.
hKey = GetKeyByPassword( hCryptProv, szPassword);
}
// 计算一次解密的数据长度，它是ENCRYPT_BLOCK_SIZE 的整数倍
dwBlockLen = 1000 - 1000 % ENCRYPT_BLOCK_SIZE;
dwBufferLen = dwBlockLen;
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 分配内存空间.
if(!(pbBuffer = (BYTE *)malloc(dwBufferLen)))
{
HandleError(&amp;ldquo;所需内存不够!\n&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 解密密文文件，解密后数据保存在目标文件
do {
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 每次从密文文件中读取dwBlockLen字节数据.
dwCount = fread(
pbBuffer,
1,
dwBlockLen,
hSource);
if(ferror(hSource))
{
HandleError(&amp;ldquo;读取密文文件出错!&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 解密 数据
if(!CryptDecrypt(
hKey,
0,
feof(hSource),
0,
pbBuffer,
&amp;amp;dwCount))
{
HandleError(&amp;ldquo;Error during CryptDecrypt!&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 把解密后的数据写入目标文件中.
fwrite(
pbBuffer,
1,
dwCount,
hDestination);
if(ferror(hDestination))
{
HandleError(&amp;ldquo;Error writing plaintext!&amp;rdquo;);
}
} while(!feof(hSource));
status = TRUE;
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 关闭文件
if(hSource)
{
if(fclose(hSource))
HandleError(&amp;ldquo;关闭原文件出错&amp;rdquo;);
}
if(hDestination)
{
if(fclose(hDestination))
HandleError(&amp;ldquo;关闭目标文件出错&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 释放内存空间
if(pbBuffer)
free(pbBuffer);
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 销毁会话密钥
if(hKey)
{
if(!(CryptDestroyKey(hKey)))
HandleError(&amp;ldquo;Error during CryptDestroyKey&amp;rdquo;);
}
//-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;ndash;-&amp;mdash;-
// 释放CSP句柄
if(hCryptProv)
{
if(!(CryptReleaseContext(hCryptProv, 0)))
HandleError(&amp;ldquo;Error during CryptReleaseContext&amp;rdquo;);
}
return status;
} // end Decryptfile
#endif
[/cpp]
其中MyOutputInfoMessage函数为我自己定义的一个打印Log的函数，在一个ListBox上输出所有的提示信息，不然用MessageBox太恶心了，这点大家可以用别的方式实现，就不贴MFC部分的代码了。
</content>
    </entry>
    
     <entry>
        <title>[加密解密]CryptoAPI简介</title>
        <url>https://cppfans.org/911.html</url>
        <categories>
          <category>技术文章</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>CryptoAPI</tag><tag>CSP</tag><tag>Microsoft</tag><tag>加密</tag>
        </tags>
        <content type="html">  帮那个小朋友写加密工具也写完了，用的是微软的CryptAPI库，支持的加密方式挺多的，最坑爹的是他们老师让做加密与解密，结果加密方式是MD5，绝对是坑爹。效果图在前面的文章已经放出来了，大家可以去围观丑陋的界面。
CryptoAPI概述 Windows CryptoAPI是Microsoft 公司提出的安全加密应用服务框架，也是PKI推荐使用的加密 API。它提供了在Win32 环境下使用认证、编码、加密和签名等安全服务时的标准加密接口，用于增强应用程序的安全性与可控性。应用开发者可以在不了解复杂的加密机制和加密算法的情况下，简便、快速地开发出标准、通用和易于扩展的安全加密应用程序。CryptoAPI 提供的功能主要有：密钥管理、数据加密和解密、数字签名和验证、证书管理、可信根证书管理、数据编码和解码、数字证书编码和解码、PKCS#7 标准格式编码和解码等。现在CryptoAPI的最新版本为2.0版本。
微软加密服务体系 微软加密服务体系包含3层结构和两个接口，分别为应用程序层、操作系统层（OS）、加密服务提供者层（Cryptographic Service Provider，CSP）、CryptoAPI接口和加密服务提供者接口（CSPI），其结构图如下图所示。应用程序层通过CryptoAPI接口与操作系统通信，操作系统通过加密服务提供者接口（CSPI）与CSP通信。其编程模型同Windows系统的图形设备接口 GDI比较类似，其中加密服务提供者CSP等同于图形设备驱动程序 ，加密硬件（可选）等同于图形硬件，其上层的应用程序也类似，都不需要同设备驱动程序和硬件直接打交道。CryptoAPI接口面向应用系统，而CryptoSPI 面向加密模块开发商，CryptoAPI 统一由Windows 提供，而底层的CSP由各开发商提供。这样的分层体系结构，使应用系统不必关心底层的加密实现细节和实现方式(软件或硬件)，降低了集成难度，并且在一个系统中可以同时加载多个CSP。同时微软公司为开发商制定了CSP 的标准接口，开发商按照标准开发CSP，就可以把自己开发的软件或硬件加密模块紧密集成进CryptoAPI 的体系中。
微软加密服务体系  在微软加密服务体系中，加密服务相关的所有操作都在CSP实现，它是真正实行加密相关服务的独立模块，既可以由软件实现也可以由硬件实现，但是必须符合CryptoAPI接口的规范。每个CSP必须包含有一个动态链接库和一个签名文件，签名文件用于保证底层的CSP 的安全性，CryptoAPI 接口在加载每个CSP 时，需要验证CSP 的签名，如果签名无效，则拒绝加载，CSP 的签名由微软公司签发。同时，每个CSP都有一个名字和一个类型，名字必须唯一的，这样便于CryptoAPI找到对应的CSP。加密服务标准被分为不同的家族，每种家族包含自己的一系列数据格式和协议，不同的家族有不同的数据格式或协议等。在CryptoAPI中，每种CSP类型代表不同的家族。目前已经有9种CSP类型，并且还在增长，不同类型支持的密钥交换算法、签名算法、对称加密算法和Hash算法等如下表所示。
 CSP类型   交换算法   签名算法   对称加密算法   Hash算法     PROV_RSA_FULL  RSA  RSA  RC2
RC4  MD5
SHA    PROV_RSA_SIG  none  RSA  none  MD5
SHA    PROV_RSA_SCHANNEL  RSA  RSA  RC4
DES
Triple DES  MD5
SHA    PROV_DSS  DSS  none  DSS  MD5
SHA    PROV_DSS_DH  DH  DSS  CYLINK_MEK  MD5
SHA    PROV_DH_SCHANNEL  DH  DSS  DES
Triple DES  MD5
SHA    PROV_FORTEZZA  KEA  DSS  Skipjack  SHA    PROV_MS_EXCHANGE  RSA  RSA  CAST  MD5    PROV_SSL  RSA  RSA  Varies  Varies    CryptoAPI体系架构 CryptoAPI体系架构共由五大主要部分组成：基本CSP函数（Base Cryptographic Functions）、证书编解码函数（Certificate Encode/Decode Functions）、证书库管理函数（Certificate Store Functions），简单消息函数（Simplified Message Functions）、底层消息函数（Low-level Message Functions）。其结构图如下图所示。
CryptoAPI体系架构  基本加密函数：用于选择CSP、建立CSP连接、产生密钥、交换及传输密钥等操作。这些函数为开发加密应用程序提供了足够灵活的空间。所有CSP 的通讯都是通过这些函数，一个CSP 是实现所有加密操作的独立模块，于是在每一个加密应用程序中至少需要提供一个CSP来完成所需的加密操作。
证书编/解码函数：用于数据加密、解密、哈希等操作。这类函数支持数据的加密/解密操作；在应用程序中完成计算哈希、创建和校验数字签名操作；用来对证书、证书撤销列表、证书请求和证书扩展进行编码和解码操作。
证书库管理函数：用于数字证书及证书库管理等操作。这组函数用于管理证书、证书撤销列表和证书信任列表的使用、储存、获取等。
简单消息函数：用于消息处理，比如消息编码/解码、消息加/解密、数字签名及签名验证等操作。它是把多个低层函数包装在一起以完成某个特定任务，以方便用户的使用。
底层消息函数：低级消息函数对传输的PKCS#7 数据进行编码，对接收到的PKCS#7 数据进行解码，并且对接收到的消息进行解密和验证。它可以实现简单消息函数可以实现的所有功能，它提供更大的灵活性，但一般会需要更多的函数调用。对于绝大多数应用，我们不推荐使用低级消息函数，使用简化消息函数更为方便。
CryptoAPI基本功能 利用CryptoAPI，开发者可以给基于Windows的应用程序添加安全服务，包括: ASN.1编码及解码、数据加密/解密、身份论证、数字证书管理，同时支持PKI、对称密码技术等。应用程序开发者直接使用这些安全功能而无须了解其底层实现。
1. 加密密钥
密钥是密码体系操作的中心，它们必须安全保存，任何人获得某个密钥则对此密钥有关的任何数据都拥有了访问的权限。例如，某人得到了加密某文件的密钥，则他就可以解密此文件了。再比如，获取了对某消息签名的密钥，则可以伪造数字签名。
在CryptoAPI中，支持两种类型密钥：会话密钥、公/私密钥对。
会话密钥也称为对称密钥，用于对称加密算法，例如RC2、RC4、DES等。在CryptoAPI中，一般使用CryptGenKey 或 CryptDeriveKey函数产生会话密钥。为了保证密钥的安全性，这些密钥都保存在CSP内部。当然，用户也可以通过CryptExportKey函数把密钥以加密密钥块形式导出到具体应用空间内，以备以后使用或传输给其他用户。
公/私密钥对（包括公钥、私钥）用于非对称加密算法，例如RSA等。非对称加密算法主要用于加解密会话密钥和数字签名。在CryptoAPI中，一般来说，大多数 CSP产生的密钥容器包含两对密钥对，一对用于加密会话密钥，称为交换密钥对，一对用于产生数字签名，称为签名密钥对；但也有些CSP没有存储密钥对，或者存储不止两对密钥对。
在CryptoAPI中，所有的密钥都存储在CSP，CSP负责产生、销毁密钥，并使用它们完成各种密码操作。也可以利用CryptoAPI函数从CSP中导出密钥。
2. 数据编码/解码
通过通信媒介（例如电话线路）传输数据，必须先把数据序列化，即把数据转化为0、1串。在序列化操作中，接到数据的计算机必须能够把数据转化为其原始格式。序列化完成的操作规则称为通信协议，它由软件和数据传输硬件共同完成，其协议一般包含多层，图3-3为一个简化了的通信协议层。
下图表示：计算机1应用程序层先传输原文数据到编码/解码层，编码/解码层编码原文数据为计算机字节流，然后发送到硬件层，硬件层把字节流数据转化为0、1串流传输到计算机2。计算机2接到数据后，反向操作，转化0、1串流为计算机字节流，发送到编码/解码层，编码/解码层解码计算机字节流为原文数据。
一种可接受的软件设计原理是使用抽象化，即根据问题或对象的一般参数来描述，而不是要描述解决问题的所有细节或对象的所有细节。利用抽象化，设计者说明软件对象的特定性质而不必关心其具体实现，它简化了说明文档。抽象化是大多数现代软件规范的特点，并且多数通信协议都包含一些列的抽象化。
简化通信协议层  描述抽象对象的一个普遍方式为：ASN.1（抽象语法标记1），ASN.1在CCITT推荐文件X.208中定义，描述对象转换为0、1串的ASN.1规则称为DER（精确编码规则），在CCITT推荐文档X.509 8.7节定义。CryptoAPI采用的就是这种编码方式，表示数据发送方发送时先把数据抽象为ASN.1对象，然后使用DER编码规则把ASN.1对象转化为可传输的0、1串；接收方接到数据后，利用DER解码规则把0、1串转化为ASN.1对象，然后再把ASN.1对象转化为具体应用支持的数据对象。
3. 数据加/解密
把明文转化为密文的过程称为加密，反之把密文转化为明文的过程称为解密。加密较大的数据，CryptoAPI中约定用对称加密算法，这种算法中，在加密和解密过程中都使用同一个对称密钥或会话密钥。CryptoAPI中，通过其封装好的加解密函数来实现数据加解密操作，不同CSP提供不同的加解密算法，但常用的算法，一般CSP都提供。
4. 哈希与数字签名
哈希与数字签名一般用于确定数据的完整性和身份鉴别。CryptoAPI中，通过其封装好的哈希与数字签名函数来实现相关操作。微软提供的CSP产生的数字签名遵循RSA标准（PKCS#6），其他CSP可能遵循其他标准。
5. 数字证书
数字证书主要用于安全通信中的身份鉴别。CryptoAPI中，对数字证书的使用管理分为证书与证书库函数、证书验证函数。
6. 数字消息
任何被编码的数据都可称为消息，它是发送给其他人或实体（或从其他人或实体接收到）的编码数据，包括数字证书。在CryptoAPI环境中，消息一般会被签名或加密，或者同时被签名和加密。在CryptoAPI2.0版本中，消息处理函数一般分为两类：底层消息函数，简单消息函数。低级消息函数直接和PKCS#7 消息工作，简化消息函数是比较高级的函数，是对几个低级消息函数和证书函数的封装，用来执行指定任务。
下篇文章介绍如何使用CryptoAPI进行文件加解密，把我那烂代码拿出来给大家看。
</content>
    </entry>
    
     <entry>
        <title>博客更新主题通知！</title>
        <url>https://cppfans.org/962.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>主题</tag><tag>博客</tag>
        </tags>
        <content type="html"> 今天本博客更换了一套很素的主题，原先的热点新闻apple主题，也非常好看，但是看着太眼花缭乱了，觉得有点乱，所以换上了现在这套主题。
SimplePro-TT 作者为 李思章， 这个主题以前还是收费的，不过正好运气好，赶上免费，所以果断就换了，折腾了一下午。
觉得作者还是应该设置一些主题选项，比如说SEO关键字，广告位等，这样就更能支持大多数博主使用了，不过总的来说，我很喜欢，谢谢作者的主题了。
关于作者使用主题的条件有两条，一是保留作者链接，这点是无可厚非的，毕竟是别人的辛苦劳动成果；第二点保留侧边栏最底部的广告，我觉得这个就稍微有点过了，所以我去掉了那部分的代码，希望作者原谅。
装完改好之后发现后台登陆不了，去数据库又折腾了一阵，终于好了，现在这个主题看上去心里很舒服，能很快从烦躁中安静下来。
如果有朋友喜欢，可以也试试。同时，本博客大力欢迎各位朋友的访问和交流。
</content>
    </entry>
    
     <entry>
        <title>MFC控件 void DrawItem(LPDRAWITEMSTRUCT) 	{ ASSERT(FALSE); }</title>
        <url>https://cppfans.org/921.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>Assert</tag><tag>DrawItem</tag><tag>MFC</tag>
        </tags>
        <content type="html"> 今天帮一位小朋友写加密工具的时候，突然发现许久不用的MFC特生疏，控件函数都忘干净了，在查的基础上，勉强写了一个工具出来，挺简陋的，接个图给大家笑话下。

写到用ListBox来显示提示信息的时候，发现给Assert，跟进去之后发现是这一句导致的
[cpp]
void CListCtrlBox::DrawItem(LPDRAWITEMSTRUCT) { ASSERT(FALSE); }
[/cpp]
查了查google，说法很多，很多人都说要自己重载DrawItem函数，不过以前用的时候并没有这样做，所以可以肯定不是这个原因，再查了下，找到了方法，要设置这个ListBox的Owner Drow属性是Fixed，选择这个属性为No再次编译运行，并没有错误了，看来应该是从VS08就有了这个属性，我以前一直用的05所以没感觉到这个，现在换成10就出了这样一个问题，悲剧啊。
</content>
    </entry>
    
     <entry>
        <title>RakNet简单应用——hello World(服务器端)</title>
        <url>https://cppfans.org/901.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>RakNet</tag><tag>服务器</tag><tag>简单应用</tag>
        </tags>
        <content type="html"> 我们学习很多编程语言的时候都是从Hello world开始的，所以这次我们也打算开始从hello world写起，不过本文只写了服务器端，客户端后面一篇文章会放出来的，一个人写有点无聊，而且工程配置比较麻烦，一切都得按项目标准来，不能随便写写就好了，为了以后也可以用，就标准些吧。
(不过，还是写的很匆忙，很多东西没写好，后面会整理的)
说起 Hello world就不得不说一个非常经典的笑话了。
某程序员对书法十分感兴趣，退休后决定在这方面有所建树。于是花重金购买了上等的文房四宝。一日，饭后突生雅兴，一番磨墨拟纸，并点上了上好的檀香，颇有王羲之风范，又具颜真卿气势，定神片刻，泼墨挥毫，郑重地写下一行字：hello world
好了，言归正传，写一个简单的hello world的服务端的例子，客户端还没写，不过客户端好写一些，代码没整理，有点乱，各位见谅。
建立一个空的Win32 Console工程，在工程配置中加入RakNet的头文件和Lib文件，上篇中有提到的。
[cpp]
// MyChatServer.h
/************************
FileName:MyChatServer.h
Author :eliteYang
Mail :elite_yang[at]163.com
Desc :服务器头文件
TODO :后面再进行整理
************************/
#ifndef __MY_CHAT_SERVER_H\__
#define __MY_CHAT_SERVER_H\__
#pragma once
#include 
#include &amp;ldquo;RakPeerInterface.h&amp;rdquo; // RakNet Peer
#include &amp;ldquo;RakNetTypes.h&amp;rdquo;
#include &amp;ldquo;MessageIdentifiers.h&amp;rdquo; // RakNet自定义消息枚举定义处
#include &amp;ldquo;BitStream.h&amp;rdquo; // RakNet消息包的Bit数据流
#define MAX_CLIENTS 10
#define SERVER_PORT 60000
enum ChatMessagesDefine
{// 自定义消息枚举值，消息ID
MSG_CHATWORD = ID_USER_PACKET_ENUM &#43; 1, // 消息ID从RakNet定义的最后一个枚举开始
};
#endif
[/cpp]
[cpp]
// MyChatServer.cpp
#include &amp;ldquo;MyChatServer.h&amp;rdquo;
int main()
{
RakNet::RakPeerInterface* pPeer = RakNet::RakPeerInterface::GetInstance();
if ( NULL == pPeer )
{
std::cout &amp;lt;&amp;lt; &amp;ldquo;RakNet::RakPeerInterface::GetInstance() Error!&amp;rdquo; &amp;lt;&amp;lt; std::endl;
return -1;
}
else
{
std::cout &amp;lt;&amp;lt; &amp;ldquo;-&amp;ndash;-&amp;ndash;-&amp;ndash;MyChatServer Init Success&amp;copy;-&amp;ndash;-&amp;ndash;-&amp;mdash;-&amp;rdquo; &amp;lt;&amp;lt; std::endl;
}
RakNet::Packet* pPacket;
std::cout &amp;lt;&amp;lt; &amp;ldquo;Start Server &amp;hellip;&amp;hellip;&amp;rdquo; &amp;lt;&amp;lt; std::endl;
pPeer-&amp;gt;Startup( MAX_CLIENTS, &amp;amp;RakNet::SocketDescriptor( SERVER_PORT, 0 ), 1 );
pPeer-&amp;gt;SetMaximumIncomingConnections( MAX_CLIENTS );
while (1)
{
for ( pPacket = pPeer-&amp;gt;Receive(); pPacket; pPeer-&amp;gt;DeallocatePacket( pPacket ), pPacket = pPeer-&amp;gt;Receive() )
{
switch ( pPacket-&amp;gt;data[0] )
{
case ID_REMOTE_DISCONNECTION_NOTIFICATION:
std::cout &amp;lt;&amp;lt; &amp;ldquo;Another client has disconnected&amp;rdquo; &amp;lt;&amp;lt; std::endl;
break;
case ID_REMOTE_CONNECTION_LOST:
std::cout &amp;lt;&amp;lt; &amp;ldquo;Another client has lost the connection&amp;rdquo; &amp;lt;&amp;lt; std::endl;
break;
case ID_REMOTE_NEW_INCOMING_CONNECTION:
std::cout &amp;lt;&amp;lt; &amp;ldquo;Another client has connected&amp;rdquo; &amp;lt;&amp;lt; std::endl;
break;
case ID_CONNECTION_REQUEST_ACCEPTED:
{
std::cout &amp;lt;&amp;lt; &amp;ldquo;Our connection request has been accepted&amp;rdquo; &amp;lt;&amp;lt; std::endl;
RakNet::BitStream bsOut;
bsOut.Write( ( RakNet::MessageID )MSG_CHATWORD );
bsOut.Write(&amp;ldquo;Hello world&amp;rdquo;);
pPeer-&amp;gt;Send( &amp;amp;bsOut, HIGH_PRIORITY, RELIABLE_ORDERED, 0, pPacket-&amp;gt;systemAddress, false );
}
break;
case ID_NEW_INCOMING_CONNECTION:
std::cout &amp;lt;&amp;lt; &amp;ldquo;A connection is incoming&amp;rdquo; &amp;lt;&amp;lt; std::endl;
break;
case ID_NO_FREE_INCOMING_CONNECTIONS:
std::cout &amp;lt;&amp;lt; &amp;ldquo;The server is full&amp;rdquo; &amp;lt;&amp;lt; std::endl;
break;
case ID_DISCONNECTION_NOTIFICATION:
std::cout &amp;lt;&amp;lt; &amp;ldquo;A client has disconnected&amp;rdquo; &amp;lt;&amp;lt; std::endl;
break;
case ID_CONNECTION_LOST:
std::cout &amp;lt;&amp;lt; &amp;ldquo;A client lost the connection&amp;rdquo; &amp;lt;&amp;lt; std::endl;
break;
case MSG_CHATWORD:
{
RakNet::RakString rs;
RakNet::BitStream bsIn( pPacket-&amp;gt;data, pPacket-&amp;gt;length, false );
bsIn.IgnoreBytes(sizeof(RakNet::MessageID));
bsIn.Read( rs );
std::cout &amp;lt;&amp;lt; &amp;ldquo;%s&amp;rdquo;&amp;lt;&amp;lt; rs.C_String() &amp;lt;&amp;lt; std::endl;
}
break;
default:
std::cout &amp;lt;&amp;lt; &amp;ldquo;Message with identifier %i has arrived&amp;rdquo; &amp;lt;&amp;lt; pPacket-&amp;gt;data[0] &amp;lt;&amp;lt; std::endl;
break;
}
}
}
RakNet::RakPeerInterface::DestroyInstance( pPeer );
return 0;
}
[/cpp]
里面除过我自己定义的MSG_CHATWORD之外，其他都是RakNet自己的消息枚举，大家可以跳进去看看含义，就不一一讲解了。
这篇就先这样吧，后面将客户端的写法，其他的东西慢慢都会讲的，我也是一边应用一边分享给大家经验，勿喷，交流而已。
PS:VS2010用的真的有点不习惯，不过坚持用吧，而且笔记本写代码真的有点蛋疼。
</content>
    </entry>
    
     <entry>
        <title>初识RakNet (RakNet第二篇)</title>
        <url>https://cppfans.org/881.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>RakNet</tag><tag>使用</tag><tag>目录</tag><tag>编译</tag>
        </tags>
        <content type="html"> 上篇文章简单介绍了一下RakNet，现在我们初步的认识一下RakNet。
前面发的文章中有RakNet的压缩包，解压之后我们会看到RakNet的结构如下：

RakNet目录结构示意图  备注：关于CMake软件的使用以后等我自己使用后再讲解。
我自己用的VS2010编译器，源码中没有提供10的解决方案，所以使用VS08的sln文件转换了一下，一般08转到10应该都没什么问题，但是高版本转低版本可能会有问题，如果你安装的是VS05或者08那就可以直接用了，不用任何转换，目录结构我就不多讲了，用VS打开可以直接看的到，里面有两个工程选项DLL和Lib，请大家自己选择想要使用的库类型，由于两种库的加载方式和使用方式都不相同，请大家选择自己熟悉和喜欢的库文件类型，不过使用DLL文件要有导出函数列表供其他调用文件使用，Lib文件要提供头文件供其他调用文件使用。
选择Debug或者Release选项之后，在工程上右键生成或者重新生成，可生成对应的库文件，我使用的是Lib文件，编译后在Lib文件夹中产生了
RakNetLibStatic.lib (Release版本)
RakNetLibStaticDebug.lib (Debug版本)
(当然你也可以选择直接使用源代码到你的项目，不过文件太多太麻烦了，并且如果你对库有做自己的封装，出于安全和机密考虑，可以使用库文件)
好了，时间不早了，睡觉了，等明天给大家带来使用RakNet第一个小例子。各位也早点睡吧。
</content>
    </entry>
    
     <entry>
        <title>关于留言和交换链接事项的说明！</title>
        <url>https://cppfans.org/879.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 最近留言内容中的垃圾信息越来越多，都是博客留言软件自动发的，觉得很烦，幸好有 Akismet 插件过滤垃圾内容，所以说明一下，如果你是真的留言想说点什么，请尽量语言正式一点，以免被过滤，谢谢合作。
有很多人在博客中留言中说想与本博客交换链接，留下了一些网址。我再次清楚地说一次，本博客只与内容相近的博客类或者论坛类交换链接，如果你是冲着本博客的pr4会给你的网站带来一些流量或者数据的话，请千万不要开口说交换链接。就像异次元的小X说的那样，友情链接友情链接，有友情才有链接，我们都不认识，互相链接有意思吗？没有任何意义，大家应该多交流才能建立友谊，才能互相学到东西，如果单纯的为了做网站而交换链接，劝君还是罢了。
&amp;nbsp;
以上就是我关于这两件事情的说明，希望大家理解一下，继续关注我的博客。大家已经很明显的感觉到了，博客的文章更新速度变慢了，其实是在酝酿更好的内容给大家，RakNet的文章已经开始写了，希望大家持续关注，多多交流。
</content>
    </entry>
    
     <entry>
        <title>RakNet简单介绍，最新版本分享</title>
        <url>https://cppfans.org/877.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>RakNet</tag><tag>下载</tag><tag>服务器</tag><tag>游戏</tag><tag>网络引擎</tag>
        </tags>
        <content type="html"> 前一阵简单的看了看RakNet的东西，觉得挺好用，想写一点东西给大家分享，还是从最基础的讲起吧，虽然有点俗套，不过真不知道怎么写这些东西，各位见谅。
什么是RakNet？
Raknet是一个基于UDP网络传输协议的C&#43;&#43;网络库，允许程序员在他们自己的程序中实现高效的网络传输服务。通常情况下用于游戏，但也可以用于其它项目。

Raknet相对于其他网络引擎有什么好处？
    高性能 在同一台计算机上，Radnet可以实现在两个程序之间每秒传输25，000条信息；   容易使用的 Raknet有在线用户手册，视频教程。每一个函数和类都有详细的讲解，每一个功能都有自己的例程；   跨平台，当前Raknet支持Windows, Linux, Macs，可以建立在Visual Studio, GCC, Code: Blocks, DevCPP 和其它平台上；   在线技术支持 RakNet有一个活跃的论坛，邮件列表，你只要给他们发信，他们可以在几小时之内回复你。   安全的传输 RakNet在你的代码中自动使用SHA1, AES128, SYN，用RSA避免传输受到攻击   音频传输 用Speex编码解码，8位的音频只需要每秒500字节传输。   远程终端 用RakNet，你能远程管理你的程序，包括程序的设置，密码的管理和日志的管理。   目录服务器 目录服务器允许服务器列举他们自己需要的客户端，并与他们连接。   Autopatcher Autopatcher系统将限制客户端传输到服务端的文件，这样是为了避免一些不合法的用户将一些不合法的文件传输到服务端。   对象重载系统   网络数据压缩 BitStream类允许压缩矢量，矩阵，四元数和在-1到1之间的实数。   远程功能调用    强健的通信层 可以保障信息按照不同的信道传输   4.0加入云服务功能，增加C#调用    RakNet是否开源？  RakNet支持两种版权，如果你是用作个人项目，RakNet将是免费的。如果用在商业用途，需要购买商业授权。  如何获得RakNet？  官方网站：http://www.jenkinssoftware.com/ 通过注册等一系列操作，可以获得，大家都可以看懂并通过操作获得对应的源代码。  当然了，大家如果觉得麻烦，可以通过我的网盘获得这个资源，我已经获得了最新版本的RakNet  下载地址如下：RakNet_PC_4.031.zip  </content>
    </entry>
    
     <entry>
        <title>祝大家国庆快乐!</title>
        <url>https://cppfans.org/849.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>国庆</tag><tag>道歉</tag>
        </tags>
        <content type="html"> 明天就是国庆节了，可能很多人在加班，很多人已经到家了，可能还有很多人在归家的旅途上，不管您现在是什么状态，先跟大家说一声国庆快乐，有时间就回去与家人团聚下。
对于近期我的博客出现很多软文的现象，我在这里做出解释，我的博客有postlinks的广告，做过wp博客的朋友应该都知道，这是一个链接广告商，然后按照软文数量和链接数量给银子，而且是美国的银子。这个也是在别的博客赚钱的网站看到的，第一个月只有一篇软文，还可以接受，不过这个月竟然连续发了九篇软文，导致我的博客出现了很多大家不愿意看到的垃圾内容，在此对大家带来的槽糕印象做出诚挚的道歉。我承诺，从国庆节后的日子里，我的博客再也不会出现软文了，前面的软文全部删除，还大家一个清静的博客。
后面的文章将会以技术文章为主，不过前提是我有些许闲暇的时间，所以大家有期待最好了，但是千万不要期待过高，怕没那么多时间写，希望大家可以谅解，谢谢！
最后，祝大家国庆期间休息好、玩好、吃好，后面3个月的时间里的工作更顺利。
</content>
    </entry>
    
     <entry>
        <title>[转]为什么中国的程序员技术偏低</title>
        <url>https://cppfans.org/784.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>程序员</tag>
        </tags>
        <content type="html"> 首先来说一个高级程序员并非靠自己读几本书写几万行代码就能练就的，我更关注于低层的环境，也就是程序员实实在在的工作环境。因为程序员的高低还得 从实际的工作来衡量，而非其它。所以我想说的是，中国的软件公司的性质直接导致程序员的水平的高低。而我所说的软件公司，不是指某个或者某几个，而是指主 流的软件公司，大众型的软件公司。所以我希望那些已经步入一个理想的公司的程序员理解我这篇文章的定位。 软件公司的无偿加班对程序员的影响：
国内的软件公司中程序员是常常加班的，每日加，周未也常加。基于这种性质，出现了一种很莫名其妙的现象：每天程序员的实际下班时间总是要晚于规定下班时 间，至于晚一个小时还是两个小时还是更多这就另说，总之，程序员这份工作，如果按时下班反而自己感觉自己像是做贼似的。表面上公司并没有强迫谁加班，但实 际上在潜移默化中有一种威慑力，要求你要多为公司工作几个小时，而且表面上你所工作的这几个小时还是你自己愿意的。正因为是“自己愿意的”，所以公司更有 理由认为是无偿的。
还有就是周未加班，一般周未加班是因为“忙”（关于这个带引号的“忙”，见“软件公司的‘忙’对程序员的影响”）。但周未加班一般是无偿的，至于法律所规 定的那种“偿”就更尝不上了。不过一般公司是这样规定的：周未加班可以倒休。关于倒休，一般是周未的班真的加了，倒休却遥遥无期，原因很简单，公司 “忙” 嘛！
这种情况对程序员的影响：消极、软弱无主见、虚伪、对前途渺茫。
软件公司的“忙”对程序员的影响：
软件公司的“忙”其实有时也是真忙，从原因来说，软件公司认为是程序员（其实也有其他员工，但本文不涉及讨论）造成的，程序员认为公司造成的。而根据“一 个巴掌拍不响”原则来看，应该是公司与程序员合作不协调出现的恶性循环造成的。深层原因大家自己研究去吧。不过从我这里的表象来看，这种“忙”有这么几 点，这几点如果不代表大家的意见，大家可以补充：
**项目开发与计划脱节，表现为项目开发慢于计划。
**突如其来的事件。
**为某种说不清道不明的原因，像是作秀。
**假忙。
**真忙。
上面说的第一种情况最常见，这涉及到软件工程的话题，其实也是软件公司做不大，程序员水平提不高的核心。而“软件公司做不大”已有前辈文章《浅谈:国内软件公司为何无法做大做强?》中说过了，而“程序员水平提不高”本文所言即是，所以这个原因大家读完这两篇自己体会吧。
上面说的第二种情况也常有，比如偶尔赶个标书，比如客户那里突然出现了BUG，急着去改等等。
第三种情况就很让人晕菜了，有点无病呻吟的感觉，比如不知道从哪里冒出一个会议，开到个七八点；
第四种情况很特别，也比较常见，大家同室坐、彼此各自心。一片共同耕作的美好景象，但果实见不到两颗豆呢。这可是大家齐心虚度时光。程序员可以拿出这个时间提高自己吗？当然不可以了，你表面上还是得干活呢。
第五种情况就不说了，因为这是正根。
总之软件公司是“忙”的，一般是以上三种“忙”，偶尔这三种都没有了，第四种就马上出来的。
这种情况对程序员的影响：混乱无序、怨由心生、虚伪做作、学习时间少。
软件公司的流程不规范对程序员的影响：
无像样的需求、无像样的设计、没有测试、没有文档、没有维护（所谓维护也大都是客户测试出BUG来改一改）。
其实说到需求这一块也并非完全是软件公司的问题，大多数情况下，客户也是根据程序员直接上来编码后暴露出来的问题才渐渐明白自己的需求是什么的。
“什么都没有”的问题在于，什么也不清楚，如果写一堆以不变应万变的代码，第一，时间不允许，第二，难度太大。要是稀里糊涂去实现，扩展与维护性又差，整个一堆豆腐渣工程，总之是没法下手。长了一堆“打铁”技巧，神不像神，程序员不像程序员的。
这种情况对程序员的影响：无规划性、代码质量低、手忙脚乱、技术永远停留在“打铁”水平。
软件公司对程序员员工的“全能型”要求对程序的影响：
装系统、修打印机、写文档、编代码、见客户、扫地搬桌子、接网线，在国内软件公司中程序员做什么事都有可能。单单说技术方面，也是要求事事能做，看一下招聘要求就知道了。
这种情况对程序员影响：术业无专攻
软件公司的工资拖欠对程序员的影响：
很悲哀，这是存在的。我向来认为一个员工与公司合作的最底线应该是按时按量发工资。但很多公司打破了这个底线。一个朋友开玩笑地说过：“家庭有钱，谁干程 序员呀！”这话虽只可信一半，但是从国内情况来看，程序员的生活质量还是不高的，工资的拖欠直接影响到程序员的心态，甚至影响到程序员的生活。
这种情况对程序员影响：低调、迷茫、心态不稳、思想徘徊、生活困难。
软件公司对软件开发的要求对程序员的影响：
软件公司对软件开发的要求一般是实现即可。如果说写一个和记事本一样的程序，公司感觉程序员应该在一天内搞定；如果写一个WPS，公司也就感觉程序员应该 在两到三个月搞定。这不是浮夸，事实就是这样的。公司所着眼的点在于“就这么一点功能”，而非在于“怎么实现这‘一点’功能。
这种情况对程序员的影响：开发难度大、维护难度大、压力大、难沟通。
软件公司的承诺对程序员的影响：
国内软件公司一般实际行动能力差，但没理难说话，他们也知道自己没理，所以比较爱承诺，把实际问题抛向以后解决。然而承诺也只是口头的，有一点“我以人格 担保”的意思。不过一般情况下，国内的程序员还是比较有忍耐能力的（从上文来看不忍耐还能混吗），但公司层面的“人格”却是不可信，多承诺少兑现，员工面 试时听到的说话到干了两年走了都没做到的事根本不少见。然而路遥马乏力，日久人变心，这样的结果往往是使公司与员工走入恶性循环。
这种情况对程序员的影响：不满、被动、拿不起放不下、进退两难。
结论：
消极、软弱无主见、虚伪、对前途渺茫、混乱无序、怨由心生、虚伪做作、学习时间少、无规划性、代码质量低、手忙脚乱、技术永远停留在“打铁”水平、术业无 专攻、低调、迷茫、心态不稳、思想徘徊、生活困难、开发难度大、维护难度大、压力大、难沟通、不满、被动、拿不起放不下、进退两难。
上面这些短语概括了程序员的性格、心态、生活环境、工作环境等方面，它们就像毒素一样，日久能把一个健康的程序员毁掉。在这样的环境下，还问为什么你的技术这么低？太搞笑了。
</content>
    </entry>
    
     <entry>
        <title>生日纪念</title>
        <url>https://cppfans.org/769.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 近两天来很多朋友打电话，发短信，QQ留言，微博留言等方式纷纷发来对我的生日祝福，对这些朋友和兄弟都非常感谢，希望你们每天也都顺利，工作上争取进步，学习上努力向上，总之一些都好，我比较词穷了。
刚刚回来，发这篇文章纪念一下，24岁了，唉！又老了一岁，祝大家开心！
</content>
    </entry>
    
     <entry>
        <title>博客100篇文章纪念</title>
        <url>https://cppfans.org/765.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          
        </tags>
        <content type="html"> 开始写这个博客已经快一年了，工作忙的缘故，写的文章也没多少，最近刚刚看到文章统计有100篇文章了，特此写个小文纪念一下，也没写多少东西给大家看，不过还是有人来一部分人来看的，先谢谢你们。
后面会逐渐向程序开发类文章转型的，科技报道和软件分享的文章就会稍微少了一些，希望给大家留下一个这个博客是搞开发的而不是别的内容的印象。
期待后面的内容吧，我自己也在努力学习更多内容的东西，希望好的东西可以与大家分享，大家有好的原创文章也可以向本博申请投稿，投稿方式请见 “关于” 页面的联系方式
</content>
    </entry>
    
     <entry>
        <title>本次开放测试卡建号问题分析——MySQL配置优化方法</title>
        <url>https://cppfans.org/712.html</url>
        <categories>
          <category>心情随笔</category><category>程序开发</category>
        </categories>
        <tags>
          <tag>MySQL</tag><tag>优化</tag>
        </tags>
        <content type="html"> 本次的开放测试依然在进行中，昨天关于卡建号的问题大家讨论了一下解决办法，对逻辑方面也检查了一下，不过逻辑方面很久都没人改过了，如果出问题应该两个项目都出问题，结果另外一个从来不卡的，所以应该不是逻辑上的问题，结果去检查MySQL的配置，才发现了原因。
是MySQL中打Log过于频繁导致的原因，原来的配置是 innodb_flush_log_at_trx_commit = 1，有一条处理就等待写LLog到磁盘，写入磁盘想对耗时比价多，所以非常卡，本次测试参数是1的测试结果是60-90毫秒，修改成2之后，使用客户端创建一个角色的时间是0 ms，用机器人创建1000个角色压力测试的结果是13ms，这个结果还可以接受，1分钟3000多账号，完全可以理解。前面运维测试的时间是200ms一个，所以呢，又被玩家骂了一顿啊，悲惨的命运。
简单搜了一下MySQL优化的配置给大家分享下：
 my.ini配置建议：
table_cache=1024
物理内存越大,设置就越大.默认为2402,调到512-1024最佳
innodb_additional_mem_pool_size=4M
默认为2M
innodb_flush_log_at_trx_commit=1
(设置为0就是等到innodb_log_buffer_size列队满后再统一储存,默认为1)
innodb_log_buffer_size=2M
默认为1M
innodb_thread_concurrency=8
你的服务器CPU有几个就设置为几,建议用默认一般为8
key_buffer_size=256M
默认为218 调到128最佳
tmp_table_size=64M
默认为16M 调到64-256最挂
read_buffer_size=4M
默认为64K
read_rnd_buffer_size=16M
默认为256K
sort_buffer_size=32M
默认为256K
max_connections=1024
默认为1210
thread_cache_size=120
默认为60
query_cache_size=32M
 以下是另一个的my.ini配置建议： &amp;gt; &amp;gt; port=3306
 default-character-set=latin1
default-storage-engine=INNODB
sql-mode=”STRICT_TRANS_TABLES,NO_AUTO_Create_USER,NO_ENGINE_SUBSTITUTION”
max_connections=120
query_cache_size=32M
#缓存数据表数量,设置这个参数可以参见系统状态中的 open_tables(表示当前打开的数据表总数) 和 opened_tables(表示所有打开的数据表总数)
table_cache=256
#临时表的大小
tmp_table_size=12M
#缓存可重用的线程数
thread_cache_size = 64
myisam_max_sort_file_size=100G
myisam_max_extra_sort_file_size=100G
myisam_sort_buffer_size=64M
#这对MyISAM表来说非常重要。如果只是使用MyISAM表，可以把它设置为可用内存的 30-40%。合理的值取决于索引大小、数据量以及负载 — #记住，MyISAM表会使用操作系统的缓存来缓存数据，因此需要留出部分内存给它们，很多情况下数据比索引大多了。
key_buffer_size=128M
read_buffer_size=1M
read_rnd_buffer_size=512K
sort_buffer_size=1M
#这对innodb表来说非常重要
innodb_buffer_pool_size = 256M
#这取决于你需要的回复速度.128M这个数值是适当的恢复时间和良好性能之间的一个好的平衡.
innodb_log_file_size = 128M
#大多数情况4M足够,除非正将很大的blob数据导入到Innodb中可以增加一点.
innodb_log_buffer_size=4M
#这个值取决于你的程序,可能高或者低.8是代表起始值.
innodb_thread_concurrency=8
innodb_additional_mem_pool_size=100M
#如果你不是很关心ACID,可以容许在系统完全crash的情况下丢失最后一两秒的事务,那么可以设置这个值.它可以极大的提高”短”的写事务的效率.
innodb_flush_log_at_trx_commit=2
注意：
很多情况需要具体情况具体分析
1&amp;gt;如果Key_reads太大，则应该把my.cnf中Key_buffer_size变大，保持Key_reads/Key_read_requests至少1/100以上，越小越好。
2&amp;gt;如果Qcache_lowmem_prunes很大，就要增加Query_cache_size的值
 晚上听到一个很悲剧的消息，我们小组长和头因为运维发了一个带%的公告，导致服务器宕机，被扣钱了，没有做特殊字符检测，同时忘记告诉运维了，这个本来应该是运维平台发消息过来，在发之前应该就屏蔽掉的，结果两边都没有做检查，就出现悲剧的事情了。下次还是小心一些微妙，仔细认真的态度做任何事情总是没错的。
</content>
    </entry>
    
     <entry>
        <title>8.19的开放测试，不好不坏的开场吧</title>
        <url>https://cppfans.org/706.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>测试</tag><tag>项目</tag>
        </tags>
        <content type="html"> 8.19号项目正式开放测试，准时2点开始，从周四晚上就一直在修问题，主要原因是时间太紧张了，而且有较多的新功能，所以导致一个晚上都在修问题，好不容易修到四点总算差不多了。一个同事修Bug到7点，然后很晕的在公司宿舍眯了会，结果旁边修东西的，游戏室玩桌球的，各种吵啊。
到下午2点，开始测了，陆续进来一些玩家，前面还算好吧，后面压力逐渐上来，主要还是体现在MySql的性能上了，堆积了大量的信息需要插入数据库，从而导致MySQL处理不过来，用户创建角色一直在卡，后面重启了MySQL服务之后又回归正常了，这期间应该流失了不少人，也算我们这次的大失误，上次就出现这个问题，一直以为是数据库服务器的问题，没有细查下去，这次全暴露出来了。
可能换到Oracle或这Key-Value类型的数据库会好一点，或者说是逻辑某处有问题，总的来说，除过这个问题之外，其他还算正常，最郁闷的是充值也很慢，可是银子在流失啊。
明天还得去公司查数据库的问题，不早了，各位晚安了。
</content>
    </entry>
    
     <entry>
        <title>[杂侃]高铁事故系无证程序员Bug所致？？？</title>
        <url>https://cppfans.org/600.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>程序员</tag>
        </tags>
        <content type="html"> 今天网络上突然传出说找到了温州高铁事故的原因找到了，系两名无证程序员写的代码Bug所致。以下是新闻原文：
 中新网温州7月25日电(记者 赵晔娇)浙江省温州市公安局常务副局长、新闻发言人沈强今天在接受中新网采访时表示，目前没有收到所谓“甬温线铁路调度员被拘”的报告。
有网上消息称，“温州事故原因有新进展：铁路调度程序员出现BUG(故障)是本次事故的根本原因，警方已经拘留了两名无证程序员。案件在进一步审理中。”沈强在回应记者求证时作以上表示。(完)
 突然我们团队懵了，什么叫无证程序员？什么叫有证程序员？什么证才能算得上有证呢？来上海参加网游开发已经一年了，整天都很忙，关注新闻的时间少了很多，温州动车事故之后，在调查了几天之后突然发现警方逮捕了两名无证程序员，这在程序这个圈子里引发了很大的争议，“证”到底是个啥东西。CU和CSDN，包括各大微博在内的，基本都在热议。
我们团队的头突然发话了，我计算机毕业的，算作有二级证吧。一个同事说幸亏我考了软考，否则还真说不过去了。其他人都傻了眼了，颤抖的声音问道“证是什么？”。突然大家都懂了，我们都是无证程序员啊，我们在犯罪，说不定那一天某位玩家玩游戏猝死了，追究其责任来，就说这是一群无证程序员团队制作的，好了，万事大吉。该该拘的拘，该枪毙的枪毙。
这年头，果然是坑爹的年代，躺着也中枪啊。从明天开始，认真写代码吧，否则无证程序员就是你的Title。
</content>
    </entry>
    
     <entry>
        <title>[转]我们需要一种其他人能使用的编程语言</title>
        <url>https://cppfans.org/594.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>编程</tag><tag>语言</tag>
        </tags>
        <content type="html"> 原作者Chris Tompkins以前是一位记者，此文基本是从一个新手的角度来讨论编程语言。此文在Reddit上的标题很有意思：“新闻记者说编程很难，希望能像买西红柿一样简单”，讨论也很激烈，约500多条评论，其中有不少精彩评论。 最近，我开始从头努力学习Objective-C语言，可是我无法摆脱的事情是：它实在太难了。一位有经验的开发人员可能会嘲笑我讲的这句话，但确实 是这样的。我要坦诚地对待我的教育，微积分II是我学过的最高级别的数学，我在美国加州大学柏克莱分校拿到新闻学的高等学位。我是一个熟练的HTML / CSS开发人员，我能把javascript粘合起来，以解决几乎任何出现的问题。第一次遇到C语言是在一个社区大学中，那时我13岁，我觉得它的语法重 复，并且目标不明确，所以很多年来我总是避开着。
现在，过了好多年后又尝试要重新学起，你可能会指责我不够努力，但很明显这是不对的——我将继续埋头学习Objective-C语言，直到我能熟练运用它为止。然而，我发现C语言是一种不能扩展学习的语法，背后有着极度复杂的系统。
复杂性的困扰
说C语言太复杂，这是因为它需要非常详细的语法来实现计算机上的所有功能（或可能的功能）。我承认它的特殊性，因为它要跨平台，与多平台的硬件有相互 作用，但学习C语言不是一定要自下而上的。我想按着我的奇思妙想使之进行，我想这样做的并不会只有我一人。我不禁想到由博士创造出的语言竟也会遭受“复杂 性的困扰”。换句话说，那些知道了这一点的人对于简化它并不感兴趣，因为这让他们的知识贬值了。
编码逐渐成为计算机基础知识的重要组成部分。在当前信息技术如此重要的社会，这种看法是不能持续的。
要是我们有更好的代码杂货店，事情就较为简单了
最近，我陪女朋友去杂货店买东西，我们在一堆堆的新鲜水果和蔬菜中翻找着做饭要用到的所有材料。这个情景使我想到，为什么编码不能更像这样一点？我 想，要更像是在挑选做饭用到的材料。学习C语言就像在学习西红柿的基因序列一样。要长出西红柿当然需要有基因序列，可是要把它切片以及加入我的材料清单 中，我并不需要熟悉它。这超出了准备一餐饭菜所需要知道的常识。
最重要的是，如果每个想成为厨师的人，在做一餐饭菜时都需要知道一份番茄的基因序列，那么他们可能就永远都不会抽空出来做饭了。事实上，他们当然不会是一位非常成功的基因学家，所以他们就更可能永远也不会成为一名厨师。
没有足够的库、基础代码、以及其他合适的代码聚集地
我所说的是并不是新时代中的一些Visual Basic程序或C语言的一个WYSIWYG程序，而是一种自然语言的语法，它通过调用C语言的对象库来使其简单易学。
编注：WYSIWYG，是“what you see is what you get”的缩写，即“所见即所得”。
因为电脑程序日益成为人们日常生活中不可缺少的一部分，我们需要帮助孩子学习代码，这将使他们受益终生。可是强制他们学习高级别级的数学技巧和晦涩的 计算机语言（用“*”表示指针，“.”缩写语法）是不现实的。这使拥有好奇心的小孩学不到基本的技能，阻碍了他们为以后要学习的多变量微积分打好基础。与 此同时，其余的人能够受益于一个程序设计语言，他们不需要花几年的时间去学习。简而言之，我们需要有一种语言，它能够让那些数学领域的门外汉懂得使用；它 包含有更自然的语法（是的，这是有可能的）；它使得初级开发人员不需用到规模庞大的术语库就能为其定义和编写脚本。你知道在所有的各种C语言的分支所使用 的方法调用机制的数量吗？
让代码尽可能简单，对于我们中其余的人来说是一种仁慈
可以把复杂的C语言分支机构可以浓缩成一系列的目对象吗？——这些对象可以用自然语言串联到一起。我是这样认为的，可是目前这远远超出我的能力范围。 我知道我们不能继续使编程语言日趋复杂下去，否则，它最终会变得过于复杂，只有最专业的用户才能使用。这个人造壁垒，将阻碍几千甚至几百万的人的声音得以 实现。
译文出处：伯乐在线 - 职场博客 - 程序员
译文链接：http://www.jobbole.com/entry.php/1124
原文：Chris Tompkins　翻译：敏捷翻译 - 张瑞霞
现在程序开发的门槛越来越低了，很多智能化的框架为大家提供了更多的更便捷的通道，使得喜欢自己开发的朋友都实现了想法，所以只要目标是相同的，语言之争已经很多年了，没必要了，做好自己的事情就行了，任何事情都是看个人能力的，虽然也有学历等因素，不过只是问路石而已。
</content>
    </entry>
    
     <entry>
        <title>[转]可视化的数据结构和算法</title>
        <url>https://cppfans.org/416.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>Algorithm</tag><tag>可视化</tag><tag>数据结构</tag><tag>算法</tag>
        </tags>
        <content type="html">  原文地址：http://coolshell.cn/articles/4671.html
还记得之前发布过的那个关于可视化排序的文章吗？在网上又看到了一个旧金山大学David Galles做的各种可视化的数据结构和基本算法的主页，网址在这里，大家可以看看。我把这个页面的目录列在下面并翻译了一下，大家可以直接点击了。
不知道国内的教育有没有相关的教学课件，至少在我大学的时候是没有的。
基础  Stack栈: 数组实现 Stack栈: 链表实现 Queues队列: 数组实现 Queues队列: 链表实现 Lists列表: 数组实现 ( java 版演示) Lists列表: 链表实现 ( java 版演示)  索引  Binary Search Trees 二叉检索树 AVL Trees (平衡二叉检索树) Red-Black Trees 红黑树 ( flash 版本演示) Open Hash Tables 开放哈希表(Closed Addressing 链地址法) Closed Hash Tables 闭合哈希表 (Open Addressing 开放定址法) Closed Hash Tables, using buckets 使用桶 B Trees B树 B&#43; Trees B&#43;树  &amp;nbsp;

   排序     Comparison Sorting 比较式排序   Bubble Sort 冒泡排序   Selection Sort 选择排序   Insertion Sort 插入排序   Shell Sort 希尔排序   Merge Sort 归并排序   Quck Sort 快速排序     Bucket Sort 桶排序   Counting Sort 计数排序   Radix Sort 基数排序    堆数据结构    Heaps 堆   Binomial Queues 二项队列    图 算法    Breadth-First Search 广度优先搜索   Depth-First Search 深度优先搜索   Connected Components 连通性   Dijkstra’s Shortest Path Dijkstra最短路径   Prim’s Minimum Cost Spanning Tree 最小生成树   Topological Sort 拓扑排序 ( flash 版本演示 java 版本演示)   Floyd-Warshall 算法(解决任意两点间的最短路径的一种算法) (flash 版本演示 java 版本演示)   基于Kruskal算法的最小生成树的构建 ( flash 版本演示 java 版本演示)    动态编程    计算 Fibonacci 数 ( java 版本演示)    其它…    Disjoint Sets （MIT算法公开课中有一课讨论的是这个，见网易公开课）   Huffman Coding 哈夫曼编码 ( java 版本演示)    </content>
    </entry>
    
     <entry>
        <title>[多图]TortoiseSVN配置管理使用</title>
        <url>https://cppfans.org/349.html</url>
        <categories>
          <category>实用软件</category>
        </categories>
        <tags>
          <tag>TortoiseSVN</tag><tag>使用</tag><tag>教程</tag>
        </tags>
        <content type="html">  本文最开始有我写在锋酷开发社区(www.flycode.org)，现转载过来供大家查看。 一.下载并安装TortoiseSVN程序，点击Next，下图为安装顺序
点击【Finish】会重新启动计算机，重启后，运行中文语言包进行汉化。
二、TortoiseSVN的基本使用方法  
安装完成后，我们来看一下如何使用TortoiseSVN。
1.签入源代码到SVN服务器
假如我们用VS在Test文件夹建立了一个项目，现在我们要把这个项目签入到SVN Server的代码库里，首席那我们右键点击Test文件夹，右键菜单显示如下图
点击Import，出现如下窗体，其中http://Server IP/为服务器名，可以自己设置，SVN为代码仓库，Test为我们要签入的项目代码库
注意：左下角的CheckBox，第一次提交代码没有用，以后会非常有用的。
点击OK，弹出如下窗体，会要求输入凭据。
在上面的窗口中输入用户名和密码，点击OK
如上图所示，我们的源代码已经成功签入SVN服务器了，我们的团队成员就可以迁出SVN服务器上的源代码到自己本地机器上了。
2.迁出源代码到本机
在本机创建Test文件夹，右键点击文件夹，点击CheckOut，
同签入一样，同样要输入服务器地址，还有迁出路径，CheckOut Depth,有四种方式，分别是迁出全部，只迁出下一级子目录和文件，只迁出文件，只迁出空项目，默认是第一个。上述例子中，我们也可以使用浏览器来完 成，在浏览器中输入服务器地址，同样要求验证用户。
现在我们的源码已经迁出到我们的Test文件夹下了，打开，可以看到如下的文件夹结构。
一旦对文件或者文件夹做了任何修改，其图标就会发生改变，下图修改了两个文件
看一下不同状态对应的图片，如下图：
现在我们已经知道如何签入迁出代码，也了解了不同图标代表的意思。 3.提交修改的代码到SVN 
上面我们修改了两个文件，下来看看如何将修改的代码提交到SVN。
在文件夹上点击右键或者再文件夹目录下空白处点击右键，在右键菜单上点击SVN Commit...
点击OK后，弹出如下窗体
4.添加新文件到SVN 
我们建立了一个新的文件UserInfo.cs，右键点击SVN Commit...与上面操作相同就可以了，也可以在文件上点击右键，点击TortoiseSVN = Add，弹出如下窗体
选择要提交的文件前的CheckBox，点击OK，但是注意这个时候我们的文件并没有提交到SVN上去，只是做了一个标记，之后我们还要SVN Commit一次，才算真正提交到SVN上了。
5.更新本机代码与SVN服务器上一致 
在需要更新的文件夹上点击右键，点击SVN Update就可以了。
注意：更新有时会因为版本冲突而失败，这里可以使用[Merge]或者其他方法解决，有可能是因为锁定[Get Lock]而失败,需要先解锁[Release Lock]。
6.重命名文件或者文件夹
右键点击TortoiseSVN = Rename...，在弹出的窗体输入新名称，点击OK，不过还需要SVN Commit 一次才算提交。
7.删除文件或者文件夹 
其实最简单的方法是删除后重新提交，不过还可以在要删除的文件或者文件夹上右键点击TortoiseSVN = Delete，不过也不算是真正删除，而是加上删除的标志，需要再次SVN Commit一次才算真正删除。 注意：提交代码时，不要提交bin，obj等文件夹，否则会很麻烦。  以上只是TortoiseSVN几个简单的使用方法，大家在以后的使用过程中慢慢体会更多功能。希望大家能够学会如何SVN，因为团队合作是这个东西很有用处。 </content>
    </entry>
    
     <entry>
        <title>第一个项目《水浒无双》3.25正式封测</title>
        <url>https://cppfans.org/320.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>水浒无双</tag><tag>游戏</tag>
        </tags>
        <content type="html"> 最近一直在忙公司的项目，不过都是瞎忙，没做出来多少东西，万幸这个项目在月底要封测了，封测顶几天，然后就可以休息一阵了。
简单的先说说这个项目，名字叫《水浒无双》，很狗血的名字，剧情呢，主要是以水浒传为蓝本，尊重原作的前提下，适当的修改了一些东西，至于宣传上说的硬派武侠风格，我就不多说了，大家玩的时候自然会体验到，好的话，留言捧个场，不好的话说出你的意见，请文明用语，健康游戏。
本次封测时间为3.25下午两点，整个封测时间可能是两天，也有可能是两周，看情况而定。
账号申请网址：水浒官网
贴张图片给大家看
 不早了，休息了，各位晚安！ </content>
    </entry>
    
     <entry>
        <title>【C/C&#43;&#43;】sprintf中如何将容器作为可变参数列表传入</title>
        <url>https://cppfans.org/254.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>C/C&#43;&#43;</tag>
        </tags>
        <content type="html"> 近日做脚本接口时遇到一个变参的传入接口，因为我们游戏中的脚本系统是自定义的，这个接口的参数因为是可变，所以将参数读进来存入一个Vector容器中，然后利用Sprintf格式化之后发送给客户端做逻辑，以前的做法就是switch&amp;hellip;case&amp;hellip;这个容器中元素的个数，然后sprintf( szBuff, nBuffSize - 1, szFormat, vtVar[0], vtVar[1], ……)，而如今要变参，这样的方法肯定是行不通了，想了一下截取字符串的方法存入，尝试了一下，是可以行得通的，与大家分享一下代码。
希望大家有更好的方法可以交流，谢谢！
[c]
#include 
#include 
#include 
using namespace std;
void ScriptSprintf( char* szBuf, int nBufSize, const char* szText,
const std::vectorstd::string&amp;amp; vtVar )
{
string strTemp(szText);
const char* szSpn = &amp;ldquo;%s&amp;rdquo;;
int nBeginPos = 0;
int nEndPos = 0;
string strSub;
if ( vtVar.empty() )
{
strncpy_s( szBuf, nBufSize - 1, szText, nBufSize - 1);
return;
}
std::vector::const_iterator iterBegin = vtVar.begin();
std::vector::const_iterator iterEnd = vtVar.end();
for ( ; iterBegin != iterEnd; &#43;&#43;iterBegin )
{// 容器元素的操作建议还是使用迭代器，因为vtVar为const，所以迭代器为const_iterator
strSub.clear();
nEndPos = strTemp.find(szSpn);
if ( nEndPos != strTemp.length() ) // 找到了%s
{
strSub = strTemp.substr(nBeginPos, nEndPos - nBeginPos &#43; 2); // 截取前面的字串XXX%s
strTemp = strTemp.substr(nEndPos &#43; 2, strTemp.length() - nEndPos - 2); // 缩短strTemp
// 特别注意此处的strlen，他可以将字串往后加
sprintf( szBuf &#43; strlen(szBuf), strSub.c_str(), iterBegin-&amp;gt;c_str() ); // 按格式存入
}
}
if ( !strTemp.empty() )
{// 如果为XXX%sYYY，%s以前的字串前面已经处理过，剩余的字串还需要拼起来
strncpy( szBuf, strTemp.c_str(), strTemp.length() );
}
}
int _tmain(int argc, _TCHAR* argv[])
{
char szBuf[1024] = {0};
const char* szText = &amp;ldquo;AAA%sBBB%sCCC%sDDD%sEEE%s&amp;rdquo;;
std::vectorstd::string vtVar;
vtVar.push_back(&amp;ldquo;1&amp;rdquo;);
vtVar.push_back(&amp;ldquo;2&amp;rdquo;);
vtVar.push_back(&amp;ldquo;3&amp;rdquo;);
vtVar.push_back(&amp;ldquo;4&amp;rdquo;);
vtVar.push_back(&amp;ldquo;5&amp;rdquo;);
ScriptSprintf(szBuf, 1023, szText, vtVar);
cout&amp;lt;&amp;lt;szBuf&amp;lt;&amp;lt;endl;
system(&amp;ldquo;pause&amp;rdquo;);
return 0;
}
[/c]
</content>
    </entry>
    
     <entry>
        <title>最近工作生活的一点小总结</title>
        <url>https://cppfans.org/229.html</url>
        <categories>
          <category>心情随笔</category>
        </categories>
        <tags>
          <tag>感悟</tag>
        </tags>
        <content type="html">   最近两周工作中，感觉明显状态不行了，每天做的事情都非常少，效率极低，有可能是年前封闭太累了，封闭完之后，直接过年了，所以状态包括身体都感觉比较疲惫导致的。 并且，最近跟策划沟通方面也显得比较毛糙，可能是年龄小了一点，很多东西都没考虑到，焦躁了一些吧。这毛病得改改了。 最近有点心高气傲，犯了一些低级错误，导致效率非常低，也可能是琐事缠身吧，一堆的Bug和新需求，确实很烦，没有安排好时间。 最近并没有学习新的东西，主要还是忙，不过，这个世界上有很多比我牛的人，这个世界上还有很多比我拼命的人，但是却还存在很多比我人还比我拼命的人。  所以，今天好好反思了一下，首先是效率优先，需要我做的东西还有很多，正如上面所说的一样“催着别人要东西不是更爽一些吗？”。其次是准确无误，不然到后面一堆Bug还是头疼。最后是提高心境，我不是那种坐在沙漠里闭上眼睛能感觉到沙滩上两只螃蟹在洞口划拳的人，也没必要到那种境界，只需戒掉浮躁的心理，改掉唐突的毛病。 再次借用图中的文字勉励一下自己吧，摘自rangerLee的QQ签名，“不与百花争艳，独领淡泊幽香”，做幕后的服务器人员。 Nerver giver up , fighting , 火鸟！
 </content>
    </entry>
    
     <entry>
        <title>【资料分享】网游[天龙八部]源代码分享</title>
        <url>https://cppfans.org/204.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>天龙八部</tag><tag>游戏</tag><tag>源代码</tag><tag>网游</tag>
        </tags>
        <content type="html"> 天龙八部这款游戏，从一到二，可谓是改进了很多东西，因为对网游玩的不是很多，所以对其中的特色也就不做介绍了，大家喜欢的话可以亲自去玩玩体验一下。不过在国内，天龙这款网游还是非常棒的，在玩家心目中有一定的地位。
废话不多说了，我想与大家分享的是天龙八部1的源代码，应该是比较旧的一版源代码。
包括：
客户端源代码
服务器源代码
工具源代码
压缩包大小为700多M，解压出来有3G多，由于都是代码文件，文件非常多，解压起来非常慢，请大家耐心等待。
为什么说这个代码非常旧呢？看其中的文件配置都是TXT，而如今游戏的数据配置都是XML了，更方便读取。不过其中服务器端网络模块和客户端的东西还是可以看看的，对研究网游有很大的帮助。逻辑的东西建议大家就不要看了，因为逻辑就那样写，最多就是效率差一些，后面多整理几次就好了，而且逻辑复杂，不知道他们的策划如何设计的，逻辑看起来也是非常吃力的，纯粹浪费时间，所以建议不要看了。
源代码下载地址：天龙八部源代码
声明：本代码源自互联网，仅供程序开发者学习所用，请勿用在商业用途，如有侵权，请通知我删除，谢谢合作！
btw.由于最近一直有很多朋友留言询问压缩包的解压密码，其实压缩包注释里有写的，不过那段密码中有部分是乱码，导致大家凌乱了，所以特写说明压缩包密码。
天龙八部压缩包密码为：[view.asp?article_id=2467 6蒅蒅犌::] (不含方括号，如有问题，请及时询问，谢谢！)
</content>
    </entry>
    
     <entry>
        <title>Lua基础语法</title>
        <url>https://cppfans.org/113.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>Lua</tag><tag>语法</tag>
        </tags>
        <content type="html"> 注释
像我们这样的码农，接触新语言第一个想的肯定是如何打注释，代码写不出来，伪代码总能写的出来一些。Lua中的注释使用两个短线来表示本行以后是注释内容，使用&amp;ndash;[[ &amp;ndash;]]来注释多行内容，例如
&amp;lt;br /&amp;gt; print (1); --打印1，单行注释&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;print (1); --[[这里是多行注释，&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;本行也被我注释掉了，到对应的符号结束。--]]
老生常谈的Hello world !
print(&amp;quot;Hello world !&amp;quot;); --本例也可以没有最后的“;”，因为写C/C&#43;&#43;习惯了，所以不自主的
&amp;ndash;会加上分号，该分号可以没有的。
把这句代码写在一个 .lua 文件里，然后进入控制台，在控制台运行Lua.exe文件，
输入指令 lua hello.lua
即可看到该文件的输出。
【题外话：Lua有一个编辑软件叫LuaForWindows，安装之后会自动加入系统变量，创建Lua.exe和Luac.exe，有一个控制台和编辑器，算是比较好用了，编辑器里面可以调试，挺强大的，如果大家觉得手动写Lua脚本容易出错，建议使用该软件。】
Chunks
Chunk是Lua中一系列语句的称呼，也可能是Lua中的每一块语句，可以是一个语句，或者很多语句、函数等。例如：在Lua.exe下执行的每一条语句都是一个Chunk。
每个语句结尾的分号（;）是可选的，但如果同一行有多个语句最好用；分开。
在交互模式(控制台)下，lua通常会把一行作为一个Chunk，但是Lua的一行不是一个完整的Chunk，它会等待你输入完整再执行，等待未完的后续行时，给出不同的提示符，一般是&amp;gt;&amp;gt;
假设我们有一个脚本
&amp;lt;br /&amp;gt; function norm (x, y)
local n2 = x^2 &#43; y^2
return math.sqrt(n2)
end
function twice (x)
return 2*x
end
在交互模式下：
&amp;lt;br /&amp;gt; &amp;gt; dofile(&amp;quot;lib1.lua&amp;quot;)
  n = norm(3.4, 1.0)
 print(twice(n))
 dofile在调试或者测试Lua代码时是很方便的。(关于Linux下的Lua，不懂，所以不讲！)
全局变量
全局变量就是不属于任何一个函数的变量，就像在C/C&#43;&#43;中，我们写的全局变量一样，不同的是，Lua中的全局变量不初始化会默认为Nil(Lua中对空的表示)，而C/C&#43;&#43;中会给随机值，所以记住要初始化。
例如：
&amp;lt;br /&amp;gt; a = 10;
print(a);
删除全局变量很简单，将其值设为Nil就行了
a = 10
print(a)
a = nil
print(a) &amp;ndash;a = nil
关键字/词法约定
标示符：字母(letter)或者下划线开头的字母、下划线、数字序列.最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。Lua中，letter的含义是依赖于本地环境的。
保留字：以下字符为Lua的保留字，不能当作标识符。
 and break do else elseif end false for function if
in local nil not or repeat return then true until while
 注意：Lua是大小写敏感的.
剩下的内容由于最近时间的问题，暂时先搁置，提供一本电子书给大家看，Lua的经典教程
DOWNLOAD:《Programming in lua》
</content>
    </entry>
    
     <entry>
        <title>Lua语言语法讲解的一点准备文章</title>
        <url>https://cppfans.org/107.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>Lua</tag>
        </tags>
        <content type="html"> (本文主要是对Lua的一点小解释和对后面的准备，如果读者不喜欢，可以略过……)
什么是Lua语言？
Lua是一种轻量语言，它的官方版本只包括一个精简的核心和最基本的库。这使得Lua体积小、启动速度快。它用标准C语言编写并以源 代码形式开放，编译后仅仅一百餘K，可以很方便的嵌入别的程式裡。和许多&amp;rdquo;大而全&amp;rdquo;的语言不一样，网路通讯、图形界面等都没有預設提供。但是Lua可以很 容易地被扩展：由宿主语言（通常是C或C&#43;&#43;）提供这些功能，Lua可以使用它们，就像是本来就内置的功能一样。事实上，现在已经有很多成熟的扩展模块可供选用。
Lua是一种多重编程范式的程式设计语言：它只提供了很小的一个特性集合来满足不同编輯范式的需要，而不是为某种特定的编輯范式提供繁杂的特性支援。例如，Lua并不提供继承这个特性，但是你可以用元表来模拟它。诸如名字空间、类这些概念都没有在语言基本特性中实现，但是我们可以轻易的用表结构（Lua唯一提供的复杂数据结构）轻易模拟。Lua可以在运行时随时构造出一个函数，并把它看作一个对象（正是所谓的first class function），这个特性可以很好的满足函数式编程的需要。这是提供了这些基本的元特性，我们可以任意的对语言进行自需的改造。
Lua原生支援的数据类型非常之少，它只提供了 数字（缺省是双精度浮点数，可配置）、布尔量、字符串、表、子程序、协程（coroutine）以及用户自定义数据这几种。但是其处理表和字符串的效率非常之高，加上元表的支援，我们可以高效的模拟出需要的复杂数据类型（比如集合、数组等）。
Lua是一个动态弱类型语言，支援增量式垃圾收集策略。有内建的，与操作系统无关的协作式多线程（coroutine）支援。
Lua有什么优点？
Lua语言是一个巴西人发明的，98年开始制定，最后一个版本5.1.4是08年发布的。不过到了暴雪做魔兽世界和魔兽争霸时才将其发扬光大了，真正成了当之无愧的“脚本之王”。
其优越性主要表现为以下几个方面：
① 可扩展性。Lua的扩展性非常卓越，以至于很多人把Lua用作搭建领域语言的工具（注：比如游戏脚本）。Lua被设计为易于扩展的，可以通过Lua代码或者C代码扩展，Lua的很多功能都是通过外部库来扩展的。Lua很容易与C/C&#43;&#43;、java、fortran、Smalltalk、Ada，以及其他语言接口。
② 简单。Lua本身简单，小巧；内容少但功能强大，这使得Lua易于学习，很容易实现一些小的应用。他的完全发布版（代码、手册以及某些平台的二进制文件）仅用一张软盘就可以装得下。
③ 高效率。Lua有很高的执行效率，统计表明Lua是目前平均效率最高的脚本语言。
④ 与平台无关。Lua几乎可以运行在所有我们听说过的系统上，如NextStep、OS/2、PlayStation II (Sony)、Mac OS-9、OS X、BeOS、MS-DOS、IBM mainframes、EPOC、PalmOS、MCF5206eLITE Evaluation Board、RISC OS，及所有的Windows和Unix。Lua不是通过使用条件编译实现平台无关，而是完全使用ANSI (ISO) C，这意味着只要你有ANSI C编译器你就可以编译并使用Lua。
什么人适合使用Lua？
Lua使用者分为三大类：使用Lua嵌入到其他应用中的、独立使用Lua的、将Lua和C混合使用的。
第一：很多人使用Lua嵌入在应用程序，比如CGILua（搭建动态网页）、LuaOrb（访问CORBA对象。这些类型用Lua-API注册新函数，创建新类型，通过配置Lua就可以改变应用宿主语言的行为。通常，这种应用的使用者并不知道Lua是一种独立的语言。例如：CGILua用户一般会认为Lua是一种用于Web的语言。
第二：作为一种独立运行的语言，Lua也是很有用的，主要用于文本处理或者只运行一次的小程序。这种应用Lua主要使用它的标准库来实现，标准库提供模式匹配和其它一些字串处理的功能。我们可以这样认为：Lua是文本处理领域的嵌入式语言。
第三：还有一些使用者使用其他语言开发，把Lua当作库使用。这些人大多使用C语言开发，但使用Lua建立简单灵活易于使用的接口。
本书面向以上三类读者。书的第一部分阐述了语言的本身，展示语言的潜在功能。我们讲述了不同的语言结构，并用一些例子展示如何解决实际问题。这部分既包括基本的语言的控制结构，也包括高级的迭代子和协同。
第二部分重点放在Lua特有的数据结构——tables上,讨论了数据结构、持久性、包及面向对象编程，这里我们将看到Lua的真正强大之处。
第三部分介绍标准库。每个标准库一章：数学库、table库、string库、I/O库、OS库、Debug库。
如何使用Lua？
1.从Lua官方网站下载lua源码包，最新版本下载地址为：
2.下载了之后，里面的结构为：doc(帮助文档) etc(一些额外补充的文件) src(Lua语法源码) test(测试使用的例子)
3.网上有的地方提供Lua.exe和Luac.exe，用来执行Lua脚本和将编写的Lua脚本打包成二进制文件，加快编译，同时也可以检查你写的脚本的正确性。还有的地方提供其他的工具等等。
有人说这种方法可以得到Lua.exe luac.exe，我自己试了一下，在Windows下不可以的，各位请自己试下，如果生成不了那两个文件，可以下载LuaBind或者LuaPlus，里面有编译好的文件。方法如下：
 解压文件，比如解压到 D:/lua-5.1.2 文件夹内（以下均以此路径为例）。
在 D:/lua-5.1.2 内，存在名为 /etc 的子目录。在此目录下找到 luavs.bat 文件，并将它复制到 D:/lua-5.1.2 中。
双击执行 luavs.bat 批处理文件，如果执行成功，在 D:/lua-5.1.2/src 文件夹中会存在 luac.exe 和 lua.exe两个文件。
将 D:/lua-5.1.2/src 加入到系统路径中
 4.Lua文件的编辑器，确切的说Lua没有一个标准的编辑器，不像其他语言那样都有一个合适的工具来编辑文本，不过Lua文件可以随便使用一款文本编辑器来编辑，有一些朋友自己开发的编辑器，像LuaEdit什么的，不过个人觉得使用NotePad&#43;&#43;就足够了，免费开源，支持绝大数编程语言着色，非常好用，以后有机会会详细介绍该款编辑器的。
5.补充说明一下，很多人可能要问，那这个怎么在Windows系统上配置？再次说明，lua是一门语言，其配置就是将其加入到系统路径中，然后将写出来的脚本用lua.exe测试一下就行了
好了，下来我们就要正式开始学习lua的语法了，前面的可能没什么用，但是了解一些总是没什么坏处。下文开始讲Lua的语法了，希望大家关注！
</content>
    </entry>
    
     <entry>
        <title>[教程预告]lua系列文章通知</title>
        <url>https://cppfans.org/102.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>Lua</tag><tag>教程</tag>
        </tags>
        <content type="html"> 
最近一直在做关于脚本方面的东西，所以就想写一写关于自己对脚本这块东西的小见解。
脚本系统在一个游戏中发挥的作用个人觉得非常巨大，比如游戏中的任务，活动，AI，玩法等等很多东西都要用脚本来控制。脚本对游戏的可玩性和多玩性做了很大的贡献。
脚本语言可谓种类繁多，比如lua, perl, python, 甚至是自定义的脚本等等，每种语言都有自己的优缺点，对于perl和Python不是很熟，所以对此不表态，而最近由于工作中一直在用lua，相对来说还是比较熟悉，而且由于暴雪(Blizzard)在魔兽争霸3(Warcraft III)和魔兽世界(WOW)中大量使用lua脚本的缘故，一下捧红了这个巴西前辈发明的lua脚本语言。
不过说实话，由于lua脚本可以任意编辑，每次程序打开的时候会加载该脚本，不需要重编译，所以优越了一些，并且跟C/C&#43;&#43;的结合性，导致其在游戏开发中越来越红。
每次写东西前都喜欢唠叨一阵，各位看官就当听故事了，千万不要见怪啊。我安排了一个lua应用系列的文章，希望大家会喜欢。
由于个人使用环境是Windows，所以教程都是在win环境下的，如果你需要看Linux下的，请在网上看其他人的帖子。
具体目录如下：
1.lua在Windows环境下的配置和简单测试
2.lua基础语法讲解
3.lua高级语法讲解(虽然高级语法自己也不是很懂，不过献献丑了，也当自己学习了一次)
4.LuaBind的配置和使用
5.LuaBind在C&#43;&#43;中的应用
6.LuaPlus的配置和使用
7.LuaPlus在C&#43;&#43;中的应用
// TODO:待补充
由于C&#43;&#43;调用Lua中的类用的不是很多，而且自己也不是很明白，所以这块东西暂时不讲解了，能力有限，望多包涵。
</content>
    </entry>
    
     <entry>
        <title>游戏服务器程序基础1-内存/类型转换/编程习惯</title>
        <url>https://cppfans.org/85.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>内存</tag><tag>服务器</tag>
        </tags>
        <content type="html"> 内存管理方式
游戏服务端的工作主要就是实时的处理用户的逻辑，存取，大量数据包的收发，这其中，网络因素是一个重要的原因，这个东西无法避免，但是更重要的是程序内部的运作方式，通常我们知道，程序中最耗资源与硬件的不是程序的执行和操作，主要是内存和资源的频繁切换，让CPU和内存一直在忙。其实就是 new/delete的问题，他们一般都是用来申请小块内存的，长时间申请问造成内存出现碎片，从而导致机器性能下降，对服务器程序来说，响应速度像生命一样，所以，传统的内存管理方式就行不通了。
为了避免使用new/delete带来的问题，一般采用两种方法：
1.从一开始就是用静态分配内存后再使用，我们知道，静态内存申请后会在程序运行时一直使用，不会释放，只能改变其中存的数据，这样就避免了大量的申请与释放内存的操作。
2.使用MemoryPool(内存池)，这块的内存池得自己写，一般的游戏中都有自己单独写的内存池代码，这个后面再说。
在制作服务器程序，这两种都有使用，不过大块的内存基本都是使用MemoryPool，小块且局部内存基本使用静态内存。
类型的问题
这块的东西主要是个人习惯问题，如果有优良的编程习惯，一般没什么问题。特别是像类型转化与typedef的时候需要注意一下。
Const的使用
其实我觉得这个问题我不应该多说，该用的地方用就行了，不过很多人就吃亏在这个const上了，这个东西用多了就熟悉了，多用几次，肯定会熟练的。主要是看清楚const的位置，它是将这个常属性加在了那个部分，这样基本就没有什么问题了。
类型转化的方法
一般的数据类型转化的方法，基本都是强制转化，不过这样某些时候会带来一些非确定的问题。一般是基本数据类型可以直接强转类型，继承类对象之间可以强转类型，转化方式大家都很清楚,如下：
(Type*)SourceType // Type 为要转为的类型,SourceType为原来要转的对象
类型转化还存在以下四种转化方式，
dynamic_cast 主要是在相互间有继承关系的对象指针或者引用之间做类型转化的时候经常使用到。一般(type*)强转类型就是使用dynamic_cast
static_cast 只是逻辑上的功能类型转换，大部分用在继承关系的指针类型转换
reinterpret_cast 他是一种没有任何限制的类型的转换，从任何类型可以转化到任何类型，不过这个时候，编译器就不负任何责任了。如果你愿意使用，就使用吧。
const_cast 主要用于将const常量转换为non-const类型
其他的一些功能大家去网上搜下，说的肯定更详细。我就不做赘述了。
希望大家喜欢，有问题，欢迎指正和补充.
</content>
    </entry>
    
     <entry>
        <title>游戏开发基础知识2——函数指针</title>
        <url>https://cppfans.org/83.html</url>
        <categories>
          <category>程序开发</category>
        </categories>
        <tags>
          <tag>函数指针</tag>
        </tags>
        <content type="html"> 前面介绍了如何进行模块化以及Lib库的制作，关于库的制作，后面会再次深入讲解的，不过可能会在锋酷开发社区(www.flycode.org)上做一个专题来讲解的，到时候希望大家关注下。
前面我们已经说过了，再多人合作开发过程中，模块化显得非常重要。在模块化开发过程中呢，比较重要的就是函数指针了，大家都知道C&#43;&#43;的一个很重要的特征就是多态，函数指针可以让你更轻松的使用这个特征。函数指针可以指向你自己写的函数地址，就像Windows编程中的事件和消息一样，包括菜单等的一些操作都是使用函数指针的，API编程中的callback函数就是一个典型的例子。
[c]/*
** Copyright &amp;copy; www.cppfans.org All rights reserved.
**Author:eliteYang
*/
void PtrFunction( void (*fp)(int, int), int Data)
{
cout&amp;lt;&amp;lt;”I’m using ptrFunction”&amp;lt;&amp;lt;”Result1:”&amp;lt;&amp;lt;Result1&amp;lt;&amp;lt;” ”&amp;lt;&amp;lt;”Result2:″&amp;lt;&amp;lt;Result2&amp;lt;&amp;lt;endl;
}
[/c]
通过上面的例子，我们可以看到，这个有点类似于重载函数，不过重载函数是三同（返回类型相同，函数名称相同，参数列表参数个数相同），而函数指针可以看到是两同（返回值相同，参数列表类型和个数相同，调用的函数名不同）。
==============================================================================
Windows函数与数据类型的使用
关于Windows中的函数我觉得在MFC和API中用的非常多，到处可见，这些都要大家在平时编程中经常使用就会比较熟悉了，不懂得可以多查查MSDN，相信如果你从事Windows开发的，相信你会经常看MSDN的。
数据类型，比如BOOL，size_t，BYTE，DWORD，DWORD PTR，LPCSTR，LPCTSTR等，如果你真的感兴趣的话，可以通过转到定义看看他们的定义，一般都是如下格式的：
#define XXX YYY //其实就是个宏定义，改名而已，大家不要觉得奇怪
常用的数据类型请查看原文章中的表格或者MSDN
还有一些Windows中的函数，我觉得大家可以自己去查查，我在此就不多赘述了。
为什么要使用Windows中的数据结构和函数？
因为目前大部分的网络游戏都是在Windows系统上运行的，而且像DX和MFC都是基于Windows系统的，为了更好的切合Windows系统，只好使用Windows中函数了，而且由于现在的系统平台分为很多，32位，64位等，Windows系统中提供的数据类型在不同的系统中长度一般来说是不相同的，但是由于这些数据类型时Unicode类型的，所以尽管在不同的系统平台上，他们的大小变化还是一致的，不会出现越界等内存泄露情况，所以这就注定了游戏开发中基本都是使用Windows上的一套东西。
好了，今天暂时先说这么多了，基础的内容爱语很多，不过相信大家都有一些基础储备的，不懂得东西多查查多看看，后面会开始进入服务器开发的一些基础内容，希望大家继续关注。
 </content>
    </entry>
    
</search>